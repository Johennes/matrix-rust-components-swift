// This file was autogenerated by some hot garbage in the `uniffi` crate.
// Trust me, you don't want to mess with it!
import Foundation

// Depending on the consumer's build setup, the low-level FFI code
// might be in a separate module, or it might be compiled inline into
// this module. This is a bit of light hackery to work with both.
#if canImport(matrix_sdk_ffiFFI)
import matrix_sdk_ffiFFI
#endif

fileprivate extension RustBuffer {
    // Allocate a new buffer, copying the contents of a `UInt8` array.
    init(bytes: [UInt8]) {
        let rbuf = bytes.withUnsafeBufferPointer { ptr in
            RustBuffer.from(ptr)
        }
        self.init(capacity: rbuf.capacity, len: rbuf.len, data: rbuf.data)
    }

    static func from(_ ptr: UnsafeBufferPointer<UInt8>) -> RustBuffer {
        try! rustCall { ffi_matrix_sdk_ffi_8d0d_rustbuffer_from_bytes(ForeignBytes(bufferPointer: ptr), $0) }
    }

    // Frees the buffer in place.
    // The buffer must not be used after this is called.
    func deallocate() {
        try! rustCall { ffi_matrix_sdk_ffi_8d0d_rustbuffer_free(self, $0) }
    }
}

fileprivate extension ForeignBytes {
    init(bufferPointer: UnsafeBufferPointer<UInt8>) {
        self.init(len: Int32(bufferPointer.count), data: bufferPointer.baseAddress)
    }
}

// For every type used in the interface, we provide helper methods for conveniently
// lifting and lowering that type from C-compatible data, and for reading and writing
// values of that type in a buffer.

// Helper classes/extensions that don't change.
// Someday, this will be in a library of its own.

fileprivate extension Data {
    init(rustBuffer: RustBuffer) {
        // TODO: This copies the buffer. Can we read directly from a
        // Rust buffer?
        self.init(bytes: rustBuffer.data!, count: Int(rustBuffer.len))
    }
}

// Define reader functionality.  Normally this would be defined in a class or
// struct, but we use standalone functions instead in order to make external
// types work.
//
// With external types, one swift source file needs to be able to call the read
// method on another source file's FfiConverter, but then what visibility
// should Reader have?
// - If Reader is fileprivate, then this means the read() must also
//   be fileprivate, which doesn't work with external types.
// - If Reader is internal/public, we'll get compile errors since both source
//   files will try define the same type.
//
// Instead, the read() method and these helper functions input a tuple of data

fileprivate func createReader(data: Data) -> (data: Data, offset: Data.Index) {
    (data: data, offset: 0)
}

// Reads an integer at the current offset, in big-endian order, and advances
// the offset on success. Throws if reading the integer would move the
// offset past the end of the buffer.
fileprivate func readInt<T: FixedWidthInteger>(_ reader: inout (data: Data, offset: Data.Index)) throws -> T {
    let range = reader.offset..<reader.offset + MemoryLayout<T>.size
    guard reader.data.count >= range.upperBound else {
        throw UniffiInternalError.bufferOverflow
    }
    if T.self == UInt8.self {
        let value = reader.data[reader.offset]
        reader.offset += 1
        return value as! T
    }
    var value: T = 0
    let _ = withUnsafeMutableBytes(of: &value, { reader.data.copyBytes(to: $0, from: range)})
    reader.offset = range.upperBound
    return value.bigEndian
}

// Reads an arbitrary number of bytes, to be used to read
// raw bytes, this is useful when lifting strings
fileprivate func readBytes(_ reader: inout (data: Data, offset: Data.Index), count: Int) throws -> Array<UInt8> {
    let range = reader.offset..<(reader.offset+count)
    guard reader.data.count >= range.upperBound else {
        throw UniffiInternalError.bufferOverflow
    }
    var value = [UInt8](repeating: 0, count: count)
    value.withUnsafeMutableBufferPointer({ buffer in
        reader.data.copyBytes(to: buffer, from: range)
    })
    reader.offset = range.upperBound
    return value
}

// Reads a float at the current offset.
fileprivate func readFloat(_ reader: inout (data: Data, offset: Data.Index)) throws -> Float {
    return Float(bitPattern: try readInt(&reader))
}

// Reads a float at the current offset.
fileprivate func readDouble(_ reader: inout (data: Data, offset: Data.Index)) throws -> Double {
    return Double(bitPattern: try readInt(&reader))
}

// Indicates if the offset has reached the end of the buffer.
fileprivate func hasRemaining(_ reader: (data: Data, offset: Data.Index)) -> Bool {
    return reader.offset < reader.data.count
}

// Define writer functionality.  Normally this would be defined in a class or
// struct, but we use standalone functions instead in order to make external
// types work.  See the above discussion on Readers for details.

fileprivate func createWriter() -> [UInt8] {
    return []
}

fileprivate func writeBytes<S>(_ writer: inout [UInt8], _ byteArr: S) where S: Sequence, S.Element == UInt8 {
    writer.append(contentsOf: byteArr)
}

// Writes an integer in big-endian order.
//
// Warning: make sure what you are trying to write
// is in the correct type!
fileprivate func writeInt<T: FixedWidthInteger>(_ writer: inout [UInt8], _ value: T) {
    var value = value.bigEndian
    withUnsafeBytes(of: &value) { writer.append(contentsOf: $0) }
}

fileprivate func writeFloat(_ writer: inout [UInt8], _ value: Float) {
    writeInt(&writer, value.bitPattern)
}

fileprivate func writeDouble(_ writer: inout [UInt8], _ value: Double) {
    writeInt(&writer, value.bitPattern)
}

// Protocol for types that transfer other types across the FFI. This is
// analogous go the Rust trait of the same name.
fileprivate protocol FfiConverter {
    associatedtype FfiType
    associatedtype SwiftType

    static func lift(_ value: FfiType) throws -> SwiftType
    static func lower(_ value: SwiftType) -> FfiType
    static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType
    static func write(_ value: SwiftType, into buf: inout [UInt8])
}

// Types conforming to `Primitive` pass themselves directly over the FFI.
fileprivate protocol FfiConverterPrimitive: FfiConverter where FfiType == SwiftType { }

extension FfiConverterPrimitive {
    public static func lift(_ value: FfiType) throws -> SwiftType {
        return value
    }

    public static func lower(_ value: SwiftType) -> FfiType {
        return value
    }
}

// Types conforming to `FfiConverterRustBuffer` lift and lower into a `RustBuffer`.
// Used for complex types where it's hard to write a custom lift/lower.
fileprivate protocol FfiConverterRustBuffer: FfiConverter where FfiType == RustBuffer {}

extension FfiConverterRustBuffer {
    public static func lift(_ buf: RustBuffer) throws -> SwiftType {
        var reader = createReader(data: Data(rustBuffer: buf))
        let value = try read(from: &reader)
        if hasRemaining(reader) {
            throw UniffiInternalError.incompleteData
        }
        buf.deallocate()
        return value
    }

    public static func lower(_ value: SwiftType) -> RustBuffer {
          var writer = createWriter()
          write(value, into: &writer)
          return RustBuffer(bytes: writer)
    }
}
// An error type for FFI errors. These errors occur at the UniFFI level, not
// the library level.
fileprivate enum UniffiInternalError: LocalizedError {
    case bufferOverflow
    case incompleteData
    case unexpectedOptionalTag
    case unexpectedEnumCase
    case unexpectedNullPointer
    case unexpectedRustCallStatusCode
    case unexpectedRustCallError
    case unexpectedStaleHandle
    case rustPanic(_ message: String)

    public var errorDescription: String? {
        switch self {
        case .bufferOverflow: return "Reading the requested value would read past the end of the buffer"
        case .incompleteData: return "The buffer still has data after lifting its containing value"
        case .unexpectedOptionalTag: return "Unexpected optional tag; should be 0 or 1"
        case .unexpectedEnumCase: return "Raw enum value doesn't match any cases"
        case .unexpectedNullPointer: return "Raw pointer value was null"
        case .unexpectedRustCallStatusCode: return "Unexpected RustCallStatus code"
        case .unexpectedRustCallError: return "CALL_ERROR but no errorClass specified"
        case .unexpectedStaleHandle: return "The object in the handle map has been dropped already"
        case let .rustPanic(message): return message
        }
    }
}

fileprivate let CALL_SUCCESS: Int8 = 0
fileprivate let CALL_ERROR: Int8 = 1
fileprivate let CALL_PANIC: Int8 = 2

fileprivate extension RustCallStatus {
    init() {
        self.init(
            code: CALL_SUCCESS,
            errorBuf: RustBuffer.init(
                capacity: 0,
                len: 0,
                data: nil
            )
        )
    }
}

private func rustCall<T>(_ callback: (UnsafeMutablePointer<RustCallStatus>) -> T) throws -> T {
    try makeRustCall(callback, errorHandler: {
        $0.deallocate()
        return UniffiInternalError.unexpectedRustCallError
    })
}

private func rustCallWithError<T, F: FfiConverter>
    (_ errorFfiConverter: F.Type, _ callback: (UnsafeMutablePointer<RustCallStatus>) -> T) throws -> T
    where F.SwiftType: Error, F.FfiType == RustBuffer
    {
    try makeRustCall(callback, errorHandler: { return try errorFfiConverter.lift($0) })
}

private func makeRustCall<T>(_ callback: (UnsafeMutablePointer<RustCallStatus>) -> T, errorHandler: (RustBuffer) throws -> Error) throws -> T {
    var callStatus = RustCallStatus.init()
    let returnedVal = callback(&callStatus)
    switch callStatus.code {
        case CALL_SUCCESS:
            return returnedVal

        case CALL_ERROR:
            throw try errorHandler(callStatus.errorBuf)

        case CALL_PANIC:
            // When the rust code sees a panic, it tries to construct a RustBuffer
            // with the message.  But if that code panics, then it just sends back
            // an empty buffer.
            if callStatus.errorBuf.len > 0 {
                throw UniffiInternalError.rustPanic(try FfiConverterString.lift(callStatus.errorBuf))
            } else {
                callStatus.errorBuf.deallocate()
                throw UniffiInternalError.rustPanic("Rust panic")
            }

        default:
            throw UniffiInternalError.unexpectedRustCallStatusCode
    }
}

// Public interface members begin here.


fileprivate struct FfiConverterUInt8: FfiConverterPrimitive {
    typealias FfiType = UInt8
    typealias SwiftType = UInt8

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt8 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: UInt8, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

fileprivate struct FfiConverterUInt16: FfiConverterPrimitive {
    typealias FfiType = UInt16
    typealias SwiftType = UInt16

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt16 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

fileprivate struct FfiConverterUInt32: FfiConverterPrimitive {
    typealias FfiType = UInt32
    typealias SwiftType = UInt32

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt32 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

fileprivate struct FfiConverterInt32: FfiConverterPrimitive {
    typealias FfiType = Int32
    typealias SwiftType = Int32

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Int32 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: Int32, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

fileprivate struct FfiConverterUInt64: FfiConverterPrimitive {
    typealias FfiType = UInt64
    typealias SwiftType = UInt64

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt64 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

fileprivate struct FfiConverterInt64: FfiConverterPrimitive {
    typealias FfiType = Int64
    typealias SwiftType = Int64

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Int64 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: Int64, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

fileprivate struct FfiConverterBool : FfiConverter {
    typealias FfiType = Int8
    typealias SwiftType = Bool

    public static func lift(_ value: Int8) throws -> Bool {
        return value != 0
    }

    public static func lower(_ value: Bool) -> Int8 {
        return value ? 1 : 0
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Bool {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: Bool, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

fileprivate struct FfiConverterString: FfiConverter {
    typealias SwiftType = String
    typealias FfiType = RustBuffer

    public static func lift(_ value: RustBuffer) throws -> String {
        defer {
            value.deallocate()
        }
        if value.data == nil {
            return String()
        }
        let bytes = UnsafeBufferPointer<UInt8>(start: value.data!, count: Int(value.len))
        return String(bytes: bytes, encoding: String.Encoding.utf8)!
    }

    public static func lower(_ value: String) -> RustBuffer {
        return value.utf8CString.withUnsafeBufferPointer { ptr in
            // The swift string gives us int8_t, we want uint8_t.
            ptr.withMemoryRebound(to: UInt8.self) { ptr in
                // The swift string gives us a trailing null byte, we don't want it.
                let buf = UnsafeBufferPointer(rebasing: ptr.prefix(upTo: ptr.count - 1))
                return RustBuffer.from(buf)
            }
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> String {
        let len: Int32 = try readInt(&buf)
        return String(bytes: try readBytes(&buf, count: Int(len)), encoding: String.Encoding.utf8)!
    }

    public static func write(_ value: String, into buf: inout [UInt8]) {
        let len = Int32(value.utf8.count)
        writeInt(&buf, len)
        writeBytes(&buf, value.utf8)
    }
}


public protocol AuthenticationServiceProtocol {
    func `configureHomeserver`(`serverNameOrHomeserverUrl`: String)  throws
    func `homeserverDetails`()   -> HomeserverLoginDetails?
    func `login`(`username`: String, `password`: String, `initialDeviceName`: String?, `deviceId`: String?)  throws -> Client
    func `restoreWithAccessToken`(`token`: String, `deviceId`: String)  throws -> Client
    
}

public class AuthenticationService: AuthenticationServiceProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }
    public convenience init(`basePath`: String, `passphrase`: String?, `customSlidingSyncProxy`: String?)  {
        self.init(unsafeFromRawPointer: try! rustCall() {
    matrix_sdk_ffi_8d0d_AuthenticationService_new(
        FfiConverterString.lower(`basePath`), 
        FfiConverterOptionString.lower(`passphrase`), 
        FfiConverterOptionString.lower(`customSlidingSyncProxy`), $0)
})
    }

    deinit {
        try! rustCall { ffi_matrix_sdk_ffi_8d0d_AuthenticationService_object_free(pointer, $0) }
    }

    

    
    

    public func `configureHomeserver`(`serverNameOrHomeserverUrl`: String) throws {
        try 
    rustCallWithError(FfiConverterTypeAuthenticationError.self) {
    _uniffi_matrix_sdk_ffi_impl_AuthenticationService_configure_homeserver_5a2b(self.pointer, 
        FfiConverterString.lower(`serverNameOrHomeserverUrl`), $0
    )
}
    }

    public func `homeserverDetails`()  -> HomeserverLoginDetails? {
        return try!  FfiConverterOptionTypeHomeserverLoginDetails.lift(
            try! 
    rustCall() {
    
    _uniffi_matrix_sdk_ffi_impl_AuthenticationService_homeserver_details_5a3d(self.pointer, $0
    )
}
        )
    }

    public func `login`(`username`: String, `password`: String, `initialDeviceName`: String?, `deviceId`: String?) throws -> Client {
        return try  FfiConverterTypeClient.lift(
            try 
    rustCallWithError(FfiConverterTypeAuthenticationError.self) {
    _uniffi_matrix_sdk_ffi_impl_AuthenticationService_login_e1b3(self.pointer, 
        FfiConverterString.lower(`username`), 
        FfiConverterString.lower(`password`), 
        FfiConverterOptionString.lower(`initialDeviceName`), 
        FfiConverterOptionString.lower(`deviceId`), $0
    )
}
        )
    }

    public func `restoreWithAccessToken`(`token`: String, `deviceId`: String) throws -> Client {
        return try  FfiConverterTypeClient.lift(
            try 
    rustCallWithError(FfiConverterTypeAuthenticationError.self) {
    _uniffi_matrix_sdk_ffi_impl_AuthenticationService_restore_with_access_token_1d43(self.pointer, 
        FfiConverterString.lower(`token`), 
        FfiConverterString.lower(`deviceId`), $0
    )
}
        )
    }
}



public struct FfiConverterTypeAuthenticationService: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = AuthenticationService

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AuthenticationService {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: AuthenticationService, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> AuthenticationService {
        return AuthenticationService(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: AuthenticationService) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}


public func FfiConverterTypeAuthenticationService_lift(_ pointer: UnsafeMutableRawPointer) throws -> AuthenticationService {
    return try FfiConverterTypeAuthenticationService.lift(pointer)
}

public func FfiConverterTypeAuthenticationService_lower(_ value: AuthenticationService) -> UnsafeMutableRawPointer {
    return FfiConverterTypeAuthenticationService.lower(value)
}


public protocol ClientProtocol {
    func `setDelegate`(`delegate`: ClientDelegate?)  
    func `login`(`username`: String, `password`: String, `initialDeviceName`: String?, `deviceId`: String?)  throws
    func `getMediaFile`(`source`: MediaSource, `mimeType`: String)  throws -> MediaFileHandle
    func `accountData`(`eventType`: String)  throws -> String?
    func `avatarUrl`()  throws -> String?
    func `cachedAvatarUrl`()  throws -> String?
    func `createRoom`(`request`: CreateRoomParameters)  throws -> String
    func `deviceId`()  throws -> String
    func `displayName`()  throws -> String
    func `getDmRoom`(`userId`: String)  throws -> Room?
    func `getMediaContent`(`mediaSource`: MediaSource)  throws -> [UInt8]
    func `getMediaThumbnail`(`mediaSource`: MediaSource, `width`: UInt64, `height`: UInt64)  throws -> [UInt8]
    func `getProfile`(`userId`: String)  throws -> UserProfile
    func `getSessionVerificationController`()  throws -> SessionVerificationController
    func `homeserver`()   -> String
    func `ignoreUser`(`userId`: String)  throws
    func `logout`()  throws
    func `restoreSession`(`session`: Session)  throws
    func `rooms`()   -> [Room]
    func `searchUsers`(`searchTerm`: String, `limit`: UInt64)  throws -> SearchUsersResults
    func `session`()  throws -> Session
    func `setAccountData`(`eventType`: String, `content`: String)  throws
    func `setDisplayName`(`name`: String)  throws
    func `setPusher`(`identifiers`: PusherIdentifiers, `kind`: PusherKind, `appDisplayName`: String, `deviceDisplayName`: String, `profileTag`: String?, `lang`: String)  throws
    func `slidingSync`()   -> SlidingSyncBuilder
    func `unignoreUser`(`userId`: String)  throws
    func `uploadMedia`(`mimeType`: String, `data`: [UInt8])  throws -> String
    func `userId`()  throws -> String
    
}

public class Client: ClientProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { ffi_matrix_sdk_ffi_8d0d_Client_object_free(pointer, $0) }
    }

    

    
    

    public func `setDelegate`(`delegate`: ClientDelegate?)  {
        try! 
    rustCall() {
    
    matrix_sdk_ffi_8d0d_Client_set_delegate(self.pointer, 
        FfiConverterOptionCallbackInterfaceClientDelegate.lower(`delegate`), $0
    )
}
    }

    public func `login`(`username`: String, `password`: String, `initialDeviceName`: String?, `deviceId`: String?) throws {
        try 
    rustCallWithError(FfiConverterTypeClientError.self) {
    matrix_sdk_ffi_8d0d_Client_login(self.pointer, 
        FfiConverterString.lower(`username`), 
        FfiConverterString.lower(`password`), 
        FfiConverterOptionString.lower(`initialDeviceName`), 
        FfiConverterOptionString.lower(`deviceId`), $0
    )
}
    }

    public func `getMediaFile`(`source`: MediaSource, `mimeType`: String) throws -> MediaFileHandle {
        return try  FfiConverterTypeMediaFileHandle.lift(
            try 
    rustCallWithError(FfiConverterTypeClientError.self) {
    matrix_sdk_ffi_8d0d_Client_get_media_file(self.pointer, 
        FfiConverterTypeMediaSource.lower(`source`), 
        FfiConverterString.lower(`mimeType`), $0
    )
}
        )
    }

    public func `accountData`(`eventType`: String) throws -> String? {
        return try  FfiConverterOptionString.lift(
            try 
    rustCallWithError(FfiConverterTypeClientError.self) {
    _uniffi_matrix_sdk_ffi_impl_Client_account_data_c0e2(self.pointer, 
        FfiConverterString.lower(`eventType`), $0
    )
}
        )
    }

    public func `avatarUrl`() throws -> String? {
        return try  FfiConverterOptionString.lift(
            try 
    rustCallWithError(FfiConverterTypeClientError.self) {
    _uniffi_matrix_sdk_ffi_impl_Client_avatar_url_dca2(self.pointer, $0
    )
}
        )
    }

    public func `cachedAvatarUrl`() throws -> String? {
        return try  FfiConverterOptionString.lift(
            try 
    rustCallWithError(FfiConverterTypeClientError.self) {
    _uniffi_matrix_sdk_ffi_impl_Client_cached_avatar_url_eafb(self.pointer, $0
    )
}
        )
    }

    public func `createRoom`(`request`: CreateRoomParameters) throws -> String {
        return try  FfiConverterString.lift(
            try 
    rustCallWithError(FfiConverterTypeClientError.self) {
    _uniffi_matrix_sdk_ffi_impl_Client_create_room_d94e(self.pointer, 
        FfiConverterTypeCreateRoomParameters.lower(`request`), $0
    )
}
        )
    }

    public func `deviceId`() throws -> String {
        return try  FfiConverterString.lift(
            try 
    rustCallWithError(FfiConverterTypeClientError.self) {
    _uniffi_matrix_sdk_ffi_impl_Client_device_id_93f(self.pointer, $0
    )
}
        )
    }

    public func `displayName`() throws -> String {
        return try  FfiConverterString.lift(
            try 
    rustCallWithError(FfiConverterTypeClientError.self) {
    _uniffi_matrix_sdk_ffi_impl_Client_display_name_39ad(self.pointer, $0
    )
}
        )
    }

    public func `getDmRoom`(`userId`: String) throws -> Room? {
        return try  FfiConverterOptionTypeRoom.lift(
            try 
    rustCallWithError(FfiConverterTypeClientError.self) {
    _uniffi_matrix_sdk_ffi_impl_Client_get_dm_room_5342(self.pointer, 
        FfiConverterString.lower(`userId`), $0
    )
}
        )
    }

    public func `getMediaContent`(`mediaSource`: MediaSource) throws -> [UInt8] {
        return try  FfiConverterSequenceUInt8.lift(
            try 
    rustCallWithError(FfiConverterTypeClientError.self) {
    _uniffi_matrix_sdk_ffi_impl_Client_get_media_content_2cc4(self.pointer, 
        FfiConverterTypeMediaSource.lower(`mediaSource`), $0
    )
}
        )
    }

    public func `getMediaThumbnail`(`mediaSource`: MediaSource, `width`: UInt64, `height`: UInt64) throws -> [UInt8] {
        return try  FfiConverterSequenceUInt8.lift(
            try 
    rustCallWithError(FfiConverterTypeClientError.self) {
    _uniffi_matrix_sdk_ffi_impl_Client_get_media_thumbnail_2f9e(self.pointer, 
        FfiConverterTypeMediaSource.lower(`mediaSource`), 
        FfiConverterUInt64.lower(`width`), 
        FfiConverterUInt64.lower(`height`), $0
    )
}
        )
    }

    public func `getProfile`(`userId`: String) throws -> UserProfile {
        return try  FfiConverterTypeUserProfile.lift(
            try 
    rustCallWithError(FfiConverterTypeClientError.self) {
    _uniffi_matrix_sdk_ffi_impl_Client_get_profile_7f94(self.pointer, 
        FfiConverterString.lower(`userId`), $0
    )
}
        )
    }

    public func `getSessionVerificationController`() throws -> SessionVerificationController {
        return try  FfiConverterTypeSessionVerificationController.lift(
            try 
    rustCallWithError(FfiConverterTypeClientError.self) {
    _uniffi_matrix_sdk_ffi_impl_Client_get_session_verification_controller_47cf(self.pointer, $0
    )
}
        )
    }

    public func `homeserver`()  -> String {
        return try!  FfiConverterString.lift(
            try! 
    rustCall() {
    
    _uniffi_matrix_sdk_ffi_impl_Client_homeserver_cb72(self.pointer, $0
    )
}
        )
    }

    public func `ignoreUser`(`userId`: String) throws {
        try 
    rustCallWithError(FfiConverterTypeClientError.self) {
    _uniffi_matrix_sdk_ffi_impl_Client_ignore_user_f636(self.pointer, 
        FfiConverterString.lower(`userId`), $0
    )
}
    }

    public func `logout`() throws {
        try 
    rustCallWithError(FfiConverterTypeClientError.self) {
    _uniffi_matrix_sdk_ffi_impl_Client_logout_e617(self.pointer, $0
    )
}
    }

    public func `restoreSession`(`session`: Session) throws {
        try 
    rustCallWithError(FfiConverterTypeClientError.self) {
    _uniffi_matrix_sdk_ffi_impl_Client_restore_session_e586(self.pointer, 
        FfiConverterTypeSession.lower(`session`), $0
    )
}
    }

    public func `rooms`()  -> [Room] {
        return try!  FfiConverterSequenceTypeRoom.lift(
            try! 
    rustCall() {
    
    _uniffi_matrix_sdk_ffi_impl_Client_rooms_bbf1(self.pointer, $0
    )
}
        )
    }

    public func `searchUsers`(`searchTerm`: String, `limit`: UInt64) throws -> SearchUsersResults {
        return try  FfiConverterTypeSearchUsersResults.lift(
            try 
    rustCallWithError(FfiConverterTypeClientError.self) {
    _uniffi_matrix_sdk_ffi_impl_Client_search_users_f239(self.pointer, 
        FfiConverterString.lower(`searchTerm`), 
        FfiConverterUInt64.lower(`limit`), $0
    )
}
        )
    }

    public func `session`() throws -> Session {
        return try  FfiConverterTypeSession.lift(
            try 
    rustCallWithError(FfiConverterTypeClientError.self) {
    _uniffi_matrix_sdk_ffi_impl_Client_session_3236(self.pointer, $0
    )
}
        )
    }

    public func `setAccountData`(`eventType`: String, `content`: String) throws {
        try 
    rustCallWithError(FfiConverterTypeClientError.self) {
    _uniffi_matrix_sdk_ffi_impl_Client_set_account_data_c63f(self.pointer, 
        FfiConverterString.lower(`eventType`), 
        FfiConverterString.lower(`content`), $0
    )
}
    }

    public func `setDisplayName`(`name`: String) throws {
        try 
    rustCallWithError(FfiConverterTypeClientError.self) {
    _uniffi_matrix_sdk_ffi_impl_Client_set_display_name_1461(self.pointer, 
        FfiConverterString.lower(`name`), $0
    )
}
    }

    public func `setPusher`(`identifiers`: PusherIdentifiers, `kind`: PusherKind, `appDisplayName`: String, `deviceDisplayName`: String, `profileTag`: String?, `lang`: String) throws {
        try 
    rustCallWithError(FfiConverterTypeClientError.self) {
    _uniffi_matrix_sdk_ffi_impl_Client_set_pusher_40f8(self.pointer, 
        FfiConverterTypePusherIdentifiers.lower(`identifiers`), 
        FfiConverterTypePusherKind.lower(`kind`), 
        FfiConverterString.lower(`appDisplayName`), 
        FfiConverterString.lower(`deviceDisplayName`), 
        FfiConverterOptionString.lower(`profileTag`), 
        FfiConverterString.lower(`lang`), $0
    )
}
    }

    public func `slidingSync`()  -> SlidingSyncBuilder {
        return try!  FfiConverterTypeSlidingSyncBuilder.lift(
            try! 
    rustCall() {
    
    _uniffi_matrix_sdk_ffi_impl_Client_sliding_sync_3ce1(self.pointer, $0
    )
}
        )
    }

    public func `unignoreUser`(`userId`: String) throws {
        try 
    rustCallWithError(FfiConverterTypeClientError.self) {
    _uniffi_matrix_sdk_ffi_impl_Client_unignore_user_e4ef(self.pointer, 
        FfiConverterString.lower(`userId`), $0
    )
}
    }

    public func `uploadMedia`(`mimeType`: String, `data`: [UInt8]) throws -> String {
        return try  FfiConverterString.lift(
            try 
    rustCallWithError(FfiConverterTypeClientError.self) {
    _uniffi_matrix_sdk_ffi_impl_Client_upload_media_5801(self.pointer, 
        FfiConverterString.lower(`mimeType`), 
        FfiConverterSequenceUInt8.lower(`data`), $0
    )
}
        )
    }

    public func `userId`() throws -> String {
        return try  FfiConverterString.lift(
            try 
    rustCallWithError(FfiConverterTypeClientError.self) {
    _uniffi_matrix_sdk_ffi_impl_Client_user_id_5c0b(self.pointer, $0
    )
}
        )
    }
}



public struct FfiConverterTypeClient: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Client

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Client {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Client, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Client {
        return Client(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Client) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}


public func FfiConverterTypeClient_lift(_ pointer: UnsafeMutableRawPointer) throws -> Client {
    return try FfiConverterTypeClient.lift(pointer)
}

public func FfiConverterTypeClient_lower(_ value: Client) -> UnsafeMutableRawPointer {
    return FfiConverterTypeClient.lower(value)
}


public protocol ClientBuilderProtocol {
    func `build`()  throws -> Client
    func `basePath`(`path`: String)   -> ClientBuilder
    func `homeserverUrl`(`url`: String)   -> ClientBuilder
    func `passphrase`(`passphrase`: String?)   -> ClientBuilder
    func `serverName`(`serverName`: String)   -> ClientBuilder
    func `serverVersions`(`versions`: [String])   -> ClientBuilder
    func `slidingSyncProxy`(`slidingSyncProxy`: String?)   -> ClientBuilder
    func `userAgent`(`userAgent`: String)   -> ClientBuilder
    func `username`(`username`: String)   -> ClientBuilder
    
}

public class ClientBuilder: ClientBuilderProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }
    public convenience init()  {
        self.init(unsafeFromRawPointer: try! rustCall() {
    matrix_sdk_ffi_8d0d_ClientBuilder_new($0)
})
    }

    deinit {
        try! rustCall { ffi_matrix_sdk_ffi_8d0d_ClientBuilder_object_free(pointer, $0) }
    }

    

    
    

    public func `build`() throws -> Client {
        return try  FfiConverterTypeClient.lift(
            try 
    rustCallWithError(FfiConverterTypeClientError.self) {
    matrix_sdk_ffi_8d0d_ClientBuilder_build(self.pointer, $0
    )
}
        )
    }

    public func `basePath`(`path`: String)  -> ClientBuilder {
        return try!  FfiConverterTypeClientBuilder.lift(
            try! 
    rustCall() {
    
    _uniffi_matrix_sdk_ffi_impl_ClientBuilder_base_path_a1af(self.pointer, 
        FfiConverterString.lower(`path`), $0
    )
}
        )
    }

    public func `homeserverUrl`(`url`: String)  -> ClientBuilder {
        return try!  FfiConverterTypeClientBuilder.lift(
            try! 
    rustCall() {
    
    _uniffi_matrix_sdk_ffi_impl_ClientBuilder_homeserver_url_d5fa(self.pointer, 
        FfiConverterString.lower(`url`), $0
    )
}
        )
    }

    public func `passphrase`(`passphrase`: String?)  -> ClientBuilder {
        return try!  FfiConverterTypeClientBuilder.lift(
            try! 
    rustCall() {
    
    _uniffi_matrix_sdk_ffi_impl_ClientBuilder_passphrase_fa90(self.pointer, 
        FfiConverterOptionString.lower(`passphrase`), $0
    )
}
        )
    }

    public func `serverName`(`serverName`: String)  -> ClientBuilder {
        return try!  FfiConverterTypeClientBuilder.lift(
            try! 
    rustCall() {
    
    _uniffi_matrix_sdk_ffi_impl_ClientBuilder_server_name_3073(self.pointer, 
        FfiConverterString.lower(`serverName`), $0
    )
}
        )
    }

    public func `serverVersions`(`versions`: [String])  -> ClientBuilder {
        return try!  FfiConverterTypeClientBuilder.lift(
            try! 
    rustCall() {
    
    _uniffi_matrix_sdk_ffi_impl_ClientBuilder_server_versions_366(self.pointer, 
        FfiConverterSequenceString.lower(`versions`), $0
    )
}
        )
    }

    public func `slidingSyncProxy`(`slidingSyncProxy`: String?)  -> ClientBuilder {
        return try!  FfiConverterTypeClientBuilder.lift(
            try! 
    rustCall() {
    
    _uniffi_matrix_sdk_ffi_impl_ClientBuilder_sliding_sync_proxy_fd67(self.pointer, 
        FfiConverterOptionString.lower(`slidingSyncProxy`), $0
    )
}
        )
    }

    public func `userAgent`(`userAgent`: String)  -> ClientBuilder {
        return try!  FfiConverterTypeClientBuilder.lift(
            try! 
    rustCall() {
    
    _uniffi_matrix_sdk_ffi_impl_ClientBuilder_user_agent_c34d(self.pointer, 
        FfiConverterString.lower(`userAgent`), $0
    )
}
        )
    }

    public func `username`(`username`: String)  -> ClientBuilder {
        return try!  FfiConverterTypeClientBuilder.lift(
            try! 
    rustCall() {
    
    _uniffi_matrix_sdk_ffi_impl_ClientBuilder_username_6f74(self.pointer, 
        FfiConverterString.lower(`username`), $0
    )
}
        )
    }
}



public struct FfiConverterTypeClientBuilder: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = ClientBuilder

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ClientBuilder {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: ClientBuilder, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ClientBuilder {
        return ClientBuilder(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: ClientBuilder) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}


public func FfiConverterTypeClientBuilder_lift(_ pointer: UnsafeMutableRawPointer) throws -> ClientBuilder {
    return try FfiConverterTypeClientBuilder.lift(pointer)
}

public func FfiConverterTypeClientBuilder_lower(_ value: ClientBuilder) -> UnsafeMutableRawPointer {
    return FfiConverterTypeClientBuilder.lower(value)
}


public protocol EventTimelineItemProtocol {
    func `content`()   -> TimelineItemContent
    func `debugInfo`()   -> EventTimelineItemDebugInfo
    func `eventId`()   -> String?
    func `isEditable`()   -> Bool
    func `isLocal`()   -> Bool
    func `isOwn`()   -> Bool
    func `isRemote`()   -> Bool
    func `localSendState`()   -> EventSendState?
    func `reactions`()   -> [Reaction]?
    func `sender`()   -> String
    func `senderProfile`()   -> ProfileDetails
    func `timestamp`()   -> UInt64
    func `uniqueIdentifier`()   -> String
    
}

public class EventTimelineItem: EventTimelineItemProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { _uniffi_matrix_sdk_ffi_object_free_EventTimelineItem_46cf(pointer, $0) }
    }

    

    
    

    public func `content`()  -> TimelineItemContent {
        return try!  FfiConverterTypeTimelineItemContent.lift(
            try! 
    rustCall() {
    
    _uniffi_matrix_sdk_ffi_impl_EventTimelineItem_content_b878(self.pointer, $0
    )
}
        )
    }

    public func `debugInfo`()  -> EventTimelineItemDebugInfo {
        return try!  FfiConverterTypeEventTimelineItemDebugInfo.lift(
            try! 
    rustCall() {
    
    _uniffi_matrix_sdk_ffi_impl_EventTimelineItem_debug_info_2597(self.pointer, $0
    )
}
        )
    }

    public func `eventId`()  -> String? {
        return try!  FfiConverterOptionString.lift(
            try! 
    rustCall() {
    
    _uniffi_matrix_sdk_ffi_impl_EventTimelineItem_event_id_fd2e(self.pointer, $0
    )
}
        )
    }

    public func `isEditable`()  -> Bool {
        return try!  FfiConverterBool.lift(
            try! 
    rustCall() {
    
    _uniffi_matrix_sdk_ffi_impl_EventTimelineItem_is_editable_b154(self.pointer, $0
    )
}
        )
    }

    public func `isLocal`()  -> Bool {
        return try!  FfiConverterBool.lift(
            try! 
    rustCall() {
    
    _uniffi_matrix_sdk_ffi_impl_EventTimelineItem_is_local_dd0d(self.pointer, $0
    )
}
        )
    }

    public func `isOwn`()  -> Bool {
        return try!  FfiConverterBool.lift(
            try! 
    rustCall() {
    
    _uniffi_matrix_sdk_ffi_impl_EventTimelineItem_is_own_1bd0(self.pointer, $0
    )
}
        )
    }

    public func `isRemote`()  -> Bool {
        return try!  FfiConverterBool.lift(
            try! 
    rustCall() {
    
    _uniffi_matrix_sdk_ffi_impl_EventTimelineItem_is_remote_2a3e(self.pointer, $0
    )
}
        )
    }

    public func `localSendState`()  -> EventSendState? {
        return try!  FfiConverterOptionTypeEventSendState.lift(
            try! 
    rustCall() {
    
    _uniffi_matrix_sdk_ffi_impl_EventTimelineItem_local_send_state_6078(self.pointer, $0
    )
}
        )
    }

    public func `reactions`()  -> [Reaction]? {
        return try!  FfiConverterOptionSequenceTypeReaction.lift(
            try! 
    rustCall() {
    
    _uniffi_matrix_sdk_ffi_impl_EventTimelineItem_reactions_1f7d(self.pointer, $0
    )
}
        )
    }

    public func `sender`()  -> String {
        return try!  FfiConverterString.lift(
            try! 
    rustCall() {
    
    _uniffi_matrix_sdk_ffi_impl_EventTimelineItem_sender_9be3(self.pointer, $0
    )
}
        )
    }

    public func `senderProfile`()  -> ProfileDetails {
        return try!  FfiConverterTypeProfileDetails.lift(
            try! 
    rustCall() {
    
    _uniffi_matrix_sdk_ffi_impl_EventTimelineItem_sender_profile_382f(self.pointer, $0
    )
}
        )
    }

    public func `timestamp`()  -> UInt64 {
        return try!  FfiConverterUInt64.lift(
            try! 
    rustCall() {
    
    _uniffi_matrix_sdk_ffi_impl_EventTimelineItem_timestamp_be48(self.pointer, $0
    )
}
        )
    }

    public func `uniqueIdentifier`()  -> String {
        return try!  FfiConverterString.lift(
            try! 
    rustCall() {
    
    _uniffi_matrix_sdk_ffi_impl_EventTimelineItem_unique_identifier_91e7(self.pointer, $0
    )
}
        )
    }
}



public struct FfiConverterTypeEventTimelineItem: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = EventTimelineItem

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> EventTimelineItem {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: EventTimelineItem, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> EventTimelineItem {
        return EventTimelineItem(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: EventTimelineItem) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}


public func FfiConverterTypeEventTimelineItem_lift(_ pointer: UnsafeMutableRawPointer) throws -> EventTimelineItem {
    return try FfiConverterTypeEventTimelineItem.lift(pointer)
}

public func FfiConverterTypeEventTimelineItem_lower(_ value: EventTimelineItem) -> UnsafeMutableRawPointer {
    return FfiConverterTypeEventTimelineItem.lower(value)
}


public protocol HomeserverLoginDetailsProtocol {
    func `authenticationIssuer`()   -> String?
    func `supportsPasswordLogin`()   -> Bool
    func `url`()   -> String
    
}

public class HomeserverLoginDetails: HomeserverLoginDetailsProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { _uniffi_matrix_sdk_ffi_object_free_HomeserverLoginDetails_2400(pointer, $0) }
    }

    

    
    

    public func `authenticationIssuer`()  -> String? {
        return try!  FfiConverterOptionString.lift(
            try! 
    rustCall() {
    
    _uniffi_matrix_sdk_ffi_impl_HomeserverLoginDetails_authentication_issuer_8e36(self.pointer, $0
    )
}
        )
    }

    public func `supportsPasswordLogin`()  -> Bool {
        return try!  FfiConverterBool.lift(
            try! 
    rustCall() {
    
    _uniffi_matrix_sdk_ffi_impl_HomeserverLoginDetails_supports_password_login_db17(self.pointer, $0
    )
}
        )
    }

    public func `url`()  -> String {
        return try!  FfiConverterString.lift(
            try! 
    rustCall() {
    
    _uniffi_matrix_sdk_ffi_impl_HomeserverLoginDetails_url_e46d(self.pointer, $0
    )
}
        )
    }
}



public struct FfiConverterTypeHomeserverLoginDetails: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = HomeserverLoginDetails

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> HomeserverLoginDetails {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: HomeserverLoginDetails, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> HomeserverLoginDetails {
        return HomeserverLoginDetails(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: HomeserverLoginDetails) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}


public func FfiConverterTypeHomeserverLoginDetails_lift(_ pointer: UnsafeMutableRawPointer) throws -> HomeserverLoginDetails {
    return try FfiConverterTypeHomeserverLoginDetails.lift(pointer)
}

public func FfiConverterTypeHomeserverLoginDetails_lower(_ value: HomeserverLoginDetails) -> UnsafeMutableRawPointer {
    return FfiConverterTypeHomeserverLoginDetails.lower(value)
}


public protocol MediaFileHandleProtocol {
    func `path`()   -> String
    
}

public class MediaFileHandle: MediaFileHandleProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { ffi_matrix_sdk_ffi_8d0d_MediaFileHandle_object_free(pointer, $0) }
    }

    

    
    

    public func `path`()  -> String {
        return try!  FfiConverterString.lift(
            try! 
    rustCall() {
    
    matrix_sdk_ffi_8d0d_MediaFileHandle_path(self.pointer, $0
    )
}
        )
    }
}



public struct FfiConverterTypeMediaFileHandle: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = MediaFileHandle

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MediaFileHandle {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: MediaFileHandle, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> MediaFileHandle {
        return MediaFileHandle(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: MediaFileHandle) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}


public func FfiConverterTypeMediaFileHandle_lift(_ pointer: UnsafeMutableRawPointer) throws -> MediaFileHandle {
    return try FfiConverterTypeMediaFileHandle.lift(pointer)
}

public func FfiConverterTypeMediaFileHandle_lower(_ value: MediaFileHandle) -> UnsafeMutableRawPointer {
    return FfiConverterTypeMediaFileHandle.lower(value)
}


public protocol MediaSourceProtocol {
    func `url`()   -> String
    
}

public class MediaSource: MediaSourceProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { ffi_matrix_sdk_ffi_8d0d_MediaSource_object_free(pointer, $0) }
    }

    

    
    

    public func `url`()  -> String {
        return try!  FfiConverterString.lift(
            try! 
    rustCall() {
    
    matrix_sdk_ffi_8d0d_MediaSource_url(self.pointer, $0
    )
}
        )
    }
}



public struct FfiConverterTypeMediaSource: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = MediaSource

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MediaSource {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: MediaSource, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> MediaSource {
        return MediaSource(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: MediaSource) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}


public func FfiConverterTypeMediaSource_lift(_ pointer: UnsafeMutableRawPointer) throws -> MediaSource {
    return try FfiConverterTypeMediaSource.lift(pointer)
}

public func FfiConverterTypeMediaSource_lower(_ value: MediaSource) -> UnsafeMutableRawPointer {
    return FfiConverterTypeMediaSource.lower(value)
}


public protocol MessageProtocol {
    func `body`()   -> String
    func `inReplyTo`()   -> InReplyToDetails?
    func `isEdited`()   -> Bool
    func `msgtype`()   -> MessageType?
    
}

public class Message: MessageProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { _uniffi_matrix_sdk_ffi_object_free_Message_1ab4(pointer, $0) }
    }

    

    
    

    public func `body`()  -> String {
        return try!  FfiConverterString.lift(
            try! 
    rustCall() {
    
    _uniffi_matrix_sdk_ffi_impl_Message_body_ad14(self.pointer, $0
    )
}
        )
    }

    public func `inReplyTo`()  -> InReplyToDetails? {
        return try!  FfiConverterOptionTypeInReplyToDetails.lift(
            try! 
    rustCall() {
    
    _uniffi_matrix_sdk_ffi_impl_Message_in_reply_to_1857(self.pointer, $0
    )
}
        )
    }

    public func `isEdited`()  -> Bool {
        return try!  FfiConverterBool.lift(
            try! 
    rustCall() {
    
    _uniffi_matrix_sdk_ffi_impl_Message_is_edited_d878(self.pointer, $0
    )
}
        )
    }

    public func `msgtype`()  -> MessageType? {
        return try!  FfiConverterOptionTypeMessageType.lift(
            try! 
    rustCall() {
    
    _uniffi_matrix_sdk_ffi_impl_Message_msgtype_13c1(self.pointer, $0
    )
}
        )
    }
}



public struct FfiConverterTypeMessage: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Message

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Message {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Message, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Message {
        return Message(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Message) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}


public func FfiConverterTypeMessage_lift(_ pointer: UnsafeMutableRawPointer) throws -> Message {
    return try FfiConverterTypeMessage.lift(pointer)
}

public func FfiConverterTypeMessage_lower(_ value: Message) -> UnsafeMutableRawPointer {
    return FfiConverterTypeMessage.lower(value)
}


public protocol NotificationServiceProtocol {
    func `getNotificationItem`(`roomId`: String, `eventId`: String)  throws -> NotificationItem?
    
}

public class NotificationService: NotificationServiceProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }
    public convenience init(`basePath`: String, `userId`: String)  {
        self.init(unsafeFromRawPointer: try! rustCall() {
    matrix_sdk_ffi_8d0d_NotificationService_new(
        FfiConverterString.lower(`basePath`), 
        FfiConverterString.lower(`userId`), $0)
})
    }

    deinit {
        try! rustCall { ffi_matrix_sdk_ffi_8d0d_NotificationService_object_free(pointer, $0) }
    }

    

    
    

    public func `getNotificationItem`(`roomId`: String, `eventId`: String) throws -> NotificationItem? {
        return try  FfiConverterOptionTypeNotificationItem.lift(
            try 
    rustCallWithError(FfiConverterTypeClientError.self) {
    matrix_sdk_ffi_8d0d_NotificationService_get_notification_item(self.pointer, 
        FfiConverterString.lower(`roomId`), 
        FfiConverterString.lower(`eventId`), $0
    )
}
        )
    }
}



public struct FfiConverterTypeNotificationService: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = NotificationService

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NotificationService {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: NotificationService, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> NotificationService {
        return NotificationService(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: NotificationService) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}


public func FfiConverterTypeNotificationService_lift(_ pointer: UnsafeMutableRawPointer) throws -> NotificationService {
    return try FfiConverterTypeNotificationService.lift(pointer)
}

public func FfiConverterTypeNotificationService_lower(_ value: NotificationService) -> UnsafeMutableRawPointer {
    return FfiConverterTypeNotificationService.lower(value)
}


public protocol RoomProtocol {
    func `displayName`()  throws -> String
    func `isEncrypted`()  throws -> Bool
    func `members`()  throws -> [RoomMember]
    func `memberAvatarUrl`(`userId`: String)  throws -> String?
    func `memberDisplayName`(`userId`: String)  throws -> String?
    func `addTimelineListener`(`listener`: TimelineListener)   -> [TimelineItem]
    func `paginateBackwards`(`opts`: PaginationOptions)  throws
    func `sendReadReceipt`(`eventId`: String)  throws
    func `sendReadMarker`(`fullyReadEventId`: String, `readReceiptEventId`: String?)  throws
    func `send`(`msg`: RoomMessageEventContent, `txnId`: String?)  
    func `sendReply`(`msg`: String, `inReplyToEventId`: String, `txnId`: String?)  throws
    func `edit`(`newMsg`: String, `originalEventId`: String, `txnId`: String?)  throws
    func `redact`(`eventId`: String, `reason`: String?, `txnId`: String?)  throws
    func `reportContent`(`eventId`: String, `score`: Int32?, `reason`: String?)  throws
    func `ignoreUser`(`userId`: String)  throws
    func `sendReaction`(`eventId`: String, `key`: String)  throws
    func `leave`()  throws
    func `rejectInvitation`()  throws
    func `acceptInvitation`()  throws
    func `setTopic`(`topic`: String)  throws
    func `uploadAvatar`(`mimeType`: String, `data`: [UInt8])  throws
    func `removeAvatar`()  throws
    func `inviteUserById`(`userId`: String)  throws
    func `alternativeAliases`()   -> [String]
    func `avatarUrl`()   -> String?
    func `canonicalAlias`()   -> String?
    func `fetchMembers`()  
    func `id`()   -> String
    func `inviter`()   -> RoomMember?
    func `isDirect`()   -> Bool
    func `isPublic`()   -> Bool
    func `isSpace`()   -> Bool
    func `isTombstoned`()   -> Bool
    func `membership`()   -> Membership
    func `name`()   -> String?
    func `removeTimeline`()  
    func `retryDecryption`(`sessionIds`: [String])  
    func `topic`()   -> String?
    
}

public class Room: RoomProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { ffi_matrix_sdk_ffi_8d0d_Room_object_free(pointer, $0) }
    }

    

    
    

    public func `displayName`() throws -> String {
        return try  FfiConverterString.lift(
            try 
    rustCallWithError(FfiConverterTypeClientError.self) {
    matrix_sdk_ffi_8d0d_Room_display_name(self.pointer, $0
    )
}
        )
    }

    public func `isEncrypted`() throws -> Bool {
        return try  FfiConverterBool.lift(
            try 
    rustCallWithError(FfiConverterTypeClientError.self) {
    matrix_sdk_ffi_8d0d_Room_is_encrypted(self.pointer, $0
    )
}
        )
    }

    public func `members`() throws -> [RoomMember] {
        return try  FfiConverterSequenceTypeRoomMember.lift(
            try 
    rustCallWithError(FfiConverterTypeClientError.self) {
    matrix_sdk_ffi_8d0d_Room_members(self.pointer, $0
    )
}
        )
    }

    public func `memberAvatarUrl`(`userId`: String) throws -> String? {
        return try  FfiConverterOptionString.lift(
            try 
    rustCallWithError(FfiConverterTypeClientError.self) {
    matrix_sdk_ffi_8d0d_Room_member_avatar_url(self.pointer, 
        FfiConverterString.lower(`userId`), $0
    )
}
        )
    }

    public func `memberDisplayName`(`userId`: String) throws -> String? {
        return try  FfiConverterOptionString.lift(
            try 
    rustCallWithError(FfiConverterTypeClientError.self) {
    matrix_sdk_ffi_8d0d_Room_member_display_name(self.pointer, 
        FfiConverterString.lower(`userId`), $0
    )
}
        )
    }

    public func `addTimelineListener`(`listener`: TimelineListener)  -> [TimelineItem] {
        return try!  FfiConverterSequenceTypeTimelineItem.lift(
            try! 
    rustCall() {
    
    matrix_sdk_ffi_8d0d_Room_add_timeline_listener(self.pointer, 
        FfiConverterCallbackInterfaceTimelineListener.lower(`listener`), $0
    )
}
        )
    }

    public func `paginateBackwards`(`opts`: PaginationOptions) throws {
        try 
    rustCallWithError(FfiConverterTypeClientError.self) {
    matrix_sdk_ffi_8d0d_Room_paginate_backwards(self.pointer, 
        FfiConverterTypePaginationOptions.lower(`opts`), $0
    )
}
    }

    public func `sendReadReceipt`(`eventId`: String) throws {
        try 
    rustCallWithError(FfiConverterTypeClientError.self) {
    matrix_sdk_ffi_8d0d_Room_send_read_receipt(self.pointer, 
        FfiConverterString.lower(`eventId`), $0
    )
}
    }

    public func `sendReadMarker`(`fullyReadEventId`: String, `readReceiptEventId`: String?) throws {
        try 
    rustCallWithError(FfiConverterTypeClientError.self) {
    matrix_sdk_ffi_8d0d_Room_send_read_marker(self.pointer, 
        FfiConverterString.lower(`fullyReadEventId`), 
        FfiConverterOptionString.lower(`readReceiptEventId`), $0
    )
}
    }

    public func `send`(`msg`: RoomMessageEventContent, `txnId`: String?)  {
        try! 
    rustCall() {
    
    matrix_sdk_ffi_8d0d_Room_send(self.pointer, 
        FfiConverterTypeRoomMessageEventContent.lower(`msg`), 
        FfiConverterOptionString.lower(`txnId`), $0
    )
}
    }

    public func `sendReply`(`msg`: String, `inReplyToEventId`: String, `txnId`: String?) throws {
        try 
    rustCallWithError(FfiConverterTypeClientError.self) {
    matrix_sdk_ffi_8d0d_Room_send_reply(self.pointer, 
        FfiConverterString.lower(`msg`), 
        FfiConverterString.lower(`inReplyToEventId`), 
        FfiConverterOptionString.lower(`txnId`), $0
    )
}
    }

    public func `edit`(`newMsg`: String, `originalEventId`: String, `txnId`: String?) throws {
        try 
    rustCallWithError(FfiConverterTypeClientError.self) {
    matrix_sdk_ffi_8d0d_Room_edit(self.pointer, 
        FfiConverterString.lower(`newMsg`), 
        FfiConverterString.lower(`originalEventId`), 
        FfiConverterOptionString.lower(`txnId`), $0
    )
}
    }

    public func `redact`(`eventId`: String, `reason`: String?, `txnId`: String?) throws {
        try 
    rustCallWithError(FfiConverterTypeClientError.self) {
    matrix_sdk_ffi_8d0d_Room_redact(self.pointer, 
        FfiConverterString.lower(`eventId`), 
        FfiConverterOptionString.lower(`reason`), 
        FfiConverterOptionString.lower(`txnId`), $0
    )
}
    }

    public func `reportContent`(`eventId`: String, `score`: Int32?, `reason`: String?) throws {
        try 
    rustCallWithError(FfiConverterTypeClientError.self) {
    matrix_sdk_ffi_8d0d_Room_report_content(self.pointer, 
        FfiConverterString.lower(`eventId`), 
        FfiConverterOptionInt32.lower(`score`), 
        FfiConverterOptionString.lower(`reason`), $0
    )
}
    }

    public func `ignoreUser`(`userId`: String) throws {
        try 
    rustCallWithError(FfiConverterTypeClientError.self) {
    matrix_sdk_ffi_8d0d_Room_ignore_user(self.pointer, 
        FfiConverterString.lower(`userId`), $0
    )
}
    }

    public func `sendReaction`(`eventId`: String, `key`: String) throws {
        try 
    rustCallWithError(FfiConverterTypeClientError.self) {
    matrix_sdk_ffi_8d0d_Room_send_reaction(self.pointer, 
        FfiConverterString.lower(`eventId`), 
        FfiConverterString.lower(`key`), $0
    )
}
    }

    public func `leave`() throws {
        try 
    rustCallWithError(FfiConverterTypeClientError.self) {
    matrix_sdk_ffi_8d0d_Room_leave(self.pointer, $0
    )
}
    }

    public func `rejectInvitation`() throws {
        try 
    rustCallWithError(FfiConverterTypeClientError.self) {
    matrix_sdk_ffi_8d0d_Room_reject_invitation(self.pointer, $0
    )
}
    }

    public func `acceptInvitation`() throws {
        try 
    rustCallWithError(FfiConverterTypeClientError.self) {
    matrix_sdk_ffi_8d0d_Room_accept_invitation(self.pointer, $0
    )
}
    }

    public func `setTopic`(`topic`: String) throws {
        try 
    rustCallWithError(FfiConverterTypeClientError.self) {
    matrix_sdk_ffi_8d0d_Room_set_topic(self.pointer, 
        FfiConverterString.lower(`topic`), $0
    )
}
    }

    public func `uploadAvatar`(`mimeType`: String, `data`: [UInt8]) throws {
        try 
    rustCallWithError(FfiConverterTypeClientError.self) {
    matrix_sdk_ffi_8d0d_Room_upload_avatar(self.pointer, 
        FfiConverterString.lower(`mimeType`), 
        FfiConverterSequenceUInt8.lower(`data`), $0
    )
}
    }

    public func `removeAvatar`() throws {
        try 
    rustCallWithError(FfiConverterTypeClientError.self) {
    matrix_sdk_ffi_8d0d_Room_remove_avatar(self.pointer, $0
    )
}
    }

    public func `inviteUserById`(`userId`: String) throws {
        try 
    rustCallWithError(FfiConverterTypeClientError.self) {
    matrix_sdk_ffi_8d0d_Room_invite_user_by_id(self.pointer, 
        FfiConverterString.lower(`userId`), $0
    )
}
    }

    public func `alternativeAliases`()  -> [String] {
        return try!  FfiConverterSequenceString.lift(
            try! 
    rustCall() {
    
    _uniffi_matrix_sdk_ffi_impl_Room_alternative_aliases_6756(self.pointer, $0
    )
}
        )
    }

    public func `avatarUrl`()  -> String? {
        return try!  FfiConverterOptionString.lift(
            try! 
    rustCall() {
    
    _uniffi_matrix_sdk_ffi_impl_Room_avatar_url_723b(self.pointer, $0
    )
}
        )
    }

    public func `canonicalAlias`()  -> String? {
        return try!  FfiConverterOptionString.lift(
            try! 
    rustCall() {
    
    _uniffi_matrix_sdk_ffi_impl_Room_canonical_alias_6c5e(self.pointer, $0
    )
}
        )
    }

    public func `fetchMembers`()  {
        try! 
    rustCall() {
    
    _uniffi_matrix_sdk_ffi_impl_Room_fetch_members_caf7(self.pointer, $0
    )
}
    }

    public func `id`()  -> String {
        return try!  FfiConverterString.lift(
            try! 
    rustCall() {
    
    _uniffi_matrix_sdk_ffi_impl_Room_id_8cb8(self.pointer, $0
    )
}
        )
    }

    public func `inviter`()  -> RoomMember? {
        return try!  FfiConverterOptionTypeRoomMember.lift(
            try! 
    rustCall() {
    
    _uniffi_matrix_sdk_ffi_impl_Room_inviter_679(self.pointer, $0
    )
}
        )
    }

    public func `isDirect`()  -> Bool {
        return try!  FfiConverterBool.lift(
            try! 
    rustCall() {
    
    _uniffi_matrix_sdk_ffi_impl_Room_is_direct_5762(self.pointer, $0
    )
}
        )
    }

    public func `isPublic`()  -> Bool {
        return try!  FfiConverterBool.lift(
            try! 
    rustCall() {
    
    _uniffi_matrix_sdk_ffi_impl_Room_is_public_ea60(self.pointer, $0
    )
}
        )
    }

    public func `isSpace`()  -> Bool {
        return try!  FfiConverterBool.lift(
            try! 
    rustCall() {
    
    _uniffi_matrix_sdk_ffi_impl_Room_is_space_4eb2(self.pointer, $0
    )
}
        )
    }

    public func `isTombstoned`()  -> Bool {
        return try!  FfiConverterBool.lift(
            try! 
    rustCall() {
    
    _uniffi_matrix_sdk_ffi_impl_Room_is_tombstoned_649(self.pointer, $0
    )
}
        )
    }

    public func `membership`()  -> Membership {
        return try!  FfiConverterTypeMembership.lift(
            try! 
    rustCall() {
    
    _uniffi_matrix_sdk_ffi_impl_Room_membership_723(self.pointer, $0
    )
}
        )
    }

    public func `name`()  -> String? {
        return try!  FfiConverterOptionString.lift(
            try! 
    rustCall() {
    
    _uniffi_matrix_sdk_ffi_impl_Room_name_961e(self.pointer, $0
    )
}
        )
    }

    public func `removeTimeline`()  {
        try! 
    rustCall() {
    
    _uniffi_matrix_sdk_ffi_impl_Room_remove_timeline_28b8(self.pointer, $0
    )
}
    }

    public func `retryDecryption`(`sessionIds`: [String])  {
        try! 
    rustCall() {
    
    _uniffi_matrix_sdk_ffi_impl_Room_retry_decryption_d3c(self.pointer, 
        FfiConverterSequenceString.lower(`sessionIds`), $0
    )
}
    }

    public func `topic`()  -> String? {
        return try!  FfiConverterOptionString.lift(
            try! 
    rustCall() {
    
    _uniffi_matrix_sdk_ffi_impl_Room_topic_cc24(self.pointer, $0
    )
}
        )
    }
}



public struct FfiConverterTypeRoom: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Room

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Room {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Room, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Room {
        return Room(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Room) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}


public func FfiConverterTypeRoom_lift(_ pointer: UnsafeMutableRawPointer) throws -> Room {
    return try FfiConverterTypeRoom.lift(pointer)
}

public func FfiConverterTypeRoom_lower(_ value: Room) -> UnsafeMutableRawPointer {
    return FfiConverterTypeRoom.lower(value)
}


public protocol RoomMemberProtocol {
    func `avatarUrl`()   -> String?
    func `displayName`()   -> String?
    func `ignore`()  throws
    func `isAccountUser`()   -> Bool
    func `isIgnored`()   -> Bool
    func `isNameAmbiguous`()   -> Bool
    func `membership`()   -> MembershipState
    func `normalizedPowerLevel`()   -> Int64
    func `powerLevel`()   -> Int64
    func `unignore`()  throws
    func `userId`()   -> String
    
}

public class RoomMember: RoomMemberProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { ffi_matrix_sdk_ffi_8d0d_RoomMember_object_free(pointer, $0) }
    }

    

    
    

    public func `avatarUrl`()  -> String? {
        return try!  FfiConverterOptionString.lift(
            try! 
    rustCall() {
    
    _uniffi_matrix_sdk_ffi_impl_RoomMember_avatar_url_4027(self.pointer, $0
    )
}
        )
    }

    public func `displayName`()  -> String? {
        return try!  FfiConverterOptionString.lift(
            try! 
    rustCall() {
    
    _uniffi_matrix_sdk_ffi_impl_RoomMember_display_name_a28c(self.pointer, $0
    )
}
        )
    }

    public func `ignore`() throws {
        try 
    rustCallWithError(FfiConverterTypeClientError.self) {
    _uniffi_matrix_sdk_ffi_impl_RoomMember_ignore_5349(self.pointer, $0
    )
}
    }

    public func `isAccountUser`()  -> Bool {
        return try!  FfiConverterBool.lift(
            try! 
    rustCall() {
    
    _uniffi_matrix_sdk_ffi_impl_RoomMember_is_account_user_22e7(self.pointer, $0
    )
}
        )
    }

    public func `isIgnored`()  -> Bool {
        return try!  FfiConverterBool.lift(
            try! 
    rustCall() {
    
    _uniffi_matrix_sdk_ffi_impl_RoomMember_is_ignored_e9ed(self.pointer, $0
    )
}
        )
    }

    public func `isNameAmbiguous`()  -> Bool {
        return try!  FfiConverterBool.lift(
            try! 
    rustCall() {
    
    _uniffi_matrix_sdk_ffi_impl_RoomMember_is_name_ambiguous_4eb9(self.pointer, $0
    )
}
        )
    }

    public func `membership`()  -> MembershipState {
        return try!  FfiConverterTypeMembershipState.lift(
            try! 
    rustCall() {
    
    _uniffi_matrix_sdk_ffi_impl_RoomMember_membership_8b7e(self.pointer, $0
    )
}
        )
    }

    public func `normalizedPowerLevel`()  -> Int64 {
        return try!  FfiConverterInt64.lift(
            try! 
    rustCall() {
    
    _uniffi_matrix_sdk_ffi_impl_RoomMember_normalized_power_level_c46(self.pointer, $0
    )
}
        )
    }

    public func `powerLevel`()  -> Int64 {
        return try!  FfiConverterInt64.lift(
            try! 
    rustCall() {
    
    _uniffi_matrix_sdk_ffi_impl_RoomMember_power_level_e051(self.pointer, $0
    )
}
        )
    }

    public func `unignore`() throws {
        try 
    rustCallWithError(FfiConverterTypeClientError.self) {
    _uniffi_matrix_sdk_ffi_impl_RoomMember_unignore_9d34(self.pointer, $0
    )
}
    }

    public func `userId`()  -> String {
        return try!  FfiConverterString.lift(
            try! 
    rustCall() {
    
    _uniffi_matrix_sdk_ffi_impl_RoomMember_user_id_c970(self.pointer, $0
    )
}
        )
    }
}



public struct FfiConverterTypeRoomMember: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = RoomMember

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RoomMember {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: RoomMember, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> RoomMember {
        return RoomMember(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: RoomMember) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}


public func FfiConverterTypeRoomMember_lift(_ pointer: UnsafeMutableRawPointer) throws -> RoomMember {
    return try FfiConverterTypeRoomMember.lift(pointer)
}

public func FfiConverterTypeRoomMember_lower(_ value: RoomMember) -> UnsafeMutableRawPointer {
    return FfiConverterTypeRoomMember.lower(value)
}


public protocol RoomMessageEventContentProtocol {
    
}

public class RoomMessageEventContent: RoomMessageEventContentProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { ffi_matrix_sdk_ffi_8d0d_RoomMessageEventContent_object_free(pointer, $0) }
    }

    

    
    
}



public struct FfiConverterTypeRoomMessageEventContent: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = RoomMessageEventContent

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RoomMessageEventContent {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: RoomMessageEventContent, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> RoomMessageEventContent {
        return RoomMessageEventContent(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: RoomMessageEventContent) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}


public func FfiConverterTypeRoomMessageEventContent_lift(_ pointer: UnsafeMutableRawPointer) throws -> RoomMessageEventContent {
    return try FfiConverterTypeRoomMessageEventContent.lift(pointer)
}

public func FfiConverterTypeRoomMessageEventContent_lower(_ value: RoomMessageEventContent) -> UnsafeMutableRawPointer {
    return FfiConverterTypeRoomMessageEventContent.lower(value)
}


public protocol SessionVerificationControllerProtocol {
    func `setDelegate`(`delegate`: SessionVerificationControllerDelegate?)  
    func `requestVerification`()  throws
    func `startSasVerification`()  throws
    func `approveVerification`()  throws
    func `declineVerification`()  throws
    func `cancelVerification`()  throws
    func `isVerified`()   -> Bool
    
}

public class SessionVerificationController: SessionVerificationControllerProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { ffi_matrix_sdk_ffi_8d0d_SessionVerificationController_object_free(pointer, $0) }
    }

    

    
    

    public func `setDelegate`(`delegate`: SessionVerificationControllerDelegate?)  {
        try! 
    rustCall() {
    
    matrix_sdk_ffi_8d0d_SessionVerificationController_set_delegate(self.pointer, 
        FfiConverterOptionCallbackInterfaceSessionVerificationControllerDelegate.lower(`delegate`), $0
    )
}
    }

    public func `requestVerification`() throws {
        try 
    rustCallWithError(FfiConverterTypeClientError.self) {
    matrix_sdk_ffi_8d0d_SessionVerificationController_request_verification(self.pointer, $0
    )
}
    }

    public func `startSasVerification`() throws {
        try 
    rustCallWithError(FfiConverterTypeClientError.self) {
    matrix_sdk_ffi_8d0d_SessionVerificationController_start_sas_verification(self.pointer, $0
    )
}
    }

    public func `approveVerification`() throws {
        try 
    rustCallWithError(FfiConverterTypeClientError.self) {
    matrix_sdk_ffi_8d0d_SessionVerificationController_approve_verification(self.pointer, $0
    )
}
    }

    public func `declineVerification`() throws {
        try 
    rustCallWithError(FfiConverterTypeClientError.self) {
    matrix_sdk_ffi_8d0d_SessionVerificationController_decline_verification(self.pointer, $0
    )
}
    }

    public func `cancelVerification`() throws {
        try 
    rustCallWithError(FfiConverterTypeClientError.self) {
    matrix_sdk_ffi_8d0d_SessionVerificationController_cancel_verification(self.pointer, $0
    )
}
    }

    public func `isVerified`()  -> Bool {
        return try!  FfiConverterBool.lift(
            try! 
    rustCall() {
    
    _uniffi_matrix_sdk_ffi_impl_SessionVerificationController_is_verified_e7e9(self.pointer, $0
    )
}
        )
    }
}



public struct FfiConverterTypeSessionVerificationController: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = SessionVerificationController

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SessionVerificationController {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: SessionVerificationController, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> SessionVerificationController {
        return SessionVerificationController(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: SessionVerificationController) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}


public func FfiConverterTypeSessionVerificationController_lift(_ pointer: UnsafeMutableRawPointer) throws -> SessionVerificationController {
    return try FfiConverterTypeSessionVerificationController.lift(pointer)
}

public func FfiConverterTypeSessionVerificationController_lower(_ value: SessionVerificationController) -> UnsafeMutableRawPointer {
    return FfiConverterTypeSessionVerificationController.lower(value)
}


public protocol SessionVerificationEmojiProtocol {
    func `description`()   -> String
    func `symbol`()   -> String
    
}

public class SessionVerificationEmoji: SessionVerificationEmojiProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { ffi_matrix_sdk_ffi_8d0d_SessionVerificationEmoji_object_free(pointer, $0) }
    }

    

    
    

    public func `description`()  -> String {
        return try!  FfiConverterString.lift(
            try! 
    rustCall() {
    
    _uniffi_matrix_sdk_ffi_impl_SessionVerificationEmoji_description_955f(self.pointer, $0
    )
}
        )
    }

    public func `symbol`()  -> String {
        return try!  FfiConverterString.lift(
            try! 
    rustCall() {
    
    _uniffi_matrix_sdk_ffi_impl_SessionVerificationEmoji_symbol_89f7(self.pointer, $0
    )
}
        )
    }
}



public struct FfiConverterTypeSessionVerificationEmoji: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = SessionVerificationEmoji

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SessionVerificationEmoji {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: SessionVerificationEmoji, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> SessionVerificationEmoji {
        return SessionVerificationEmoji(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: SessionVerificationEmoji) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}


public func FfiConverterTypeSessionVerificationEmoji_lift(_ pointer: UnsafeMutableRawPointer) throws -> SessionVerificationEmoji {
    return try FfiConverterTypeSessionVerificationEmoji.lift(pointer)
}

public func FfiConverterTypeSessionVerificationEmoji_lower(_ value: SessionVerificationEmoji) -> UnsafeMutableRawPointer {
    return FfiConverterTypeSessionVerificationEmoji.lower(value)
}


public protocol SlidingSyncProtocol {
    func `setObserver`(`observer`: SlidingSyncObserver?)  
    func `subscribe`(`roomId`: String, `settings`: RoomSubscription?)  throws
    func `unsubscribe`(`roomId`: String)  throws
    func `getRoom`(`roomId`: String)  throws -> SlidingSyncRoom?
    func `getRooms`(`roomIds`: [String])  throws -> [SlidingSyncRoom?]
    func `addCommonExtensions`()  
    func `addList`(`list`: SlidingSyncList)   -> SlidingSyncList?
    func `getList`(`name`: String)   -> SlidingSyncList?
    func `popList`(`name`: String)   -> SlidingSyncList?
    func `resetLists`()  
    func `sync`()   -> TaskHandle
    
}

public class SlidingSync: SlidingSyncProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { ffi_matrix_sdk_ffi_8d0d_SlidingSync_object_free(pointer, $0) }
    }

    

    
    

    public func `setObserver`(`observer`: SlidingSyncObserver?)  {
        try! 
    rustCall() {
    
    matrix_sdk_ffi_8d0d_SlidingSync_set_observer(self.pointer, 
        FfiConverterOptionCallbackInterfaceSlidingSyncObserver.lower(`observer`), $0
    )
}
    }

    public func `subscribe`(`roomId`: String, `settings`: RoomSubscription?) throws {
        try 
    rustCallWithError(FfiConverterTypeClientError.self) {
    matrix_sdk_ffi_8d0d_SlidingSync_subscribe(self.pointer, 
        FfiConverterString.lower(`roomId`), 
        FfiConverterOptionTypeRoomSubscription.lower(`settings`), $0
    )
}
    }

    public func `unsubscribe`(`roomId`: String) throws {
        try 
    rustCallWithError(FfiConverterTypeClientError.self) {
    matrix_sdk_ffi_8d0d_SlidingSync_unsubscribe(self.pointer, 
        FfiConverterString.lower(`roomId`), $0
    )
}
    }

    public func `getRoom`(`roomId`: String) throws -> SlidingSyncRoom? {
        return try  FfiConverterOptionTypeSlidingSyncRoom.lift(
            try 
    rustCallWithError(FfiConverterTypeClientError.self) {
    matrix_sdk_ffi_8d0d_SlidingSync_get_room(self.pointer, 
        FfiConverterString.lower(`roomId`), $0
    )
}
        )
    }

    public func `getRooms`(`roomIds`: [String]) throws -> [SlidingSyncRoom?] {
        return try  FfiConverterSequenceOptionTypeSlidingSyncRoom.lift(
            try 
    rustCallWithError(FfiConverterTypeClientError.self) {
    matrix_sdk_ffi_8d0d_SlidingSync_get_rooms(self.pointer, 
        FfiConverterSequenceString.lower(`roomIds`), $0
    )
}
        )
    }

    public func `addCommonExtensions`()  {
        try! 
    rustCall() {
    
    _uniffi_matrix_sdk_ffi_impl_SlidingSync_add_common_extensions_6d8e(self.pointer, $0
    )
}
    }

    public func `addList`(`list`: SlidingSyncList)  -> SlidingSyncList? {
        return try!  FfiConverterOptionTypeSlidingSyncList.lift(
            try! 
    rustCall() {
    
    _uniffi_matrix_sdk_ffi_impl_SlidingSync_add_list_691f(self.pointer, 
        FfiConverterTypeSlidingSyncList.lower(`list`), $0
    )
}
        )
    }

    public func `getList`(`name`: String)  -> SlidingSyncList? {
        return try!  FfiConverterOptionTypeSlidingSyncList.lift(
            try! 
    rustCall() {
    
    _uniffi_matrix_sdk_ffi_impl_SlidingSync_get_list_535c(self.pointer, 
        FfiConverterString.lower(`name`), $0
    )
}
        )
    }

    public func `popList`(`name`: String)  -> SlidingSyncList? {
        return try!  FfiConverterOptionTypeSlidingSyncList.lift(
            try! 
    rustCall() {
    
    _uniffi_matrix_sdk_ffi_impl_SlidingSync_pop_list_c712(self.pointer, 
        FfiConverterString.lower(`name`), $0
    )
}
        )
    }

    public func `resetLists`()  {
        try! 
    rustCall() {
    
    _uniffi_matrix_sdk_ffi_impl_SlidingSync_reset_lists_4375(self.pointer, $0
    )
}
    }

    public func `sync`()  -> TaskHandle {
        return try!  FfiConverterTypeTaskHandle.lift(
            try! 
    rustCall() {
    
    _uniffi_matrix_sdk_ffi_impl_SlidingSync_sync_4bb(self.pointer, $0
    )
}
        )
    }
}



public struct FfiConverterTypeSlidingSync: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = SlidingSync

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SlidingSync {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: SlidingSync, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> SlidingSync {
        return SlidingSync(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: SlidingSync) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}


public func FfiConverterTypeSlidingSync_lift(_ pointer: UnsafeMutableRawPointer) throws -> SlidingSync {
    return try FfiConverterTypeSlidingSync.lift(pointer)
}

public func FfiConverterTypeSlidingSync_lower(_ value: SlidingSync) -> UnsafeMutableRawPointer {
    return FfiConverterTypeSlidingSync.lower(value)
}


public protocol SlidingSyncBuilderProtocol {
    func `homeserver`(`url`: String)  throws -> SlidingSyncBuilder
    func `build`()  throws -> SlidingSync
    func `addList`(`v`: SlidingSyncList)   -> SlidingSyncBuilder
    func `storageKey`(`name`: String?)   -> SlidingSyncBuilder
    func `withAllExtensions`()   -> SlidingSyncBuilder
    func `withCommonExtensions`()   -> SlidingSyncBuilder
    func `withoutAccountDataExtension`()   -> SlidingSyncBuilder
    func `withoutE2eeExtension`()   -> SlidingSyncBuilder
    func `withoutReceiptExtension`()   -> SlidingSyncBuilder
    func `withoutToDeviceExtension`()   -> SlidingSyncBuilder
    func `withoutTypingExtension`()   -> SlidingSyncBuilder
    
}

public class SlidingSyncBuilder: SlidingSyncBuilderProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { ffi_matrix_sdk_ffi_8d0d_SlidingSyncBuilder_object_free(pointer, $0) }
    }

    

    
    

    public func `homeserver`(`url`: String) throws -> SlidingSyncBuilder {
        return try  FfiConverterTypeSlidingSyncBuilder.lift(
            try 
    rustCallWithError(FfiConverterTypeClientError.self) {
    matrix_sdk_ffi_8d0d_SlidingSyncBuilder_homeserver(self.pointer, 
        FfiConverterString.lower(`url`), $0
    )
}
        )
    }

    public func `build`() throws -> SlidingSync {
        return try  FfiConverterTypeSlidingSync.lift(
            try 
    rustCallWithError(FfiConverterTypeClientError.self) {
    matrix_sdk_ffi_8d0d_SlidingSyncBuilder_build(self.pointer, $0
    )
}
        )
    }

    public func `addList`(`v`: SlidingSyncList)  -> SlidingSyncBuilder {
        return try!  FfiConverterTypeSlidingSyncBuilder.lift(
            try! 
    rustCall() {
    
    _uniffi_matrix_sdk_ffi_impl_SlidingSyncBuilder_add_list_2044(self.pointer, 
        FfiConverterTypeSlidingSyncList.lower(`v`), $0
    )
}
        )
    }

    public func `storageKey`(`name`: String?)  -> SlidingSyncBuilder {
        return try!  FfiConverterTypeSlidingSyncBuilder.lift(
            try! 
    rustCall() {
    
    _uniffi_matrix_sdk_ffi_impl_SlidingSyncBuilder_storage_key_224b(self.pointer, 
        FfiConverterOptionString.lower(`name`), $0
    )
}
        )
    }

    public func `withAllExtensions`()  -> SlidingSyncBuilder {
        return try!  FfiConverterTypeSlidingSyncBuilder.lift(
            try! 
    rustCall() {
    
    _uniffi_matrix_sdk_ffi_impl_SlidingSyncBuilder_with_all_extensions_7e0f(self.pointer, $0
    )
}
        )
    }

    public func `withCommonExtensions`()  -> SlidingSyncBuilder {
        return try!  FfiConverterTypeSlidingSyncBuilder.lift(
            try! 
    rustCall() {
    
    _uniffi_matrix_sdk_ffi_impl_SlidingSyncBuilder_with_common_extensions_e90d(self.pointer, $0
    )
}
        )
    }

    public func `withoutAccountDataExtension`()  -> SlidingSyncBuilder {
        return try!  FfiConverterTypeSlidingSyncBuilder.lift(
            try! 
    rustCall() {
    
    _uniffi_matrix_sdk_ffi_impl_SlidingSyncBuilder_without_account_data_extension_d3f5(self.pointer, $0
    )
}
        )
    }

    public func `withoutE2eeExtension`()  -> SlidingSyncBuilder {
        return try!  FfiConverterTypeSlidingSyncBuilder.lift(
            try! 
    rustCall() {
    
    _uniffi_matrix_sdk_ffi_impl_SlidingSyncBuilder_without_e2ee_extension_bc03(self.pointer, $0
    )
}
        )
    }

    public func `withoutReceiptExtension`()  -> SlidingSyncBuilder {
        return try!  FfiConverterTypeSlidingSyncBuilder.lift(
            try! 
    rustCall() {
    
    _uniffi_matrix_sdk_ffi_impl_SlidingSyncBuilder_without_receipt_extension_ea21(self.pointer, $0
    )
}
        )
    }

    public func `withoutToDeviceExtension`()  -> SlidingSyncBuilder {
        return try!  FfiConverterTypeSlidingSyncBuilder.lift(
            try! 
    rustCall() {
    
    _uniffi_matrix_sdk_ffi_impl_SlidingSyncBuilder_without_to_device_extension_2502(self.pointer, $0
    )
}
        )
    }

    public func `withoutTypingExtension`()  -> SlidingSyncBuilder {
        return try!  FfiConverterTypeSlidingSyncBuilder.lift(
            try! 
    rustCall() {
    
    _uniffi_matrix_sdk_ffi_impl_SlidingSyncBuilder_without_typing_extension_96fe(self.pointer, $0
    )
}
        )
    }
}



public struct FfiConverterTypeSlidingSyncBuilder: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = SlidingSyncBuilder

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SlidingSyncBuilder {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: SlidingSyncBuilder, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> SlidingSyncBuilder {
        return SlidingSyncBuilder(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: SlidingSyncBuilder) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}


public func FfiConverterTypeSlidingSyncBuilder_lift(_ pointer: UnsafeMutableRawPointer) throws -> SlidingSyncBuilder {
    return try FfiConverterTypeSlidingSyncBuilder.lift(pointer)
}

public func FfiConverterTypeSlidingSyncBuilder_lower(_ value: SlidingSyncBuilder) -> UnsafeMutableRawPointer {
    return FfiConverterTypeSlidingSyncBuilder.lower(value)
}


public protocol SlidingSyncListProtocol {
    func `observeRoomList`(`observer`: SlidingSyncListRoomListObserver)   -> TaskHandle
    func `observeRoomsCount`(`observer`: SlidingSyncListRoomsCountObserver)   -> TaskHandle
    func `observeState`(`observer`: SlidingSyncListStateObserver)   -> TaskHandle
    func `addRange`(`start`: UInt32, `end`: UInt32)  throws
    func `currentRoomCount`()   -> UInt32?
    func `currentRoomList`()   -> [RoomListEntry]
    func `getTimelineLimit`()   -> UInt32?
    func `resetRanges`()  throws
    func `setRange`(`start`: UInt32, `end`: UInt32)  throws
    func `setTimelineLimit`(`value`: UInt32)  
    func `unsetTimelineLimit`()  
    
}

public class SlidingSyncList: SlidingSyncListProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { ffi_matrix_sdk_ffi_8d0d_SlidingSyncList_object_free(pointer, $0) }
    }

    

    
    

    public func `observeRoomList`(`observer`: SlidingSyncListRoomListObserver)  -> TaskHandle {
        return try!  FfiConverterTypeTaskHandle.lift(
            try! 
    rustCall() {
    
    matrix_sdk_ffi_8d0d_SlidingSyncList_observe_room_list(self.pointer, 
        FfiConverterCallbackInterfaceSlidingSyncListRoomListObserver.lower(`observer`), $0
    )
}
        )
    }

    public func `observeRoomsCount`(`observer`: SlidingSyncListRoomsCountObserver)  -> TaskHandle {
        return try!  FfiConverterTypeTaskHandle.lift(
            try! 
    rustCall() {
    
    matrix_sdk_ffi_8d0d_SlidingSyncList_observe_rooms_count(self.pointer, 
        FfiConverterCallbackInterfaceSlidingSyncListRoomsCountObserver.lower(`observer`), $0
    )
}
        )
    }

    public func `observeState`(`observer`: SlidingSyncListStateObserver)  -> TaskHandle {
        return try!  FfiConverterTypeTaskHandle.lift(
            try! 
    rustCall() {
    
    matrix_sdk_ffi_8d0d_SlidingSyncList_observe_state(self.pointer, 
        FfiConverterCallbackInterfaceSlidingSyncListStateObserver.lower(`observer`), $0
    )
}
        )
    }

    public func `addRange`(`start`: UInt32, `end`: UInt32) throws {
        try 
    rustCallWithError(FfiConverterTypeSlidingSyncError.self) {
    _uniffi_matrix_sdk_ffi_impl_SlidingSyncList_add_range_78e2(self.pointer, 
        FfiConverterUInt32.lower(`start`), 
        FfiConverterUInt32.lower(`end`), $0
    )
}
    }

    public func `currentRoomCount`()  -> UInt32? {
        return try!  FfiConverterOptionUInt32.lift(
            try! 
    rustCall() {
    
    _uniffi_matrix_sdk_ffi_impl_SlidingSyncList_current_room_count_8e0(self.pointer, $0
    )
}
        )
    }

    public func `currentRoomList`()  -> [RoomListEntry] {
        return try!  FfiConverterSequenceTypeRoomListEntry.lift(
            try! 
    rustCall() {
    
    _uniffi_matrix_sdk_ffi_impl_SlidingSyncList_current_room_list_34df(self.pointer, $0
    )
}
        )
    }

    public func `getTimelineLimit`()  -> UInt32? {
        return try!  FfiConverterOptionUInt32.lift(
            try! 
    rustCall() {
    
    _uniffi_matrix_sdk_ffi_impl_SlidingSyncList_get_timeline_limit_486f(self.pointer, $0
    )
}
        )
    }

    public func `resetRanges`() throws {
        try 
    rustCallWithError(FfiConverterTypeSlidingSyncError.self) {
    _uniffi_matrix_sdk_ffi_impl_SlidingSyncList_reset_ranges_7aea(self.pointer, $0
    )
}
    }

    public func `setRange`(`start`: UInt32, `end`: UInt32) throws {
        try 
    rustCallWithError(FfiConverterTypeSlidingSyncError.self) {
    _uniffi_matrix_sdk_ffi_impl_SlidingSyncList_set_range_d537(self.pointer, 
        FfiConverterUInt32.lower(`start`), 
        FfiConverterUInt32.lower(`end`), $0
    )
}
    }

    public func `setTimelineLimit`(`value`: UInt32)  {
        try! 
    rustCall() {
    
    _uniffi_matrix_sdk_ffi_impl_SlidingSyncList_set_timeline_limit_17e1(self.pointer, 
        FfiConverterUInt32.lower(`value`), $0
    )
}
    }

    public func `unsetTimelineLimit`()  {
        try! 
    rustCall() {
    
    _uniffi_matrix_sdk_ffi_impl_SlidingSyncList_unset_timeline_limit_336e(self.pointer, $0
    )
}
    }
}



public struct FfiConverterTypeSlidingSyncList: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = SlidingSyncList

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SlidingSyncList {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: SlidingSyncList, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> SlidingSyncList {
        return SlidingSyncList(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: SlidingSyncList) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}


public func FfiConverterTypeSlidingSyncList_lift(_ pointer: UnsafeMutableRawPointer) throws -> SlidingSyncList {
    return try FfiConverterTypeSlidingSyncList.lift(pointer)
}

public func FfiConverterTypeSlidingSyncList_lower(_ value: SlidingSyncList) -> UnsafeMutableRawPointer {
    return FfiConverterTypeSlidingSyncList.lower(value)
}


public protocol SlidingSyncListBuilderProtocol {
    func `syncMode`(`mode`: SlidingSyncMode)   -> SlidingSyncListBuilder
    func `build`()  throws -> SlidingSyncList
    func `addRange`(`from`: UInt32, `to`: UInt32)   -> SlidingSyncListBuilder
    func `batchSize`(`batchSize`: UInt32)   -> SlidingSyncListBuilder
    func `filters`(`filters`: SlidingSyncRequestListFilters)   -> SlidingSyncListBuilder
    func `name`(`name`: String)   -> SlidingSyncListBuilder
    func `noFilters`()   -> SlidingSyncListBuilder
    func `noRoomLimit`()   -> SlidingSyncListBuilder
    func `noTimelineLimit`()   -> SlidingSyncListBuilder
    func `requiredState`(`requiredState`: [RequiredState])   -> SlidingSyncListBuilder
    func `resetRanges`()   -> SlidingSyncListBuilder
    func `roomLimit`(`limit`: UInt32)   -> SlidingSyncListBuilder
    func `sort`(`sort`: [String])   -> SlidingSyncListBuilder
    func `timelineLimit`(`limit`: UInt32)   -> SlidingSyncListBuilder
    
}

public class SlidingSyncListBuilder: SlidingSyncListBuilderProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }
    public convenience init()  {
        self.init(unsafeFromRawPointer: try! rustCall() {
    matrix_sdk_ffi_8d0d_SlidingSyncListBuilder_new($0)
})
    }

    deinit {
        try! rustCall { ffi_matrix_sdk_ffi_8d0d_SlidingSyncListBuilder_object_free(pointer, $0) }
    }

    

    
    

    public func `syncMode`(`mode`: SlidingSyncMode)  -> SlidingSyncListBuilder {
        return try!  FfiConverterTypeSlidingSyncListBuilder.lift(
            try! 
    rustCall() {
    
    matrix_sdk_ffi_8d0d_SlidingSyncListBuilder_sync_mode(self.pointer, 
        FfiConverterTypeSlidingSyncMode.lower(`mode`), $0
    )
}
        )
    }

    public func `build`() throws -> SlidingSyncList {
        return try  FfiConverterTypeSlidingSyncList.lift(
            try 
    rustCallWithError(FfiConverterTypeClientError.self) {
    matrix_sdk_ffi_8d0d_SlidingSyncListBuilder_build(self.pointer, $0
    )
}
        )
    }

    public func `addRange`(`from`: UInt32, `to`: UInt32)  -> SlidingSyncListBuilder {
        return try!  FfiConverterTypeSlidingSyncListBuilder.lift(
            try! 
    rustCall() {
    
    _uniffi_matrix_sdk_ffi_impl_SlidingSyncListBuilder_add_range_2f2d(self.pointer, 
        FfiConverterUInt32.lower(`from`), 
        FfiConverterUInt32.lower(`to`), $0
    )
}
        )
    }

    public func `batchSize`(`batchSize`: UInt32)  -> SlidingSyncListBuilder {
        return try!  FfiConverterTypeSlidingSyncListBuilder.lift(
            try! 
    rustCall() {
    
    _uniffi_matrix_sdk_ffi_impl_SlidingSyncListBuilder_batch_size_2b78(self.pointer, 
        FfiConverterUInt32.lower(`batchSize`), $0
    )
}
        )
    }

    public func `filters`(`filters`: SlidingSyncRequestListFilters)  -> SlidingSyncListBuilder {
        return try!  FfiConverterTypeSlidingSyncListBuilder.lift(
            try! 
    rustCall() {
    
    _uniffi_matrix_sdk_ffi_impl_SlidingSyncListBuilder_filters_3274(self.pointer, 
        FfiConverterTypeSlidingSyncRequestListFilters.lower(`filters`), $0
    )
}
        )
    }

    public func `name`(`name`: String)  -> SlidingSyncListBuilder {
        return try!  FfiConverterTypeSlidingSyncListBuilder.lift(
            try! 
    rustCall() {
    
    _uniffi_matrix_sdk_ffi_impl_SlidingSyncListBuilder_name_dfb(self.pointer, 
        FfiConverterString.lower(`name`), $0
    )
}
        )
    }

    public func `noFilters`()  -> SlidingSyncListBuilder {
        return try!  FfiConverterTypeSlidingSyncListBuilder.lift(
            try! 
    rustCall() {
    
    _uniffi_matrix_sdk_ffi_impl_SlidingSyncListBuilder_no_filters_3d7b(self.pointer, $0
    )
}
        )
    }

    public func `noRoomLimit`()  -> SlidingSyncListBuilder {
        return try!  FfiConverterTypeSlidingSyncListBuilder.lift(
            try! 
    rustCall() {
    
    _uniffi_matrix_sdk_ffi_impl_SlidingSyncListBuilder_no_room_limit_9ab4(self.pointer, $0
    )
}
        )
    }

    public func `noTimelineLimit`()  -> SlidingSyncListBuilder {
        return try!  FfiConverterTypeSlidingSyncListBuilder.lift(
            try! 
    rustCall() {
    
    _uniffi_matrix_sdk_ffi_impl_SlidingSyncListBuilder_no_timeline_limit_1d0d(self.pointer, $0
    )
}
        )
    }

    public func `requiredState`(`requiredState`: [RequiredState])  -> SlidingSyncListBuilder {
        return try!  FfiConverterTypeSlidingSyncListBuilder.lift(
            try! 
    rustCall() {
    
    _uniffi_matrix_sdk_ffi_impl_SlidingSyncListBuilder_required_state_827b(self.pointer, 
        FfiConverterSequenceTypeRequiredState.lower(`requiredState`), $0
    )
}
        )
    }

    public func `resetRanges`()  -> SlidingSyncListBuilder {
        return try!  FfiConverterTypeSlidingSyncListBuilder.lift(
            try! 
    rustCall() {
    
    _uniffi_matrix_sdk_ffi_impl_SlidingSyncListBuilder_reset_ranges_5b71(self.pointer, $0
    )
}
        )
    }

    public func `roomLimit`(`limit`: UInt32)  -> SlidingSyncListBuilder {
        return try!  FfiConverterTypeSlidingSyncListBuilder.lift(
            try! 
    rustCall() {
    
    _uniffi_matrix_sdk_ffi_impl_SlidingSyncListBuilder_room_limit_d39c(self.pointer, 
        FfiConverterUInt32.lower(`limit`), $0
    )
}
        )
    }

    public func `sort`(`sort`: [String])  -> SlidingSyncListBuilder {
        return try!  FfiConverterTypeSlidingSyncListBuilder.lift(
            try! 
    rustCall() {
    
    _uniffi_matrix_sdk_ffi_impl_SlidingSyncListBuilder_sort_1272(self.pointer, 
        FfiConverterSequenceString.lower(`sort`), $0
    )
}
        )
    }

    public func `timelineLimit`(`limit`: UInt32)  -> SlidingSyncListBuilder {
        return try!  FfiConverterTypeSlidingSyncListBuilder.lift(
            try! 
    rustCall() {
    
    _uniffi_matrix_sdk_ffi_impl_SlidingSyncListBuilder_timeline_limit_554d(self.pointer, 
        FfiConverterUInt32.lower(`limit`), $0
    )
}
        )
    }
}



public struct FfiConverterTypeSlidingSyncListBuilder: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = SlidingSyncListBuilder

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SlidingSyncListBuilder {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: SlidingSyncListBuilder, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> SlidingSyncListBuilder {
        return SlidingSyncListBuilder(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: SlidingSyncListBuilder) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}


public func FfiConverterTypeSlidingSyncListBuilder_lift(_ pointer: UnsafeMutableRawPointer) throws -> SlidingSyncListBuilder {
    return try FfiConverterTypeSlidingSyncListBuilder.lift(pointer)
}

public func FfiConverterTypeSlidingSyncListBuilder_lower(_ value: SlidingSyncListBuilder) -> UnsafeMutableRawPointer {
    return FfiConverterTypeSlidingSyncListBuilder.lower(value)
}


public protocol SlidingSyncRoomProtocol {
    func `subscribeAndAddTimelineListener`(`listener`: TimelineListener, `settings`: RoomSubscription?)  throws -> SlidingSyncSubscribeResult
    func `addTimelineListener`(`listener`: TimelineListener)  throws -> SlidingSyncSubscribeResult
    func `avatarUrl`()   -> String?
    func `fullRoom`()   -> Room?
    func `hasUnreadNotifications`()   -> Bool
    func `isDm`()   -> Bool?
    func `isInitial`()   -> Bool?
    func `isLoadingMore`()   -> Bool
    func `latestRoomMessage`()   -> EventTimelineItem?
    func `name`()   -> String?
    func `roomId`()   -> String
    func `unreadNotifications`()   -> UnreadNotificationsCount
    
}

public class SlidingSyncRoom: SlidingSyncRoomProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { ffi_matrix_sdk_ffi_8d0d_SlidingSyncRoom_object_free(pointer, $0) }
    }

    

    
    

    public func `subscribeAndAddTimelineListener`(`listener`: TimelineListener, `settings`: RoomSubscription?) throws -> SlidingSyncSubscribeResult {
        return try  FfiConverterTypeSlidingSyncSubscribeResult.lift(
            try 
    rustCallWithError(FfiConverterTypeClientError.self) {
    matrix_sdk_ffi_8d0d_SlidingSyncRoom_subscribe_and_add_timeline_listener(self.pointer, 
        FfiConverterCallbackInterfaceTimelineListener.lower(`listener`), 
        FfiConverterOptionTypeRoomSubscription.lower(`settings`), $0
    )
}
        )
    }

    public func `addTimelineListener`(`listener`: TimelineListener) throws -> SlidingSyncSubscribeResult {
        return try  FfiConverterTypeSlidingSyncSubscribeResult.lift(
            try 
    rustCallWithError(FfiConverterTypeClientError.self) {
    matrix_sdk_ffi_8d0d_SlidingSyncRoom_add_timeline_listener(self.pointer, 
        FfiConverterCallbackInterfaceTimelineListener.lower(`listener`), $0
    )
}
        )
    }

    public func `avatarUrl`()  -> String? {
        return try!  FfiConverterOptionString.lift(
            try! 
    rustCall() {
    
    _uniffi_matrix_sdk_ffi_impl_SlidingSyncRoom_avatar_url_5462(self.pointer, $0
    )
}
        )
    }

    public func `fullRoom`()  -> Room? {
        return try!  FfiConverterOptionTypeRoom.lift(
            try! 
    rustCall() {
    
    _uniffi_matrix_sdk_ffi_impl_SlidingSyncRoom_full_room_6ee7(self.pointer, $0
    )
}
        )
    }

    public func `hasUnreadNotifications`()  -> Bool {
        return try!  FfiConverterBool.lift(
            try! 
    rustCall() {
    
    _uniffi_matrix_sdk_ffi_impl_SlidingSyncRoom_has_unread_notifications_aad9(self.pointer, $0
    )
}
        )
    }

    public func `isDm`()  -> Bool? {
        return try!  FfiConverterOptionBool.lift(
            try! 
    rustCall() {
    
    _uniffi_matrix_sdk_ffi_impl_SlidingSyncRoom_is_dm_8047(self.pointer, $0
    )
}
        )
    }

    public func `isInitial`()  -> Bool? {
        return try!  FfiConverterOptionBool.lift(
            try! 
    rustCall() {
    
    _uniffi_matrix_sdk_ffi_impl_SlidingSyncRoom_is_initial_b79c(self.pointer, $0
    )
}
        )
    }

    public func `isLoadingMore`()  -> Bool {
        return try!  FfiConverterBool.lift(
            try! 
    rustCall() {
    
    _uniffi_matrix_sdk_ffi_impl_SlidingSyncRoom_is_loading_more_98c9(self.pointer, $0
    )
}
        )
    }

    public func `latestRoomMessage`()  -> EventTimelineItem? {
        return try!  FfiConverterOptionTypeEventTimelineItem.lift(
            try! 
    rustCall() {
    
    _uniffi_matrix_sdk_ffi_impl_SlidingSyncRoom_latest_room_message_d69d(self.pointer, $0
    )
}
        )
    }

    public func `name`()  -> String? {
        return try!  FfiConverterOptionString.lift(
            try! 
    rustCall() {
    
    _uniffi_matrix_sdk_ffi_impl_SlidingSyncRoom_name_6a4c(self.pointer, $0
    )
}
        )
    }

    public func `roomId`()  -> String {
        return try!  FfiConverterString.lift(
            try! 
    rustCall() {
    
    _uniffi_matrix_sdk_ffi_impl_SlidingSyncRoom_room_id_a4da(self.pointer, $0
    )
}
        )
    }

    public func `unreadNotifications`()  -> UnreadNotificationsCount {
        return try!  FfiConverterTypeUnreadNotificationsCount.lift(
            try! 
    rustCall() {
    
    _uniffi_matrix_sdk_ffi_impl_SlidingSyncRoom_unread_notifications_4c16(self.pointer, $0
    )
}
        )
    }
}



public struct FfiConverterTypeSlidingSyncRoom: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = SlidingSyncRoom

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SlidingSyncRoom {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: SlidingSyncRoom, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> SlidingSyncRoom {
        return SlidingSyncRoom(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: SlidingSyncRoom) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}


public func FfiConverterTypeSlidingSyncRoom_lift(_ pointer: UnsafeMutableRawPointer) throws -> SlidingSyncRoom {
    return try FfiConverterTypeSlidingSyncRoom.lift(pointer)
}

public func FfiConverterTypeSlidingSyncRoom_lower(_ value: SlidingSyncRoom) -> UnsafeMutableRawPointer {
    return FfiConverterTypeSlidingSyncRoom.lower(value)
}


public protocol TaskHandleProtocol {
    func `cancel`()  
    func `isFinished`()   -> Bool
    
}

public class TaskHandle: TaskHandleProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { ffi_matrix_sdk_ffi_8d0d_TaskHandle_object_free(pointer, $0) }
    }

    

    
    

    public func `cancel`()  {
        try! 
    rustCall() {
    
    _uniffi_matrix_sdk_ffi_impl_TaskHandle_cancel_a65c(self.pointer, $0
    )
}
    }

    public func `isFinished`()  -> Bool {
        return try!  FfiConverterBool.lift(
            try! 
    rustCall() {
    
    _uniffi_matrix_sdk_ffi_impl_TaskHandle_is_finished_56b2(self.pointer, $0
    )
}
        )
    }
}



public struct FfiConverterTypeTaskHandle: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = TaskHandle

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TaskHandle {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: TaskHandle, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> TaskHandle {
        return TaskHandle(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: TaskHandle) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}


public func FfiConverterTypeTaskHandle_lift(_ pointer: UnsafeMutableRawPointer) throws -> TaskHandle {
    return try FfiConverterTypeTaskHandle.lift(pointer)
}

public func FfiConverterTypeTaskHandle_lower(_ value: TaskHandle) -> UnsafeMutableRawPointer {
    return FfiConverterTypeTaskHandle.lower(value)
}


public protocol TimelineDiffProtocol {
    func `append`()   -> [TimelineItem]?
    func `change`()   -> TimelineChange
    func `insert`()   -> InsertData?
    func `pushBack`()   -> TimelineItem?
    func `pushFront`()   -> TimelineItem?
    func `remove`()   -> UInt32?
    func `reset`()   -> [TimelineItem]?
    func `set`()   -> SetData?
    
}

public class TimelineDiff: TimelineDiffProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { ffi_matrix_sdk_ffi_8d0d_TimelineDiff_object_free(pointer, $0) }
    }

    

    
    

    public func `append`()  -> [TimelineItem]? {
        return try!  FfiConverterOptionSequenceTypeTimelineItem.lift(
            try! 
    rustCall() {
    
    _uniffi_matrix_sdk_ffi_impl_TimelineDiff_append_c24b(self.pointer, $0
    )
}
        )
    }

    public func `change`()  -> TimelineChange {
        return try!  FfiConverterTypeTimelineChange.lift(
            try! 
    rustCall() {
    
    _uniffi_matrix_sdk_ffi_impl_TimelineDiff_change_6a6d(self.pointer, $0
    )
}
        )
    }

    public func `insert`()  -> InsertData? {
        return try!  FfiConverterOptionTypeInsertData.lift(
            try! 
    rustCall() {
    
    _uniffi_matrix_sdk_ffi_impl_TimelineDiff_insert_b007(self.pointer, $0
    )
}
        )
    }

    public func `pushBack`()  -> TimelineItem? {
        return try!  FfiConverterOptionTypeTimelineItem.lift(
            try! 
    rustCall() {
    
    _uniffi_matrix_sdk_ffi_impl_TimelineDiff_push_back_3aff(self.pointer, $0
    )
}
        )
    }

    public func `pushFront`()  -> TimelineItem? {
        return try!  FfiConverterOptionTypeTimelineItem.lift(
            try! 
    rustCall() {
    
    _uniffi_matrix_sdk_ffi_impl_TimelineDiff_push_front_96a0(self.pointer, $0
    )
}
        )
    }

    public func `remove`()  -> UInt32? {
        return try!  FfiConverterOptionUInt32.lift(
            try! 
    rustCall() {
    
    _uniffi_matrix_sdk_ffi_impl_TimelineDiff_remove_d74f(self.pointer, $0
    )
}
        )
    }

    public func `reset`()  -> [TimelineItem]? {
        return try!  FfiConverterOptionSequenceTypeTimelineItem.lift(
            try! 
    rustCall() {
    
    _uniffi_matrix_sdk_ffi_impl_TimelineDiff_reset_6b55(self.pointer, $0
    )
}
        )
    }

    public func `set`()  -> SetData? {
        return try!  FfiConverterOptionTypeSetData.lift(
            try! 
    rustCall() {
    
    _uniffi_matrix_sdk_ffi_impl_TimelineDiff_set_3cf2(self.pointer, $0
    )
}
        )
    }
}



public struct FfiConverterTypeTimelineDiff: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = TimelineDiff

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TimelineDiff {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: TimelineDiff, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> TimelineDiff {
        return TimelineDiff(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: TimelineDiff) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}


public func FfiConverterTypeTimelineDiff_lift(_ pointer: UnsafeMutableRawPointer) throws -> TimelineDiff {
    return try FfiConverterTypeTimelineDiff.lift(pointer)
}

public func FfiConverterTypeTimelineDiff_lower(_ value: TimelineDiff) -> UnsafeMutableRawPointer {
    return FfiConverterTypeTimelineDiff.lower(value)
}


public protocol TimelineItemProtocol {
    func `asEvent`()   -> EventTimelineItem?
    func `asVirtual`()   -> VirtualTimelineItem?
    func `fmtDebug`()   -> String
    
}

public class TimelineItem: TimelineItemProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { ffi_matrix_sdk_ffi_8d0d_TimelineItem_object_free(pointer, $0) }
    }

    

    
    

    public func `asEvent`()  -> EventTimelineItem? {
        return try!  FfiConverterOptionTypeEventTimelineItem.lift(
            try! 
    rustCall() {
    
    _uniffi_matrix_sdk_ffi_impl_TimelineItem_as_event_9e04(self.pointer, $0
    )
}
        )
    }

    public func `asVirtual`()  -> VirtualTimelineItem? {
        return try!  FfiConverterOptionTypeVirtualTimelineItem.lift(
            try! 
    rustCall() {
    
    _uniffi_matrix_sdk_ffi_impl_TimelineItem_as_virtual_d72c(self.pointer, $0
    )
}
        )
    }

    public func `fmtDebug`()  -> String {
        return try!  FfiConverterString.lift(
            try! 
    rustCall() {
    
    _uniffi_matrix_sdk_ffi_impl_TimelineItem_fmt_debug_6d42(self.pointer, $0
    )
}
        )
    }
}



public struct FfiConverterTypeTimelineItem: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = TimelineItem

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TimelineItem {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: TimelineItem, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> TimelineItem {
        return TimelineItem(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: TimelineItem) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}


public func FfiConverterTypeTimelineItem_lift(_ pointer: UnsafeMutableRawPointer) throws -> TimelineItem {
    return try FfiConverterTypeTimelineItem.lift(pointer)
}

public func FfiConverterTypeTimelineItem_lower(_ value: TimelineItem) -> UnsafeMutableRawPointer {
    return FfiConverterTypeTimelineItem.lower(value)
}


public protocol TimelineItemContentProtocol {
    func `asMessage`()   -> Message?
    func `kind`()   -> TimelineItemContentKind
    
}

public class TimelineItemContent: TimelineItemContentProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { _uniffi_matrix_sdk_ffi_object_free_TimelineItemContent_2b31(pointer, $0) }
    }

    

    
    

    public func `asMessage`()  -> Message? {
        return try!  FfiConverterOptionTypeMessage.lift(
            try! 
    rustCall() {
    
    _uniffi_matrix_sdk_ffi_impl_TimelineItemContent_as_message_31df(self.pointer, $0
    )
}
        )
    }

    public func `kind`()  -> TimelineItemContentKind {
        return try!  FfiConverterTypeTimelineItemContentKind.lift(
            try! 
    rustCall() {
    
    _uniffi_matrix_sdk_ffi_impl_TimelineItemContent_kind_4894(self.pointer, $0
    )
}
        )
    }
}



public struct FfiConverterTypeTimelineItemContent: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = TimelineItemContent

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TimelineItemContent {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: TimelineItemContent, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> TimelineItemContent {
        return TimelineItemContent(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: TimelineItemContent) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}


public func FfiConverterTypeTimelineItemContent_lift(_ pointer: UnsafeMutableRawPointer) throws -> TimelineItemContent {
    return try FfiConverterTypeTimelineItemContent.lift(pointer)
}

public func FfiConverterTypeTimelineItemContent_lower(_ value: TimelineItemContent) -> UnsafeMutableRawPointer {
    return FfiConverterTypeTimelineItemContent.lower(value)
}


public protocol UnreadNotificationsCountProtocol {
    func `hasNotifications`()   -> Bool
    func `highlightCount`()   -> UInt32
    func `notificationCount`()   -> UInt32
    
}

public class UnreadNotificationsCount: UnreadNotificationsCountProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { _uniffi_matrix_sdk_ffi_object_free_UnreadNotificationsCount_b323(pointer, $0) }
    }

    

    
    

    public func `hasNotifications`()  -> Bool {
        return try!  FfiConverterBool.lift(
            try! 
    rustCall() {
    
    _uniffi_matrix_sdk_ffi_impl_UnreadNotificationsCount_has_notifications_72(self.pointer, $0
    )
}
        )
    }

    public func `highlightCount`()  -> UInt32 {
        return try!  FfiConverterUInt32.lift(
            try! 
    rustCall() {
    
    _uniffi_matrix_sdk_ffi_impl_UnreadNotificationsCount_highlight_count_41b0(self.pointer, $0
    )
}
        )
    }

    public func `notificationCount`()  -> UInt32 {
        return try!  FfiConverterUInt32.lift(
            try! 
    rustCall() {
    
    _uniffi_matrix_sdk_ffi_impl_UnreadNotificationsCount_notification_count_1e7d(self.pointer, $0
    )
}
        )
    }
}



public struct FfiConverterTypeUnreadNotificationsCount: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = UnreadNotificationsCount

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UnreadNotificationsCount {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: UnreadNotificationsCount, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> UnreadNotificationsCount {
        return UnreadNotificationsCount(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: UnreadNotificationsCount) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}


public func FfiConverterTypeUnreadNotificationsCount_lift(_ pointer: UnsafeMutableRawPointer) throws -> UnreadNotificationsCount {
    return try FfiConverterTypeUnreadNotificationsCount.lift(pointer)
}

public func FfiConverterTypeUnreadNotificationsCount_lower(_ value: UnreadNotificationsCount) -> UnsafeMutableRawPointer {
    return FfiConverterTypeUnreadNotificationsCount.lower(value)
}


public struct AudioInfo {
    public var `duration`: UInt64?
    public var `size`: UInt64?
    public var `mimetype`: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`duration`: UInt64?, `size`: UInt64?, `mimetype`: String?) {
        self.`duration` = `duration`
        self.`size` = `size`
        self.`mimetype` = `mimetype`
    }
}


extension AudioInfo: Equatable, Hashable {
    public static func ==(lhs: AudioInfo, rhs: AudioInfo) -> Bool {
        if lhs.`duration` != rhs.`duration` {
            return false
        }
        if lhs.`size` != rhs.`size` {
            return false
        }
        if lhs.`mimetype` != rhs.`mimetype` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`duration`)
        hasher.combine(`size`)
        hasher.combine(`mimetype`)
    }
}


public struct FfiConverterTypeAudioInfo: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AudioInfo {
        return try AudioInfo(
            `duration`: FfiConverterOptionUInt64.read(from: &buf), 
            `size`: FfiConverterOptionUInt64.read(from: &buf), 
            `mimetype`: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: AudioInfo, into buf: inout [UInt8]) {
        FfiConverterOptionUInt64.write(value.`duration`, into: &buf)
        FfiConverterOptionUInt64.write(value.`size`, into: &buf)
        FfiConverterOptionString.write(value.`mimetype`, into: &buf)
    }
}


public func FfiConverterTypeAudioInfo_lift(_ buf: RustBuffer) throws -> AudioInfo {
    return try FfiConverterTypeAudioInfo.lift(buf)
}

public func FfiConverterTypeAudioInfo_lower(_ value: AudioInfo) -> RustBuffer {
    return FfiConverterTypeAudioInfo.lower(value)
}


public struct AudioMessageContent {
    public var `body`: String
    public var `source`: MediaSource
    public var `info`: AudioInfo?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`body`: String, `source`: MediaSource, `info`: AudioInfo?) {
        self.`body` = `body`
        self.`source` = `source`
        self.`info` = `info`
    }
}



public struct FfiConverterTypeAudioMessageContent: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AudioMessageContent {
        return try AudioMessageContent(
            `body`: FfiConverterString.read(from: &buf), 
            `source`: FfiConverterTypeMediaSource.read(from: &buf), 
            `info`: FfiConverterOptionTypeAudioInfo.read(from: &buf)
        )
    }

    public static func write(_ value: AudioMessageContent, into buf: inout [UInt8]) {
        FfiConverterString.write(value.`body`, into: &buf)
        FfiConverterTypeMediaSource.write(value.`source`, into: &buf)
        FfiConverterOptionTypeAudioInfo.write(value.`info`, into: &buf)
    }
}


public func FfiConverterTypeAudioMessageContent_lift(_ buf: RustBuffer) throws -> AudioMessageContent {
    return try FfiConverterTypeAudioMessageContent.lift(buf)
}

public func FfiConverterTypeAudioMessageContent_lower(_ value: AudioMessageContent) -> RustBuffer {
    return FfiConverterTypeAudioMessageContent.lower(value)
}


public struct CreateRoomParameters {
    public var `name`: String?
    public var `topic`: String?
    public var `isEncrypted`: Bool
    public var `isDirect`: Bool
    public var `visibility`: RoomVisibility
    public var `preset`: RoomPreset
    public var `invite`: [String]?
    public var `avatar`: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`name`: String?, `topic`: String? = nil, `isEncrypted`: Bool, `isDirect`: Bool = false, `visibility`: RoomVisibility, `preset`: RoomPreset, `invite`: [String]? = nil, `avatar`: String? = nil) {
        self.`name` = `name`
        self.`topic` = `topic`
        self.`isEncrypted` = `isEncrypted`
        self.`isDirect` = `isDirect`
        self.`visibility` = `visibility`
        self.`preset` = `preset`
        self.`invite` = `invite`
        self.`avatar` = `avatar`
    }
}


extension CreateRoomParameters: Equatable, Hashable {
    public static func ==(lhs: CreateRoomParameters, rhs: CreateRoomParameters) -> Bool {
        if lhs.`name` != rhs.`name` {
            return false
        }
        if lhs.`topic` != rhs.`topic` {
            return false
        }
        if lhs.`isEncrypted` != rhs.`isEncrypted` {
            return false
        }
        if lhs.`isDirect` != rhs.`isDirect` {
            return false
        }
        if lhs.`visibility` != rhs.`visibility` {
            return false
        }
        if lhs.`preset` != rhs.`preset` {
            return false
        }
        if lhs.`invite` != rhs.`invite` {
            return false
        }
        if lhs.`avatar` != rhs.`avatar` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`name`)
        hasher.combine(`topic`)
        hasher.combine(`isEncrypted`)
        hasher.combine(`isDirect`)
        hasher.combine(`visibility`)
        hasher.combine(`preset`)
        hasher.combine(`invite`)
        hasher.combine(`avatar`)
    }
}


public struct FfiConverterTypeCreateRoomParameters: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> CreateRoomParameters {
        return try CreateRoomParameters(
            `name`: FfiConverterOptionString.read(from: &buf), 
            `topic`: FfiConverterOptionString.read(from: &buf), 
            `isEncrypted`: FfiConverterBool.read(from: &buf), 
            `isDirect`: FfiConverterBool.read(from: &buf), 
            `visibility`: FfiConverterTypeRoomVisibility.read(from: &buf), 
            `preset`: FfiConverterTypeRoomPreset.read(from: &buf), 
            `invite`: FfiConverterOptionSequenceString.read(from: &buf), 
            `avatar`: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: CreateRoomParameters, into buf: inout [UInt8]) {
        FfiConverterOptionString.write(value.`name`, into: &buf)
        FfiConverterOptionString.write(value.`topic`, into: &buf)
        FfiConverterBool.write(value.`isEncrypted`, into: &buf)
        FfiConverterBool.write(value.`isDirect`, into: &buf)
        FfiConverterTypeRoomVisibility.write(value.`visibility`, into: &buf)
        FfiConverterTypeRoomPreset.write(value.`preset`, into: &buf)
        FfiConverterOptionSequenceString.write(value.`invite`, into: &buf)
        FfiConverterOptionString.write(value.`avatar`, into: &buf)
    }
}


public func FfiConverterTypeCreateRoomParameters_lift(_ buf: RustBuffer) throws -> CreateRoomParameters {
    return try FfiConverterTypeCreateRoomParameters.lift(buf)
}

public func FfiConverterTypeCreateRoomParameters_lower(_ value: CreateRoomParameters) -> RustBuffer {
    return FfiConverterTypeCreateRoomParameters.lower(value)
}


public struct EmoteMessageContent {
    public var `body`: String
    public var `formatted`: FormattedBody?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`body`: String, `formatted`: FormattedBody?) {
        self.`body` = `body`
        self.`formatted` = `formatted`
    }
}


extension EmoteMessageContent: Equatable, Hashable {
    public static func ==(lhs: EmoteMessageContent, rhs: EmoteMessageContent) -> Bool {
        if lhs.`body` != rhs.`body` {
            return false
        }
        if lhs.`formatted` != rhs.`formatted` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`body`)
        hasher.combine(`formatted`)
    }
}


public struct FfiConverterTypeEmoteMessageContent: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> EmoteMessageContent {
        return try EmoteMessageContent(
            `body`: FfiConverterString.read(from: &buf), 
            `formatted`: FfiConverterOptionTypeFormattedBody.read(from: &buf)
        )
    }

    public static func write(_ value: EmoteMessageContent, into buf: inout [UInt8]) {
        FfiConverterString.write(value.`body`, into: &buf)
        FfiConverterOptionTypeFormattedBody.write(value.`formatted`, into: &buf)
    }
}


public func FfiConverterTypeEmoteMessageContent_lift(_ buf: RustBuffer) throws -> EmoteMessageContent {
    return try FfiConverterTypeEmoteMessageContent.lift(buf)
}

public func FfiConverterTypeEmoteMessageContent_lower(_ value: EmoteMessageContent) -> RustBuffer {
    return FfiConverterTypeEmoteMessageContent.lower(value)
}


public struct EventTimelineItemDebugInfo {
    public var `model`: String
    public var `originalJson`: String?
    public var `latestEditJson`: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`model`: String, `originalJson`: String?, `latestEditJson`: String?) {
        self.`model` = `model`
        self.`originalJson` = `originalJson`
        self.`latestEditJson` = `latestEditJson`
    }
}


extension EventTimelineItemDebugInfo: Equatable, Hashable {
    public static func ==(lhs: EventTimelineItemDebugInfo, rhs: EventTimelineItemDebugInfo) -> Bool {
        if lhs.`model` != rhs.`model` {
            return false
        }
        if lhs.`originalJson` != rhs.`originalJson` {
            return false
        }
        if lhs.`latestEditJson` != rhs.`latestEditJson` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`model`)
        hasher.combine(`originalJson`)
        hasher.combine(`latestEditJson`)
    }
}


public struct FfiConverterTypeEventTimelineItemDebugInfo: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> EventTimelineItemDebugInfo {
        return try EventTimelineItemDebugInfo(
            `model`: FfiConverterString.read(from: &buf), 
            `originalJson`: FfiConverterOptionString.read(from: &buf), 
            `latestEditJson`: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: EventTimelineItemDebugInfo, into buf: inout [UInt8]) {
        FfiConverterString.write(value.`model`, into: &buf)
        FfiConverterOptionString.write(value.`originalJson`, into: &buf)
        FfiConverterOptionString.write(value.`latestEditJson`, into: &buf)
    }
}


public func FfiConverterTypeEventTimelineItemDebugInfo_lift(_ buf: RustBuffer) throws -> EventTimelineItemDebugInfo {
    return try FfiConverterTypeEventTimelineItemDebugInfo.lift(buf)
}

public func FfiConverterTypeEventTimelineItemDebugInfo_lower(_ value: EventTimelineItemDebugInfo) -> RustBuffer {
    return FfiConverterTypeEventTimelineItemDebugInfo.lower(value)
}


public struct FileInfo {
    public var `mimetype`: String?
    public var `size`: UInt64?
    public var `thumbnailInfo`: ThumbnailInfo?
    public var `thumbnailSource`: MediaSource?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`mimetype`: String?, `size`: UInt64?, `thumbnailInfo`: ThumbnailInfo?, `thumbnailSource`: MediaSource?) {
        self.`mimetype` = `mimetype`
        self.`size` = `size`
        self.`thumbnailInfo` = `thumbnailInfo`
        self.`thumbnailSource` = `thumbnailSource`
    }
}



public struct FfiConverterTypeFileInfo: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FileInfo {
        return try FileInfo(
            `mimetype`: FfiConverterOptionString.read(from: &buf), 
            `size`: FfiConverterOptionUInt64.read(from: &buf), 
            `thumbnailInfo`: FfiConverterOptionTypeThumbnailInfo.read(from: &buf), 
            `thumbnailSource`: FfiConverterOptionTypeMediaSource.read(from: &buf)
        )
    }

    public static func write(_ value: FileInfo, into buf: inout [UInt8]) {
        FfiConverterOptionString.write(value.`mimetype`, into: &buf)
        FfiConverterOptionUInt64.write(value.`size`, into: &buf)
        FfiConverterOptionTypeThumbnailInfo.write(value.`thumbnailInfo`, into: &buf)
        FfiConverterOptionTypeMediaSource.write(value.`thumbnailSource`, into: &buf)
    }
}


public func FfiConverterTypeFileInfo_lift(_ buf: RustBuffer) throws -> FileInfo {
    return try FfiConverterTypeFileInfo.lift(buf)
}

public func FfiConverterTypeFileInfo_lower(_ value: FileInfo) -> RustBuffer {
    return FfiConverterTypeFileInfo.lower(value)
}


public struct FileMessageContent {
    public var `body`: String
    public var `source`: MediaSource
    public var `info`: FileInfo?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`body`: String, `source`: MediaSource, `info`: FileInfo?) {
        self.`body` = `body`
        self.`source` = `source`
        self.`info` = `info`
    }
}



public struct FfiConverterTypeFileMessageContent: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FileMessageContent {
        return try FileMessageContent(
            `body`: FfiConverterString.read(from: &buf), 
            `source`: FfiConverterTypeMediaSource.read(from: &buf), 
            `info`: FfiConverterOptionTypeFileInfo.read(from: &buf)
        )
    }

    public static func write(_ value: FileMessageContent, into buf: inout [UInt8]) {
        FfiConverterString.write(value.`body`, into: &buf)
        FfiConverterTypeMediaSource.write(value.`source`, into: &buf)
        FfiConverterOptionTypeFileInfo.write(value.`info`, into: &buf)
    }
}


public func FfiConverterTypeFileMessageContent_lift(_ buf: RustBuffer) throws -> FileMessageContent {
    return try FfiConverterTypeFileMessageContent.lift(buf)
}

public func FfiConverterTypeFileMessageContent_lower(_ value: FileMessageContent) -> RustBuffer {
    return FfiConverterTypeFileMessageContent.lower(value)
}


public struct FormattedBody {
    public var `format`: MessageFormat
    public var `body`: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`format`: MessageFormat, `body`: String) {
        self.`format` = `format`
        self.`body` = `body`
    }
}


extension FormattedBody: Equatable, Hashable {
    public static func ==(lhs: FormattedBody, rhs: FormattedBody) -> Bool {
        if lhs.`format` != rhs.`format` {
            return false
        }
        if lhs.`body` != rhs.`body` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`format`)
        hasher.combine(`body`)
    }
}


public struct FfiConverterTypeFormattedBody: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FormattedBody {
        return try FormattedBody(
            `format`: FfiConverterTypeMessageFormat.read(from: &buf), 
            `body`: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: FormattedBody, into buf: inout [UInt8]) {
        FfiConverterTypeMessageFormat.write(value.`format`, into: &buf)
        FfiConverterString.write(value.`body`, into: &buf)
    }
}


public func FfiConverterTypeFormattedBody_lift(_ buf: RustBuffer) throws -> FormattedBody {
    return try FfiConverterTypeFormattedBody.lift(buf)
}

public func FfiConverterTypeFormattedBody_lower(_ value: FormattedBody) -> RustBuffer {
    return FfiConverterTypeFormattedBody.lower(value)
}


public struct HttpPusherData {
    public var `url`: String
    public var `format`: PushFormat?
    public var `defaultPayload`: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`url`: String, `format`: PushFormat?, `defaultPayload`: String?) {
        self.`url` = `url`
        self.`format` = `format`
        self.`defaultPayload` = `defaultPayload`
    }
}


extension HttpPusherData: Equatable, Hashable {
    public static func ==(lhs: HttpPusherData, rhs: HttpPusherData) -> Bool {
        if lhs.`url` != rhs.`url` {
            return false
        }
        if lhs.`format` != rhs.`format` {
            return false
        }
        if lhs.`defaultPayload` != rhs.`defaultPayload` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`url`)
        hasher.combine(`format`)
        hasher.combine(`defaultPayload`)
    }
}


public struct FfiConverterTypeHttpPusherData: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> HttpPusherData {
        return try HttpPusherData(
            `url`: FfiConverterString.read(from: &buf), 
            `format`: FfiConverterOptionTypePushFormat.read(from: &buf), 
            `defaultPayload`: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: HttpPusherData, into buf: inout [UInt8]) {
        FfiConverterString.write(value.`url`, into: &buf)
        FfiConverterOptionTypePushFormat.write(value.`format`, into: &buf)
        FfiConverterOptionString.write(value.`defaultPayload`, into: &buf)
    }
}


public func FfiConverterTypeHttpPusherData_lift(_ buf: RustBuffer) throws -> HttpPusherData {
    return try FfiConverterTypeHttpPusherData.lift(buf)
}

public func FfiConverterTypeHttpPusherData_lower(_ value: HttpPusherData) -> RustBuffer {
    return FfiConverterTypeHttpPusherData.lower(value)
}


public struct ImageInfo {
    public var `height`: UInt64?
    public var `width`: UInt64?
    public var `mimetype`: String?
    public var `size`: UInt64?
    public var `thumbnailInfo`: ThumbnailInfo?
    public var `thumbnailSource`: MediaSource?
    public var `blurhash`: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`height`: UInt64?, `width`: UInt64?, `mimetype`: String?, `size`: UInt64?, `thumbnailInfo`: ThumbnailInfo?, `thumbnailSource`: MediaSource?, `blurhash`: String?) {
        self.`height` = `height`
        self.`width` = `width`
        self.`mimetype` = `mimetype`
        self.`size` = `size`
        self.`thumbnailInfo` = `thumbnailInfo`
        self.`thumbnailSource` = `thumbnailSource`
        self.`blurhash` = `blurhash`
    }
}



public struct FfiConverterTypeImageInfo: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ImageInfo {
        return try ImageInfo(
            `height`: FfiConverterOptionUInt64.read(from: &buf), 
            `width`: FfiConverterOptionUInt64.read(from: &buf), 
            `mimetype`: FfiConverterOptionString.read(from: &buf), 
            `size`: FfiConverterOptionUInt64.read(from: &buf), 
            `thumbnailInfo`: FfiConverterOptionTypeThumbnailInfo.read(from: &buf), 
            `thumbnailSource`: FfiConverterOptionTypeMediaSource.read(from: &buf), 
            `blurhash`: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: ImageInfo, into buf: inout [UInt8]) {
        FfiConverterOptionUInt64.write(value.`height`, into: &buf)
        FfiConverterOptionUInt64.write(value.`width`, into: &buf)
        FfiConverterOptionString.write(value.`mimetype`, into: &buf)
        FfiConverterOptionUInt64.write(value.`size`, into: &buf)
        FfiConverterOptionTypeThumbnailInfo.write(value.`thumbnailInfo`, into: &buf)
        FfiConverterOptionTypeMediaSource.write(value.`thumbnailSource`, into: &buf)
        FfiConverterOptionString.write(value.`blurhash`, into: &buf)
    }
}


public func FfiConverterTypeImageInfo_lift(_ buf: RustBuffer) throws -> ImageInfo {
    return try FfiConverterTypeImageInfo.lift(buf)
}

public func FfiConverterTypeImageInfo_lower(_ value: ImageInfo) -> RustBuffer {
    return FfiConverterTypeImageInfo.lower(value)
}


public struct ImageMessageContent {
    public var `body`: String
    public var `source`: MediaSource
    public var `info`: ImageInfo?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`body`: String, `source`: MediaSource, `info`: ImageInfo?) {
        self.`body` = `body`
        self.`source` = `source`
        self.`info` = `info`
    }
}



public struct FfiConverterTypeImageMessageContent: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ImageMessageContent {
        return try ImageMessageContent(
            `body`: FfiConverterString.read(from: &buf), 
            `source`: FfiConverterTypeMediaSource.read(from: &buf), 
            `info`: FfiConverterOptionTypeImageInfo.read(from: &buf)
        )
    }

    public static func write(_ value: ImageMessageContent, into buf: inout [UInt8]) {
        FfiConverterString.write(value.`body`, into: &buf)
        FfiConverterTypeMediaSource.write(value.`source`, into: &buf)
        FfiConverterOptionTypeImageInfo.write(value.`info`, into: &buf)
    }
}


public func FfiConverterTypeImageMessageContent_lift(_ buf: RustBuffer) throws -> ImageMessageContent {
    return try FfiConverterTypeImageMessageContent.lift(buf)
}

public func FfiConverterTypeImageMessageContent_lower(_ value: ImageMessageContent) -> RustBuffer {
    return FfiConverterTypeImageMessageContent.lower(value)
}


public struct InReplyToDetails {
    public var `eventId`: String
    public var `event`: RepliedToEventDetails

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`eventId`: String, `event`: RepliedToEventDetails) {
        self.`eventId` = `eventId`
        self.`event` = `event`
    }
}



public struct FfiConverterTypeInReplyToDetails: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> InReplyToDetails {
        return try InReplyToDetails(
            `eventId`: FfiConverterString.read(from: &buf), 
            `event`: FfiConverterTypeRepliedToEventDetails.read(from: &buf)
        )
    }

    public static func write(_ value: InReplyToDetails, into buf: inout [UInt8]) {
        FfiConverterString.write(value.`eventId`, into: &buf)
        FfiConverterTypeRepliedToEventDetails.write(value.`event`, into: &buf)
    }
}


public func FfiConverterTypeInReplyToDetails_lift(_ buf: RustBuffer) throws -> InReplyToDetails {
    return try FfiConverterTypeInReplyToDetails.lift(buf)
}

public func FfiConverterTypeInReplyToDetails_lower(_ value: InReplyToDetails) -> RustBuffer {
    return FfiConverterTypeInReplyToDetails.lower(value)
}


public struct InsertData {
    public var `index`: UInt32
    public var `item`: TimelineItem

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`index`: UInt32, `item`: TimelineItem) {
        self.`index` = `index`
        self.`item` = `item`
    }
}



public struct FfiConverterTypeInsertData: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> InsertData {
        return try InsertData(
            `index`: FfiConverterUInt32.read(from: &buf), 
            `item`: FfiConverterTypeTimelineItem.read(from: &buf)
        )
    }

    public static func write(_ value: InsertData, into buf: inout [UInt8]) {
        FfiConverterUInt32.write(value.`index`, into: &buf)
        FfiConverterTypeTimelineItem.write(value.`item`, into: &buf)
    }
}


public func FfiConverterTypeInsertData_lift(_ buf: RustBuffer) throws -> InsertData {
    return try FfiConverterTypeInsertData.lift(buf)
}

public func FfiConverterTypeInsertData_lower(_ value: InsertData) -> RustBuffer {
    return FfiConverterTypeInsertData.lower(value)
}


public struct MoveData {
    public var `oldIndex`: UInt32
    public var `newIndex`: UInt32

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`oldIndex`: UInt32, `newIndex`: UInt32) {
        self.`oldIndex` = `oldIndex`
        self.`newIndex` = `newIndex`
    }
}


extension MoveData: Equatable, Hashable {
    public static func ==(lhs: MoveData, rhs: MoveData) -> Bool {
        if lhs.`oldIndex` != rhs.`oldIndex` {
            return false
        }
        if lhs.`newIndex` != rhs.`newIndex` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`oldIndex`)
        hasher.combine(`newIndex`)
    }
}


public struct FfiConverterTypeMoveData: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MoveData {
        return try MoveData(
            `oldIndex`: FfiConverterUInt32.read(from: &buf), 
            `newIndex`: FfiConverterUInt32.read(from: &buf)
        )
    }

    public static func write(_ value: MoveData, into buf: inout [UInt8]) {
        FfiConverterUInt32.write(value.`oldIndex`, into: &buf)
        FfiConverterUInt32.write(value.`newIndex`, into: &buf)
    }
}


public func FfiConverterTypeMoveData_lift(_ buf: RustBuffer) throws -> MoveData {
    return try FfiConverterTypeMoveData.lift(buf)
}

public func FfiConverterTypeMoveData_lower(_ value: MoveData) -> RustBuffer {
    return FfiConverterTypeMoveData.lower(value)
}


public struct NoticeMessageContent {
    public var `body`: String
    public var `formatted`: FormattedBody?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`body`: String, `formatted`: FormattedBody?) {
        self.`body` = `body`
        self.`formatted` = `formatted`
    }
}


extension NoticeMessageContent: Equatable, Hashable {
    public static func ==(lhs: NoticeMessageContent, rhs: NoticeMessageContent) -> Bool {
        if lhs.`body` != rhs.`body` {
            return false
        }
        if lhs.`formatted` != rhs.`formatted` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`body`)
        hasher.combine(`formatted`)
    }
}


public struct FfiConverterTypeNoticeMessageContent: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NoticeMessageContent {
        return try NoticeMessageContent(
            `body`: FfiConverterString.read(from: &buf), 
            `formatted`: FfiConverterOptionTypeFormattedBody.read(from: &buf)
        )
    }

    public static func write(_ value: NoticeMessageContent, into buf: inout [UInt8]) {
        FfiConverterString.write(value.`body`, into: &buf)
        FfiConverterOptionTypeFormattedBody.write(value.`formatted`, into: &buf)
    }
}


public func FfiConverterTypeNoticeMessageContent_lift(_ buf: RustBuffer) throws -> NoticeMessageContent {
    return try FfiConverterTypeNoticeMessageContent.lift(buf)
}

public func FfiConverterTypeNoticeMessageContent_lower(_ value: NoticeMessageContent) -> RustBuffer {
    return FfiConverterTypeNoticeMessageContent.lower(value)
}


public struct NotificationItem {
    public var `item`: TimelineItem
    public var `title`: String
    public var `subtitle`: String?
    public var `isNoisy`: Bool
    public var `avatarUrl`: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`item`: TimelineItem, `title`: String, `subtitle`: String?, `isNoisy`: Bool, `avatarUrl`: String?) {
        self.`item` = `item`
        self.`title` = `title`
        self.`subtitle` = `subtitle`
        self.`isNoisy` = `isNoisy`
        self.`avatarUrl` = `avatarUrl`
    }
}



public struct FfiConverterTypeNotificationItem: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NotificationItem {
        return try NotificationItem(
            `item`: FfiConverterTypeTimelineItem.read(from: &buf), 
            `title`: FfiConverterString.read(from: &buf), 
            `subtitle`: FfiConverterOptionString.read(from: &buf), 
            `isNoisy`: FfiConverterBool.read(from: &buf), 
            `avatarUrl`: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: NotificationItem, into buf: inout [UInt8]) {
        FfiConverterTypeTimelineItem.write(value.`item`, into: &buf)
        FfiConverterString.write(value.`title`, into: &buf)
        FfiConverterOptionString.write(value.`subtitle`, into: &buf)
        FfiConverterBool.write(value.`isNoisy`, into: &buf)
        FfiConverterOptionString.write(value.`avatarUrl`, into: &buf)
    }
}


public func FfiConverterTypeNotificationItem_lift(_ buf: RustBuffer) throws -> NotificationItem {
    return try FfiConverterTypeNotificationItem.lift(buf)
}

public func FfiConverterTypeNotificationItem_lower(_ value: NotificationItem) -> RustBuffer {
    return FfiConverterTypeNotificationItem.lower(value)
}


public struct PusherIdentifiers {
    public var `pushkey`: String
    public var `appId`: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`pushkey`: String, `appId`: String) {
        self.`pushkey` = `pushkey`
        self.`appId` = `appId`
    }
}


extension PusherIdentifiers: Equatable, Hashable {
    public static func ==(lhs: PusherIdentifiers, rhs: PusherIdentifiers) -> Bool {
        if lhs.`pushkey` != rhs.`pushkey` {
            return false
        }
        if lhs.`appId` != rhs.`appId` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`pushkey`)
        hasher.combine(`appId`)
    }
}


public struct FfiConverterTypePusherIdentifiers: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PusherIdentifiers {
        return try PusherIdentifiers(
            `pushkey`: FfiConverterString.read(from: &buf), 
            `appId`: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: PusherIdentifiers, into buf: inout [UInt8]) {
        FfiConverterString.write(value.`pushkey`, into: &buf)
        FfiConverterString.write(value.`appId`, into: &buf)
    }
}


public func FfiConverterTypePusherIdentifiers_lift(_ buf: RustBuffer) throws -> PusherIdentifiers {
    return try FfiConverterTypePusherIdentifiers.lift(buf)
}

public func FfiConverterTypePusherIdentifiers_lower(_ value: PusherIdentifiers) -> RustBuffer {
    return FfiConverterTypePusherIdentifiers.lower(value)
}


public struct Reaction {
    public var `key`: String
    public var `count`: UInt64

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`key`: String, `count`: UInt64) {
        self.`key` = `key`
        self.`count` = `count`
    }
}


extension Reaction: Equatable, Hashable {
    public static func ==(lhs: Reaction, rhs: Reaction) -> Bool {
        if lhs.`key` != rhs.`key` {
            return false
        }
        if lhs.`count` != rhs.`count` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`key`)
        hasher.combine(`count`)
    }
}


public struct FfiConverterTypeReaction: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Reaction {
        return try Reaction(
            `key`: FfiConverterString.read(from: &buf), 
            `count`: FfiConverterUInt64.read(from: &buf)
        )
    }

    public static func write(_ value: Reaction, into buf: inout [UInt8]) {
        FfiConverterString.write(value.`key`, into: &buf)
        FfiConverterUInt64.write(value.`count`, into: &buf)
    }
}


public func FfiConverterTypeReaction_lift(_ buf: RustBuffer) throws -> Reaction {
    return try FfiConverterTypeReaction.lift(buf)
}

public func FfiConverterTypeReaction_lower(_ value: Reaction) -> RustBuffer {
    return FfiConverterTypeReaction.lower(value)
}


public struct RequiredState {
    public var `key`: String
    public var `value`: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`key`: String, `value`: String) {
        self.`key` = `key`
        self.`value` = `value`
    }
}


extension RequiredState: Equatable, Hashable {
    public static func ==(lhs: RequiredState, rhs: RequiredState) -> Bool {
        if lhs.`key` != rhs.`key` {
            return false
        }
        if lhs.`value` != rhs.`value` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`key`)
        hasher.combine(`value`)
    }
}


public struct FfiConverterTypeRequiredState: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RequiredState {
        return try RequiredState(
            `key`: FfiConverterString.read(from: &buf), 
            `value`: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: RequiredState, into buf: inout [UInt8]) {
        FfiConverterString.write(value.`key`, into: &buf)
        FfiConverterString.write(value.`value`, into: &buf)
    }
}


public func FfiConverterTypeRequiredState_lift(_ buf: RustBuffer) throws -> RequiredState {
    return try FfiConverterTypeRequiredState.lift(buf)
}

public func FfiConverterTypeRequiredState_lower(_ value: RequiredState) -> RustBuffer {
    return FfiConverterTypeRequiredState.lower(value)
}


public struct RoomSubscription {
    public var `requiredState`: [RequiredState]?
    public var `timelineLimit`: UInt32?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`requiredState`: [RequiredState]?, `timelineLimit`: UInt32?) {
        self.`requiredState` = `requiredState`
        self.`timelineLimit` = `timelineLimit`
    }
}


extension RoomSubscription: Equatable, Hashable {
    public static func ==(lhs: RoomSubscription, rhs: RoomSubscription) -> Bool {
        if lhs.`requiredState` != rhs.`requiredState` {
            return false
        }
        if lhs.`timelineLimit` != rhs.`timelineLimit` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`requiredState`)
        hasher.combine(`timelineLimit`)
    }
}


public struct FfiConverterTypeRoomSubscription: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RoomSubscription {
        return try RoomSubscription(
            `requiredState`: FfiConverterOptionSequenceTypeRequiredState.read(from: &buf), 
            `timelineLimit`: FfiConverterOptionUInt32.read(from: &buf)
        )
    }

    public static func write(_ value: RoomSubscription, into buf: inout [UInt8]) {
        FfiConverterOptionSequenceTypeRequiredState.write(value.`requiredState`, into: &buf)
        FfiConverterOptionUInt32.write(value.`timelineLimit`, into: &buf)
    }
}


public func FfiConverterTypeRoomSubscription_lift(_ buf: RustBuffer) throws -> RoomSubscription {
    return try FfiConverterTypeRoomSubscription.lift(buf)
}

public func FfiConverterTypeRoomSubscription_lower(_ value: RoomSubscription) -> RustBuffer {
    return FfiConverterTypeRoomSubscription.lower(value)
}


public struct SearchUsersResults {
    public var `results`: [UserProfile]
    public var `limited`: Bool

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`results`: [UserProfile], `limited`: Bool) {
        self.`results` = `results`
        self.`limited` = `limited`
    }
}


extension SearchUsersResults: Equatable, Hashable {
    public static func ==(lhs: SearchUsersResults, rhs: SearchUsersResults) -> Bool {
        if lhs.`results` != rhs.`results` {
            return false
        }
        if lhs.`limited` != rhs.`limited` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`results`)
        hasher.combine(`limited`)
    }
}


public struct FfiConverterTypeSearchUsersResults: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SearchUsersResults {
        return try SearchUsersResults(
            `results`: FfiConverterSequenceTypeUserProfile.read(from: &buf), 
            `limited`: FfiConverterBool.read(from: &buf)
        )
    }

    public static func write(_ value: SearchUsersResults, into buf: inout [UInt8]) {
        FfiConverterSequenceTypeUserProfile.write(value.`results`, into: &buf)
        FfiConverterBool.write(value.`limited`, into: &buf)
    }
}


public func FfiConverterTypeSearchUsersResults_lift(_ buf: RustBuffer) throws -> SearchUsersResults {
    return try FfiConverterTypeSearchUsersResults.lift(buf)
}

public func FfiConverterTypeSearchUsersResults_lower(_ value: SearchUsersResults) -> RustBuffer {
    return FfiConverterTypeSearchUsersResults.lower(value)
}


public struct Session {
    public var `accessToken`: String
    public var `refreshToken`: String?
    public var `userId`: String
    public var `deviceId`: String
    public var `homeserverUrl`: String
    public var `slidingSyncProxy`: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`accessToken`: String, `refreshToken`: String?, `userId`: String, `deviceId`: String, `homeserverUrl`: String, `slidingSyncProxy`: String?) {
        self.`accessToken` = `accessToken`
        self.`refreshToken` = `refreshToken`
        self.`userId` = `userId`
        self.`deviceId` = `deviceId`
        self.`homeserverUrl` = `homeserverUrl`
        self.`slidingSyncProxy` = `slidingSyncProxy`
    }
}


extension Session: Equatable, Hashable {
    public static func ==(lhs: Session, rhs: Session) -> Bool {
        if lhs.`accessToken` != rhs.`accessToken` {
            return false
        }
        if lhs.`refreshToken` != rhs.`refreshToken` {
            return false
        }
        if lhs.`userId` != rhs.`userId` {
            return false
        }
        if lhs.`deviceId` != rhs.`deviceId` {
            return false
        }
        if lhs.`homeserverUrl` != rhs.`homeserverUrl` {
            return false
        }
        if lhs.`slidingSyncProxy` != rhs.`slidingSyncProxy` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`accessToken`)
        hasher.combine(`refreshToken`)
        hasher.combine(`userId`)
        hasher.combine(`deviceId`)
        hasher.combine(`homeserverUrl`)
        hasher.combine(`slidingSyncProxy`)
    }
}


public struct FfiConverterTypeSession: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Session {
        return try Session(
            `accessToken`: FfiConverterString.read(from: &buf), 
            `refreshToken`: FfiConverterOptionString.read(from: &buf), 
            `userId`: FfiConverterString.read(from: &buf), 
            `deviceId`: FfiConverterString.read(from: &buf), 
            `homeserverUrl`: FfiConverterString.read(from: &buf), 
            `slidingSyncProxy`: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: Session, into buf: inout [UInt8]) {
        FfiConverterString.write(value.`accessToken`, into: &buf)
        FfiConverterOptionString.write(value.`refreshToken`, into: &buf)
        FfiConverterString.write(value.`userId`, into: &buf)
        FfiConverterString.write(value.`deviceId`, into: &buf)
        FfiConverterString.write(value.`homeserverUrl`, into: &buf)
        FfiConverterOptionString.write(value.`slidingSyncProxy`, into: &buf)
    }
}


public func FfiConverterTypeSession_lift(_ buf: RustBuffer) throws -> Session {
    return try FfiConverterTypeSession.lift(buf)
}

public func FfiConverterTypeSession_lower(_ value: Session) -> RustBuffer {
    return FfiConverterTypeSession.lower(value)
}


public struct SetData {
    public var `index`: UInt32
    public var `item`: TimelineItem

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`index`: UInt32, `item`: TimelineItem) {
        self.`index` = `index`
        self.`item` = `item`
    }
}



public struct FfiConverterTypeSetData: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SetData {
        return try SetData(
            `index`: FfiConverterUInt32.read(from: &buf), 
            `item`: FfiConverterTypeTimelineItem.read(from: &buf)
        )
    }

    public static func write(_ value: SetData, into buf: inout [UInt8]) {
        FfiConverterUInt32.write(value.`index`, into: &buf)
        FfiConverterTypeTimelineItem.write(value.`item`, into: &buf)
    }
}


public func FfiConverterTypeSetData_lift(_ buf: RustBuffer) throws -> SetData {
    return try FfiConverterTypeSetData.lift(buf)
}

public func FfiConverterTypeSetData_lower(_ value: SetData) -> RustBuffer {
    return FfiConverterTypeSetData.lower(value)
}


public struct SlidingSyncRequestListFilters {
    public var `isDm`: Bool?
    public var `spaces`: [String]
    public var `isEncrypted`: Bool?
    public var `isInvite`: Bool?
    public var `isTombstoned`: Bool?
    public var `roomTypes`: [String]
    public var `notRoomTypes`: [String]
    public var `roomNameLike`: String?
    public var `tags`: [String]
    public var `notTags`: [String]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`isDm`: Bool?, `spaces`: [String], `isEncrypted`: Bool?, `isInvite`: Bool?, `isTombstoned`: Bool?, `roomTypes`: [String], `notRoomTypes`: [String], `roomNameLike`: String?, `tags`: [String], `notTags`: [String]) {
        self.`isDm` = `isDm`
        self.`spaces` = `spaces`
        self.`isEncrypted` = `isEncrypted`
        self.`isInvite` = `isInvite`
        self.`isTombstoned` = `isTombstoned`
        self.`roomTypes` = `roomTypes`
        self.`notRoomTypes` = `notRoomTypes`
        self.`roomNameLike` = `roomNameLike`
        self.`tags` = `tags`
        self.`notTags` = `notTags`
    }
}


extension SlidingSyncRequestListFilters: Equatable, Hashable {
    public static func ==(lhs: SlidingSyncRequestListFilters, rhs: SlidingSyncRequestListFilters) -> Bool {
        if lhs.`isDm` != rhs.`isDm` {
            return false
        }
        if lhs.`spaces` != rhs.`spaces` {
            return false
        }
        if lhs.`isEncrypted` != rhs.`isEncrypted` {
            return false
        }
        if lhs.`isInvite` != rhs.`isInvite` {
            return false
        }
        if lhs.`isTombstoned` != rhs.`isTombstoned` {
            return false
        }
        if lhs.`roomTypes` != rhs.`roomTypes` {
            return false
        }
        if lhs.`notRoomTypes` != rhs.`notRoomTypes` {
            return false
        }
        if lhs.`roomNameLike` != rhs.`roomNameLike` {
            return false
        }
        if lhs.`tags` != rhs.`tags` {
            return false
        }
        if lhs.`notTags` != rhs.`notTags` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`isDm`)
        hasher.combine(`spaces`)
        hasher.combine(`isEncrypted`)
        hasher.combine(`isInvite`)
        hasher.combine(`isTombstoned`)
        hasher.combine(`roomTypes`)
        hasher.combine(`notRoomTypes`)
        hasher.combine(`roomNameLike`)
        hasher.combine(`tags`)
        hasher.combine(`notTags`)
    }
}


public struct FfiConverterTypeSlidingSyncRequestListFilters: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SlidingSyncRequestListFilters {
        return try SlidingSyncRequestListFilters(
            `isDm`: FfiConverterOptionBool.read(from: &buf), 
            `spaces`: FfiConverterSequenceString.read(from: &buf), 
            `isEncrypted`: FfiConverterOptionBool.read(from: &buf), 
            `isInvite`: FfiConverterOptionBool.read(from: &buf), 
            `isTombstoned`: FfiConverterOptionBool.read(from: &buf), 
            `roomTypes`: FfiConverterSequenceString.read(from: &buf), 
            `notRoomTypes`: FfiConverterSequenceString.read(from: &buf), 
            `roomNameLike`: FfiConverterOptionString.read(from: &buf), 
            `tags`: FfiConverterSequenceString.read(from: &buf), 
            `notTags`: FfiConverterSequenceString.read(from: &buf)
        )
    }

    public static func write(_ value: SlidingSyncRequestListFilters, into buf: inout [UInt8]) {
        FfiConverterOptionBool.write(value.`isDm`, into: &buf)
        FfiConverterSequenceString.write(value.`spaces`, into: &buf)
        FfiConverterOptionBool.write(value.`isEncrypted`, into: &buf)
        FfiConverterOptionBool.write(value.`isInvite`, into: &buf)
        FfiConverterOptionBool.write(value.`isTombstoned`, into: &buf)
        FfiConverterSequenceString.write(value.`roomTypes`, into: &buf)
        FfiConverterSequenceString.write(value.`notRoomTypes`, into: &buf)
        FfiConverterOptionString.write(value.`roomNameLike`, into: &buf)
        FfiConverterSequenceString.write(value.`tags`, into: &buf)
        FfiConverterSequenceString.write(value.`notTags`, into: &buf)
    }
}


public func FfiConverterTypeSlidingSyncRequestListFilters_lift(_ buf: RustBuffer) throws -> SlidingSyncRequestListFilters {
    return try FfiConverterTypeSlidingSyncRequestListFilters.lift(buf)
}

public func FfiConverterTypeSlidingSyncRequestListFilters_lower(_ value: SlidingSyncRequestListFilters) -> RustBuffer {
    return FfiConverterTypeSlidingSyncRequestListFilters.lower(value)
}


public struct SlidingSyncSubscribeResult {
    public var `items`: [TimelineItem]
    public var `taskHandle`: TaskHandle

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`items`: [TimelineItem], `taskHandle`: TaskHandle) {
        self.`items` = `items`
        self.`taskHandle` = `taskHandle`
    }
}



public struct FfiConverterTypeSlidingSyncSubscribeResult: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SlidingSyncSubscribeResult {
        return try SlidingSyncSubscribeResult(
            `items`: FfiConverterSequenceTypeTimelineItem.read(from: &buf), 
            `taskHandle`: FfiConverterTypeTaskHandle.read(from: &buf)
        )
    }

    public static func write(_ value: SlidingSyncSubscribeResult, into buf: inout [UInt8]) {
        FfiConverterSequenceTypeTimelineItem.write(value.`items`, into: &buf)
        FfiConverterTypeTaskHandle.write(value.`taskHandle`, into: &buf)
    }
}


public func FfiConverterTypeSlidingSyncSubscribeResult_lift(_ buf: RustBuffer) throws -> SlidingSyncSubscribeResult {
    return try FfiConverterTypeSlidingSyncSubscribeResult.lift(buf)
}

public func FfiConverterTypeSlidingSyncSubscribeResult_lower(_ value: SlidingSyncSubscribeResult) -> RustBuffer {
    return FfiConverterTypeSlidingSyncSubscribeResult.lower(value)
}


public struct TextMessageContent {
    public var `body`: String
    public var `formatted`: FormattedBody?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`body`: String, `formatted`: FormattedBody?) {
        self.`body` = `body`
        self.`formatted` = `formatted`
    }
}


extension TextMessageContent: Equatable, Hashable {
    public static func ==(lhs: TextMessageContent, rhs: TextMessageContent) -> Bool {
        if lhs.`body` != rhs.`body` {
            return false
        }
        if lhs.`formatted` != rhs.`formatted` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`body`)
        hasher.combine(`formatted`)
    }
}


public struct FfiConverterTypeTextMessageContent: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TextMessageContent {
        return try TextMessageContent(
            `body`: FfiConverterString.read(from: &buf), 
            `formatted`: FfiConverterOptionTypeFormattedBody.read(from: &buf)
        )
    }

    public static func write(_ value: TextMessageContent, into buf: inout [UInt8]) {
        FfiConverterString.write(value.`body`, into: &buf)
        FfiConverterOptionTypeFormattedBody.write(value.`formatted`, into: &buf)
    }
}


public func FfiConverterTypeTextMessageContent_lift(_ buf: RustBuffer) throws -> TextMessageContent {
    return try FfiConverterTypeTextMessageContent.lift(buf)
}

public func FfiConverterTypeTextMessageContent_lower(_ value: TextMessageContent) -> RustBuffer {
    return FfiConverterTypeTextMessageContent.lower(value)
}


public struct ThumbnailInfo {
    public var `height`: UInt64?
    public var `width`: UInt64?
    public var `mimetype`: String?
    public var `size`: UInt64?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`height`: UInt64?, `width`: UInt64?, `mimetype`: String?, `size`: UInt64?) {
        self.`height` = `height`
        self.`width` = `width`
        self.`mimetype` = `mimetype`
        self.`size` = `size`
    }
}


extension ThumbnailInfo: Equatable, Hashable {
    public static func ==(lhs: ThumbnailInfo, rhs: ThumbnailInfo) -> Bool {
        if lhs.`height` != rhs.`height` {
            return false
        }
        if lhs.`width` != rhs.`width` {
            return false
        }
        if lhs.`mimetype` != rhs.`mimetype` {
            return false
        }
        if lhs.`size` != rhs.`size` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`height`)
        hasher.combine(`width`)
        hasher.combine(`mimetype`)
        hasher.combine(`size`)
    }
}


public struct FfiConverterTypeThumbnailInfo: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ThumbnailInfo {
        return try ThumbnailInfo(
            `height`: FfiConverterOptionUInt64.read(from: &buf), 
            `width`: FfiConverterOptionUInt64.read(from: &buf), 
            `mimetype`: FfiConverterOptionString.read(from: &buf), 
            `size`: FfiConverterOptionUInt64.read(from: &buf)
        )
    }

    public static func write(_ value: ThumbnailInfo, into buf: inout [UInt8]) {
        FfiConverterOptionUInt64.write(value.`height`, into: &buf)
        FfiConverterOptionUInt64.write(value.`width`, into: &buf)
        FfiConverterOptionString.write(value.`mimetype`, into: &buf)
        FfiConverterOptionUInt64.write(value.`size`, into: &buf)
    }
}


public func FfiConverterTypeThumbnailInfo_lift(_ buf: RustBuffer) throws -> ThumbnailInfo {
    return try FfiConverterTypeThumbnailInfo.lift(buf)
}

public func FfiConverterTypeThumbnailInfo_lower(_ value: ThumbnailInfo) -> RustBuffer {
    return FfiConverterTypeThumbnailInfo.lower(value)
}


public struct UpdateSummary {
    public var `lists`: [String]
    public var `rooms`: [String]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`lists`: [String], `rooms`: [String]) {
        self.`lists` = `lists`
        self.`rooms` = `rooms`
    }
}


extension UpdateSummary: Equatable, Hashable {
    public static func ==(lhs: UpdateSummary, rhs: UpdateSummary) -> Bool {
        if lhs.`lists` != rhs.`lists` {
            return false
        }
        if lhs.`rooms` != rhs.`rooms` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`lists`)
        hasher.combine(`rooms`)
    }
}


public struct FfiConverterTypeUpdateSummary: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UpdateSummary {
        return try UpdateSummary(
            `lists`: FfiConverterSequenceString.read(from: &buf), 
            `rooms`: FfiConverterSequenceString.read(from: &buf)
        )
    }

    public static func write(_ value: UpdateSummary, into buf: inout [UInt8]) {
        FfiConverterSequenceString.write(value.`lists`, into: &buf)
        FfiConverterSequenceString.write(value.`rooms`, into: &buf)
    }
}


public func FfiConverterTypeUpdateSummary_lift(_ buf: RustBuffer) throws -> UpdateSummary {
    return try FfiConverterTypeUpdateSummary.lift(buf)
}

public func FfiConverterTypeUpdateSummary_lower(_ value: UpdateSummary) -> RustBuffer {
    return FfiConverterTypeUpdateSummary.lower(value)
}


public struct UserProfile {
    public var `userId`: String
    public var `displayName`: String?
    public var `avatarUrl`: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`userId`: String, `displayName`: String?, `avatarUrl`: String?) {
        self.`userId` = `userId`
        self.`displayName` = `displayName`
        self.`avatarUrl` = `avatarUrl`
    }
}


extension UserProfile: Equatable, Hashable {
    public static func ==(lhs: UserProfile, rhs: UserProfile) -> Bool {
        if lhs.`userId` != rhs.`userId` {
            return false
        }
        if lhs.`displayName` != rhs.`displayName` {
            return false
        }
        if lhs.`avatarUrl` != rhs.`avatarUrl` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`userId`)
        hasher.combine(`displayName`)
        hasher.combine(`avatarUrl`)
    }
}


public struct FfiConverterTypeUserProfile: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UserProfile {
        return try UserProfile(
            `userId`: FfiConverterString.read(from: &buf), 
            `displayName`: FfiConverterOptionString.read(from: &buf), 
            `avatarUrl`: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: UserProfile, into buf: inout [UInt8]) {
        FfiConverterString.write(value.`userId`, into: &buf)
        FfiConverterOptionString.write(value.`displayName`, into: &buf)
        FfiConverterOptionString.write(value.`avatarUrl`, into: &buf)
    }
}


public func FfiConverterTypeUserProfile_lift(_ buf: RustBuffer) throws -> UserProfile {
    return try FfiConverterTypeUserProfile.lift(buf)
}

public func FfiConverterTypeUserProfile_lower(_ value: UserProfile) -> RustBuffer {
    return FfiConverterTypeUserProfile.lower(value)
}


public struct VideoInfo {
    public var `duration`: UInt64?
    public var `height`: UInt64?
    public var `width`: UInt64?
    public var `mimetype`: String?
    public var `size`: UInt64?
    public var `thumbnailInfo`: ThumbnailInfo?
    public var `thumbnailSource`: MediaSource?
    public var `blurhash`: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`duration`: UInt64?, `height`: UInt64?, `width`: UInt64?, `mimetype`: String?, `size`: UInt64?, `thumbnailInfo`: ThumbnailInfo?, `thumbnailSource`: MediaSource?, `blurhash`: String?) {
        self.`duration` = `duration`
        self.`height` = `height`
        self.`width` = `width`
        self.`mimetype` = `mimetype`
        self.`size` = `size`
        self.`thumbnailInfo` = `thumbnailInfo`
        self.`thumbnailSource` = `thumbnailSource`
        self.`blurhash` = `blurhash`
    }
}



public struct FfiConverterTypeVideoInfo: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> VideoInfo {
        return try VideoInfo(
            `duration`: FfiConverterOptionUInt64.read(from: &buf), 
            `height`: FfiConverterOptionUInt64.read(from: &buf), 
            `width`: FfiConverterOptionUInt64.read(from: &buf), 
            `mimetype`: FfiConverterOptionString.read(from: &buf), 
            `size`: FfiConverterOptionUInt64.read(from: &buf), 
            `thumbnailInfo`: FfiConverterOptionTypeThumbnailInfo.read(from: &buf), 
            `thumbnailSource`: FfiConverterOptionTypeMediaSource.read(from: &buf), 
            `blurhash`: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: VideoInfo, into buf: inout [UInt8]) {
        FfiConverterOptionUInt64.write(value.`duration`, into: &buf)
        FfiConverterOptionUInt64.write(value.`height`, into: &buf)
        FfiConverterOptionUInt64.write(value.`width`, into: &buf)
        FfiConverterOptionString.write(value.`mimetype`, into: &buf)
        FfiConverterOptionUInt64.write(value.`size`, into: &buf)
        FfiConverterOptionTypeThumbnailInfo.write(value.`thumbnailInfo`, into: &buf)
        FfiConverterOptionTypeMediaSource.write(value.`thumbnailSource`, into: &buf)
        FfiConverterOptionString.write(value.`blurhash`, into: &buf)
    }
}


public func FfiConverterTypeVideoInfo_lift(_ buf: RustBuffer) throws -> VideoInfo {
    return try FfiConverterTypeVideoInfo.lift(buf)
}

public func FfiConverterTypeVideoInfo_lower(_ value: VideoInfo) -> RustBuffer {
    return FfiConverterTypeVideoInfo.lower(value)
}


public struct VideoMessageContent {
    public var `body`: String
    public var `source`: MediaSource
    public var `info`: VideoInfo?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`body`: String, `source`: MediaSource, `info`: VideoInfo?) {
        self.`body` = `body`
        self.`source` = `source`
        self.`info` = `info`
    }
}



public struct FfiConverterTypeVideoMessageContent: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> VideoMessageContent {
        return try VideoMessageContent(
            `body`: FfiConverterString.read(from: &buf), 
            `source`: FfiConverterTypeMediaSource.read(from: &buf), 
            `info`: FfiConverterOptionTypeVideoInfo.read(from: &buf)
        )
    }

    public static func write(_ value: VideoMessageContent, into buf: inout [UInt8]) {
        FfiConverterString.write(value.`body`, into: &buf)
        FfiConverterTypeMediaSource.write(value.`source`, into: &buf)
        FfiConverterOptionTypeVideoInfo.write(value.`info`, into: &buf)
    }
}


public func FfiConverterTypeVideoMessageContent_lift(_ buf: RustBuffer) throws -> VideoMessageContent {
    return try FfiConverterTypeVideoMessageContent.lift(buf)
}

public func FfiConverterTypeVideoMessageContent_lower(_ value: VideoMessageContent) -> RustBuffer {
    return FfiConverterTypeVideoMessageContent.lower(value)
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum EncryptedMessage {
    
    case `olmV1Curve25519AesSha2`(`senderKey`: String)
    case `megolmV1AesSha2`(`sessionId`: String)
    case `unknown`
}

public struct FfiConverterTypeEncryptedMessage: FfiConverterRustBuffer {
    typealias SwiftType = EncryptedMessage

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> EncryptedMessage {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .`olmV1Curve25519AesSha2`(
            `senderKey`: try FfiConverterString.read(from: &buf)
        )
        
        case 2: return .`megolmV1AesSha2`(
            `sessionId`: try FfiConverterString.read(from: &buf)
        )
        
        case 3: return .`unknown`
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: EncryptedMessage, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .`olmV1Curve25519AesSha2`(`senderKey`):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(`senderKey`, into: &buf)
            
        
        case let .`megolmV1AesSha2`(`sessionId`):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(`sessionId`, into: &buf)
            
        
        case .`unknown`:
            writeInt(&buf, Int32(3))
        
        }
    }
}


public func FfiConverterTypeEncryptedMessage_lift(_ buf: RustBuffer) throws -> EncryptedMessage {
    return try FfiConverterTypeEncryptedMessage.lift(buf)
}

public func FfiConverterTypeEncryptedMessage_lower(_ value: EncryptedMessage) -> RustBuffer {
    return FfiConverterTypeEncryptedMessage.lower(value)
}


extension EncryptedMessage: Equatable, Hashable {}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum EventSendState {
    
    case `notSendYet`
    case `sendingFailed`(`error`: String)
    case `sent`(`eventId`: String)
}

public struct FfiConverterTypeEventSendState: FfiConverterRustBuffer {
    typealias SwiftType = EventSendState

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> EventSendState {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .`notSendYet`
        
        case 2: return .`sendingFailed`(
            `error`: try FfiConverterString.read(from: &buf)
        )
        
        case 3: return .`sent`(
            `eventId`: try FfiConverterString.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: EventSendState, into buf: inout [UInt8]) {
        switch value {
        
        
        case .`notSendYet`:
            writeInt(&buf, Int32(1))
        
        
        case let .`sendingFailed`(`error`):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(`error`, into: &buf)
            
        
        case let .`sent`(`eventId`):
            writeInt(&buf, Int32(3))
            FfiConverterString.write(`eventId`, into: &buf)
            
        }
    }
}


public func FfiConverterTypeEventSendState_lift(_ buf: RustBuffer) throws -> EventSendState {
    return try FfiConverterTypeEventSendState.lift(buf)
}

public func FfiConverterTypeEventSendState_lower(_ value: EventSendState) -> RustBuffer {
    return FfiConverterTypeEventSendState.lower(value)
}


extension EventSendState: Equatable, Hashable {}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum Membership {
    
    case `invited`
    case `joined`
    case `left`
}

public struct FfiConverterTypeMembership: FfiConverterRustBuffer {
    typealias SwiftType = Membership

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Membership {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .`invited`
        
        case 2: return .`joined`
        
        case 3: return .`left`
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: Membership, into buf: inout [UInt8]) {
        switch value {
        
        
        case .`invited`:
            writeInt(&buf, Int32(1))
        
        
        case .`joined`:
            writeInt(&buf, Int32(2))
        
        
        case .`left`:
            writeInt(&buf, Int32(3))
        
        }
    }
}


public func FfiConverterTypeMembership_lift(_ buf: RustBuffer) throws -> Membership {
    return try FfiConverterTypeMembership.lift(buf)
}

public func FfiConverterTypeMembership_lower(_ value: Membership) -> RustBuffer {
    return FfiConverterTypeMembership.lower(value)
}


extension Membership: Equatable, Hashable {}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum MembershipChange {
    
    case `none`
    case `error`
    case `joined`
    case `left`
    case `banned`
    case `unbanned`
    case `kicked`
    case `invited`
    case `kickedAndBanned`
    case `invitationAccepted`
    case `invitationRejected`
    case `invitationRevoked`
    case `knocked`
    case `knockAccepted`
    case `knockRetracted`
    case `knockDenied`
    case `notImplemented`
}

public struct FfiConverterTypeMembershipChange: FfiConverterRustBuffer {
    typealias SwiftType = MembershipChange

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MembershipChange {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .`none`
        
        case 2: return .`error`
        
        case 3: return .`joined`
        
        case 4: return .`left`
        
        case 5: return .`banned`
        
        case 6: return .`unbanned`
        
        case 7: return .`kicked`
        
        case 8: return .`invited`
        
        case 9: return .`kickedAndBanned`
        
        case 10: return .`invitationAccepted`
        
        case 11: return .`invitationRejected`
        
        case 12: return .`invitationRevoked`
        
        case 13: return .`knocked`
        
        case 14: return .`knockAccepted`
        
        case 15: return .`knockRetracted`
        
        case 16: return .`knockDenied`
        
        case 17: return .`notImplemented`
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: MembershipChange, into buf: inout [UInt8]) {
        switch value {
        
        
        case .`none`:
            writeInt(&buf, Int32(1))
        
        
        case .`error`:
            writeInt(&buf, Int32(2))
        
        
        case .`joined`:
            writeInt(&buf, Int32(3))
        
        
        case .`left`:
            writeInt(&buf, Int32(4))
        
        
        case .`banned`:
            writeInt(&buf, Int32(5))
        
        
        case .`unbanned`:
            writeInt(&buf, Int32(6))
        
        
        case .`kicked`:
            writeInt(&buf, Int32(7))
        
        
        case .`invited`:
            writeInt(&buf, Int32(8))
        
        
        case .`kickedAndBanned`:
            writeInt(&buf, Int32(9))
        
        
        case .`invitationAccepted`:
            writeInt(&buf, Int32(10))
        
        
        case .`invitationRejected`:
            writeInt(&buf, Int32(11))
        
        
        case .`invitationRevoked`:
            writeInt(&buf, Int32(12))
        
        
        case .`knocked`:
            writeInt(&buf, Int32(13))
        
        
        case .`knockAccepted`:
            writeInt(&buf, Int32(14))
        
        
        case .`knockRetracted`:
            writeInt(&buf, Int32(15))
        
        
        case .`knockDenied`:
            writeInt(&buf, Int32(16))
        
        
        case .`notImplemented`:
            writeInt(&buf, Int32(17))
        
        }
    }
}


public func FfiConverterTypeMembershipChange_lift(_ buf: RustBuffer) throws -> MembershipChange {
    return try FfiConverterTypeMembershipChange.lift(buf)
}

public func FfiConverterTypeMembershipChange_lower(_ value: MembershipChange) -> RustBuffer {
    return FfiConverterTypeMembershipChange.lower(value)
}


extension MembershipChange: Equatable, Hashable {}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum MembershipState {
    
    case `ban`
    case `invite`
    case `join`
    case `knock`
    case `leave`
}

public struct FfiConverterTypeMembershipState: FfiConverterRustBuffer {
    typealias SwiftType = MembershipState

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MembershipState {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .`ban`
        
        case 2: return .`invite`
        
        case 3: return .`join`
        
        case 4: return .`knock`
        
        case 5: return .`leave`
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: MembershipState, into buf: inout [UInt8]) {
        switch value {
        
        
        case .`ban`:
            writeInt(&buf, Int32(1))
        
        
        case .`invite`:
            writeInt(&buf, Int32(2))
        
        
        case .`join`:
            writeInt(&buf, Int32(3))
        
        
        case .`knock`:
            writeInt(&buf, Int32(4))
        
        
        case .`leave`:
            writeInt(&buf, Int32(5))
        
        }
    }
}


public func FfiConverterTypeMembershipState_lift(_ buf: RustBuffer) throws -> MembershipState {
    return try FfiConverterTypeMembershipState.lift(buf)
}

public func FfiConverterTypeMembershipState_lower(_ value: MembershipState) -> RustBuffer {
    return FfiConverterTypeMembershipState.lower(value)
}


extension MembershipState: Equatable, Hashable {}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum MessageFormat {
    
    case `html`
    case `unknown`
}

public struct FfiConverterTypeMessageFormat: FfiConverterRustBuffer {
    typealias SwiftType = MessageFormat

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MessageFormat {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .`html`
        
        case 2: return .`unknown`
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: MessageFormat, into buf: inout [UInt8]) {
        switch value {
        
        
        case .`html`:
            writeInt(&buf, Int32(1))
        
        
        case .`unknown`:
            writeInt(&buf, Int32(2))
        
        }
    }
}


public func FfiConverterTypeMessageFormat_lift(_ buf: RustBuffer) throws -> MessageFormat {
    return try FfiConverterTypeMessageFormat.lift(buf)
}

public func FfiConverterTypeMessageFormat_lower(_ value: MessageFormat) -> RustBuffer {
    return FfiConverterTypeMessageFormat.lower(value)
}


extension MessageFormat: Equatable, Hashable {}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum MessageType {
    
    case `emote`(`content`: EmoteMessageContent)
    case `image`(`content`: ImageMessageContent)
    case `audio`(`content`: AudioMessageContent)
    case `video`(`content`: VideoMessageContent)
    case `file`(`content`: FileMessageContent)
    case `notice`(`content`: NoticeMessageContent)
    case `text`(`content`: TextMessageContent)
}

public struct FfiConverterTypeMessageType: FfiConverterRustBuffer {
    typealias SwiftType = MessageType

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MessageType {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .`emote`(
            `content`: try FfiConverterTypeEmoteMessageContent.read(from: &buf)
        )
        
        case 2: return .`image`(
            `content`: try FfiConverterTypeImageMessageContent.read(from: &buf)
        )
        
        case 3: return .`audio`(
            `content`: try FfiConverterTypeAudioMessageContent.read(from: &buf)
        )
        
        case 4: return .`video`(
            `content`: try FfiConverterTypeVideoMessageContent.read(from: &buf)
        )
        
        case 5: return .`file`(
            `content`: try FfiConverterTypeFileMessageContent.read(from: &buf)
        )
        
        case 6: return .`notice`(
            `content`: try FfiConverterTypeNoticeMessageContent.read(from: &buf)
        )
        
        case 7: return .`text`(
            `content`: try FfiConverterTypeTextMessageContent.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: MessageType, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .`emote`(`content`):
            writeInt(&buf, Int32(1))
            FfiConverterTypeEmoteMessageContent.write(`content`, into: &buf)
            
        
        case let .`image`(`content`):
            writeInt(&buf, Int32(2))
            FfiConverterTypeImageMessageContent.write(`content`, into: &buf)
            
        
        case let .`audio`(`content`):
            writeInt(&buf, Int32(3))
            FfiConverterTypeAudioMessageContent.write(`content`, into: &buf)
            
        
        case let .`video`(`content`):
            writeInt(&buf, Int32(4))
            FfiConverterTypeVideoMessageContent.write(`content`, into: &buf)
            
        
        case let .`file`(`content`):
            writeInt(&buf, Int32(5))
            FfiConverterTypeFileMessageContent.write(`content`, into: &buf)
            
        
        case let .`notice`(`content`):
            writeInt(&buf, Int32(6))
            FfiConverterTypeNoticeMessageContent.write(`content`, into: &buf)
            
        
        case let .`text`(`content`):
            writeInt(&buf, Int32(7))
            FfiConverterTypeTextMessageContent.write(`content`, into: &buf)
            
        }
    }
}


public func FfiConverterTypeMessageType_lift(_ buf: RustBuffer) throws -> MessageType {
    return try FfiConverterTypeMessageType.lift(buf)
}

public func FfiConverterTypeMessageType_lower(_ value: MessageType) -> RustBuffer {
    return FfiConverterTypeMessageType.lower(value)
}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum OtherState {
    
    case `policyRuleRoom`
    case `policyRuleServer`
    case `policyRuleUser`
    case `roomAliases`
    case `roomAvatar`(`url`: String?)
    case `roomCanonicalAlias`
    case `roomCreate`
    case `roomEncryption`
    case `roomGuestAccess`
    case `roomHistoryVisibility`
    case `roomJoinRules`
    case `roomName`(`name`: String?)
    case `roomPinnedEvents`
    case `roomPowerLevels`
    case `roomServerAcl`
    case `roomThirdPartyInvite`(`displayName`: String?)
    case `roomTombstone`
    case `roomTopic`(`topic`: String?)
    case `spaceChild`
    case `spaceParent`
    case `custom`(`eventType`: String)
}

public struct FfiConverterTypeOtherState: FfiConverterRustBuffer {
    typealias SwiftType = OtherState

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> OtherState {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .`policyRuleRoom`
        
        case 2: return .`policyRuleServer`
        
        case 3: return .`policyRuleUser`
        
        case 4: return .`roomAliases`
        
        case 5: return .`roomAvatar`(
            `url`: try FfiConverterOptionString.read(from: &buf)
        )
        
        case 6: return .`roomCanonicalAlias`
        
        case 7: return .`roomCreate`
        
        case 8: return .`roomEncryption`
        
        case 9: return .`roomGuestAccess`
        
        case 10: return .`roomHistoryVisibility`
        
        case 11: return .`roomJoinRules`
        
        case 12: return .`roomName`(
            `name`: try FfiConverterOptionString.read(from: &buf)
        )
        
        case 13: return .`roomPinnedEvents`
        
        case 14: return .`roomPowerLevels`
        
        case 15: return .`roomServerAcl`
        
        case 16: return .`roomThirdPartyInvite`(
            `displayName`: try FfiConverterOptionString.read(from: &buf)
        )
        
        case 17: return .`roomTombstone`
        
        case 18: return .`roomTopic`(
            `topic`: try FfiConverterOptionString.read(from: &buf)
        )
        
        case 19: return .`spaceChild`
        
        case 20: return .`spaceParent`
        
        case 21: return .`custom`(
            `eventType`: try FfiConverterString.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: OtherState, into buf: inout [UInt8]) {
        switch value {
        
        
        case .`policyRuleRoom`:
            writeInt(&buf, Int32(1))
        
        
        case .`policyRuleServer`:
            writeInt(&buf, Int32(2))
        
        
        case .`policyRuleUser`:
            writeInt(&buf, Int32(3))
        
        
        case .`roomAliases`:
            writeInt(&buf, Int32(4))
        
        
        case let .`roomAvatar`(`url`):
            writeInt(&buf, Int32(5))
            FfiConverterOptionString.write(`url`, into: &buf)
            
        
        case .`roomCanonicalAlias`:
            writeInt(&buf, Int32(6))
        
        
        case .`roomCreate`:
            writeInt(&buf, Int32(7))
        
        
        case .`roomEncryption`:
            writeInt(&buf, Int32(8))
        
        
        case .`roomGuestAccess`:
            writeInt(&buf, Int32(9))
        
        
        case .`roomHistoryVisibility`:
            writeInt(&buf, Int32(10))
        
        
        case .`roomJoinRules`:
            writeInt(&buf, Int32(11))
        
        
        case let .`roomName`(`name`):
            writeInt(&buf, Int32(12))
            FfiConverterOptionString.write(`name`, into: &buf)
            
        
        case .`roomPinnedEvents`:
            writeInt(&buf, Int32(13))
        
        
        case .`roomPowerLevels`:
            writeInt(&buf, Int32(14))
        
        
        case .`roomServerAcl`:
            writeInt(&buf, Int32(15))
        
        
        case let .`roomThirdPartyInvite`(`displayName`):
            writeInt(&buf, Int32(16))
            FfiConverterOptionString.write(`displayName`, into: &buf)
            
        
        case .`roomTombstone`:
            writeInt(&buf, Int32(17))
        
        
        case let .`roomTopic`(`topic`):
            writeInt(&buf, Int32(18))
            FfiConverterOptionString.write(`topic`, into: &buf)
            
        
        case .`spaceChild`:
            writeInt(&buf, Int32(19))
        
        
        case .`spaceParent`:
            writeInt(&buf, Int32(20))
        
        
        case let .`custom`(`eventType`):
            writeInt(&buf, Int32(21))
            FfiConverterString.write(`eventType`, into: &buf)
            
        }
    }
}


public func FfiConverterTypeOtherState_lift(_ buf: RustBuffer) throws -> OtherState {
    return try FfiConverterTypeOtherState.lift(buf)
}

public func FfiConverterTypeOtherState_lower(_ value: OtherState) -> RustBuffer {
    return FfiConverterTypeOtherState.lower(value)
}


extension OtherState: Equatable, Hashable {}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum PaginationOptions {
    
    case `singleRequest`(`eventLimit`: UInt16)
    case `untilNumItems`(`eventLimit`: UInt16, `items`: UInt16)
}

public struct FfiConverterTypePaginationOptions: FfiConverterRustBuffer {
    typealias SwiftType = PaginationOptions

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PaginationOptions {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .`singleRequest`(
            `eventLimit`: try FfiConverterUInt16.read(from: &buf)
        )
        
        case 2: return .`untilNumItems`(
            `eventLimit`: try FfiConverterUInt16.read(from: &buf), 
            `items`: try FfiConverterUInt16.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: PaginationOptions, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .`singleRequest`(`eventLimit`):
            writeInt(&buf, Int32(1))
            FfiConverterUInt16.write(`eventLimit`, into: &buf)
            
        
        case let .`untilNumItems`(`eventLimit`,`items`):
            writeInt(&buf, Int32(2))
            FfiConverterUInt16.write(`eventLimit`, into: &buf)
            FfiConverterUInt16.write(`items`, into: &buf)
            
        }
    }
}


public func FfiConverterTypePaginationOptions_lift(_ buf: RustBuffer) throws -> PaginationOptions {
    return try FfiConverterTypePaginationOptions.lift(buf)
}

public func FfiConverterTypePaginationOptions_lower(_ value: PaginationOptions) -> RustBuffer {
    return FfiConverterTypePaginationOptions.lower(value)
}


extension PaginationOptions: Equatable, Hashable {}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum ProfileDetails {
    
    case `unavailable`
    case `pending`
    case `ready`(`displayName`: String?, `displayNameAmbiguous`: Bool, `avatarUrl`: String?)
    case `error`(`message`: String)
}

public struct FfiConverterTypeProfileDetails: FfiConverterRustBuffer {
    typealias SwiftType = ProfileDetails

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ProfileDetails {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .`unavailable`
        
        case 2: return .`pending`
        
        case 3: return .`ready`(
            `displayName`: try FfiConverterOptionString.read(from: &buf), 
            `displayNameAmbiguous`: try FfiConverterBool.read(from: &buf), 
            `avatarUrl`: try FfiConverterOptionString.read(from: &buf)
        )
        
        case 4: return .`error`(
            `message`: try FfiConverterString.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ProfileDetails, into buf: inout [UInt8]) {
        switch value {
        
        
        case .`unavailable`:
            writeInt(&buf, Int32(1))
        
        
        case .`pending`:
            writeInt(&buf, Int32(2))
        
        
        case let .`ready`(`displayName`,`displayNameAmbiguous`,`avatarUrl`):
            writeInt(&buf, Int32(3))
            FfiConverterOptionString.write(`displayName`, into: &buf)
            FfiConverterBool.write(`displayNameAmbiguous`, into: &buf)
            FfiConverterOptionString.write(`avatarUrl`, into: &buf)
            
        
        case let .`error`(`message`):
            writeInt(&buf, Int32(4))
            FfiConverterString.write(`message`, into: &buf)
            
        }
    }
}


public func FfiConverterTypeProfileDetails_lift(_ buf: RustBuffer) throws -> ProfileDetails {
    return try FfiConverterTypeProfileDetails.lift(buf)
}

public func FfiConverterTypeProfileDetails_lower(_ value: ProfileDetails) -> RustBuffer {
    return FfiConverterTypeProfileDetails.lower(value)
}


extension ProfileDetails: Equatable, Hashable {}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum PushFormat {
    
    case `eventIdOnly`
}

public struct FfiConverterTypePushFormat: FfiConverterRustBuffer {
    typealias SwiftType = PushFormat

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PushFormat {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .`eventIdOnly`
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: PushFormat, into buf: inout [UInt8]) {
        switch value {
        
        
        case .`eventIdOnly`:
            writeInt(&buf, Int32(1))
        
        }
    }
}


public func FfiConverterTypePushFormat_lift(_ buf: RustBuffer) throws -> PushFormat {
    return try FfiConverterTypePushFormat.lift(buf)
}

public func FfiConverterTypePushFormat_lower(_ value: PushFormat) -> RustBuffer {
    return FfiConverterTypePushFormat.lower(value)
}


extension PushFormat: Equatable, Hashable {}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum PusherKind {
    
    case `http`(`data`: HttpPusherData)
    case `email`
}

public struct FfiConverterTypePusherKind: FfiConverterRustBuffer {
    typealias SwiftType = PusherKind

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PusherKind {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .`http`(
            `data`: try FfiConverterTypeHttpPusherData.read(from: &buf)
        )
        
        case 2: return .`email`
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: PusherKind, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .`http`(`data`):
            writeInt(&buf, Int32(1))
            FfiConverterTypeHttpPusherData.write(`data`, into: &buf)
            
        
        case .`email`:
            writeInt(&buf, Int32(2))
        
        }
    }
}


public func FfiConverterTypePusherKind_lift(_ buf: RustBuffer) throws -> PusherKind {
    return try FfiConverterTypePusherKind.lift(buf)
}

public func FfiConverterTypePusherKind_lower(_ value: PusherKind) -> RustBuffer {
    return FfiConverterTypePusherKind.lower(value)
}


extension PusherKind: Equatable, Hashable {}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum RepliedToEventDetails {
    
    case `unavailable`
    case `pending`
    case `ready`(`message`: Message, `sender`: String, `senderProfile`: ProfileDetails)
    case `error`(`message`: String)
}

public struct FfiConverterTypeRepliedToEventDetails: FfiConverterRustBuffer {
    typealias SwiftType = RepliedToEventDetails

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RepliedToEventDetails {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .`unavailable`
        
        case 2: return .`pending`
        
        case 3: return .`ready`(
            `message`: try FfiConverterTypeMessage.read(from: &buf), 
            `sender`: try FfiConverterString.read(from: &buf), 
            `senderProfile`: try FfiConverterTypeProfileDetails.read(from: &buf)
        )
        
        case 4: return .`error`(
            `message`: try FfiConverterString.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: RepliedToEventDetails, into buf: inout [UInt8]) {
        switch value {
        
        
        case .`unavailable`:
            writeInt(&buf, Int32(1))
        
        
        case .`pending`:
            writeInt(&buf, Int32(2))
        
        
        case let .`ready`(`message`,`sender`,`senderProfile`):
            writeInt(&buf, Int32(3))
            FfiConverterTypeMessage.write(`message`, into: &buf)
            FfiConverterString.write(`sender`, into: &buf)
            FfiConverterTypeProfileDetails.write(`senderProfile`, into: &buf)
            
        
        case let .`error`(`message`):
            writeInt(&buf, Int32(4))
            FfiConverterString.write(`message`, into: &buf)
            
        }
    }
}


public func FfiConverterTypeRepliedToEventDetails_lift(_ buf: RustBuffer) throws -> RepliedToEventDetails {
    return try FfiConverterTypeRepliedToEventDetails.lift(buf)
}

public func FfiConverterTypeRepliedToEventDetails_lower(_ value: RepliedToEventDetails) -> RustBuffer {
    return FfiConverterTypeRepliedToEventDetails.lower(value)
}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum RoomListEntry {
    
    case `empty`
    case `invalidated`(`roomId`: String)
    case `filled`(`roomId`: String)
}

public struct FfiConverterTypeRoomListEntry: FfiConverterRustBuffer {
    typealias SwiftType = RoomListEntry

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RoomListEntry {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .`empty`
        
        case 2: return .`invalidated`(
            `roomId`: try FfiConverterString.read(from: &buf)
        )
        
        case 3: return .`filled`(
            `roomId`: try FfiConverterString.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: RoomListEntry, into buf: inout [UInt8]) {
        switch value {
        
        
        case .`empty`:
            writeInt(&buf, Int32(1))
        
        
        case let .`invalidated`(`roomId`):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(`roomId`, into: &buf)
            
        
        case let .`filled`(`roomId`):
            writeInt(&buf, Int32(3))
            FfiConverterString.write(`roomId`, into: &buf)
            
        }
    }
}


public func FfiConverterTypeRoomListEntry_lift(_ buf: RustBuffer) throws -> RoomListEntry {
    return try FfiConverterTypeRoomListEntry.lift(buf)
}

public func FfiConverterTypeRoomListEntry_lower(_ value: RoomListEntry) -> RustBuffer {
    return FfiConverterTypeRoomListEntry.lower(value)
}


extension RoomListEntry: Equatable, Hashable {}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum RoomPreset {
    
    case `privateChat`
    case `publicChat`
    case `trustedPrivateChat`
}

public struct FfiConverterTypeRoomPreset: FfiConverterRustBuffer {
    typealias SwiftType = RoomPreset

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RoomPreset {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .`privateChat`
        
        case 2: return .`publicChat`
        
        case 3: return .`trustedPrivateChat`
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: RoomPreset, into buf: inout [UInt8]) {
        switch value {
        
        
        case .`privateChat`:
            writeInt(&buf, Int32(1))
        
        
        case .`publicChat`:
            writeInt(&buf, Int32(2))
        
        
        case .`trustedPrivateChat`:
            writeInt(&buf, Int32(3))
        
        }
    }
}


public func FfiConverterTypeRoomPreset_lift(_ buf: RustBuffer) throws -> RoomPreset {
    return try FfiConverterTypeRoomPreset.lift(buf)
}

public func FfiConverterTypeRoomPreset_lower(_ value: RoomPreset) -> RustBuffer {
    return FfiConverterTypeRoomPreset.lower(value)
}


extension RoomPreset: Equatable, Hashable {}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum RoomVisibility {
    
    case `public`
    case `private`
}

public struct FfiConverterTypeRoomVisibility: FfiConverterRustBuffer {
    typealias SwiftType = RoomVisibility

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RoomVisibility {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .`public`
        
        case 2: return .`private`
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: RoomVisibility, into buf: inout [UInt8]) {
        switch value {
        
        
        case .`public`:
            writeInt(&buf, Int32(1))
        
        
        case .`private`:
            writeInt(&buf, Int32(2))
        
        }
    }
}


public func FfiConverterTypeRoomVisibility_lift(_ buf: RustBuffer) throws -> RoomVisibility {
    return try FfiConverterTypeRoomVisibility.lift(buf)
}

public func FfiConverterTypeRoomVisibility_lower(_ value: RoomVisibility) -> RustBuffer {
    return FfiConverterTypeRoomVisibility.lower(value)
}


extension RoomVisibility: Equatable, Hashable {}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum SlidingSyncListRoomsListDiff {
    
    case `append`(`values`: [RoomListEntry])
    case `insert`(`index`: UInt32, `value`: RoomListEntry)
    case `set`(`index`: UInt32, `value`: RoomListEntry)
    case `remove`(`index`: UInt32)
    case `pushBack`(`value`: RoomListEntry)
    case `pushFront`(`value`: RoomListEntry)
    case `popBack`
    case `popFront`
    case `clear`
    case `reset`(`values`: [RoomListEntry])
}

public struct FfiConverterTypeSlidingSyncListRoomsListDiff: FfiConverterRustBuffer {
    typealias SwiftType = SlidingSyncListRoomsListDiff

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SlidingSyncListRoomsListDiff {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .`append`(
            `values`: try FfiConverterSequenceTypeRoomListEntry.read(from: &buf)
        )
        
        case 2: return .`insert`(
            `index`: try FfiConverterUInt32.read(from: &buf), 
            `value`: try FfiConverterTypeRoomListEntry.read(from: &buf)
        )
        
        case 3: return .`set`(
            `index`: try FfiConverterUInt32.read(from: &buf), 
            `value`: try FfiConverterTypeRoomListEntry.read(from: &buf)
        )
        
        case 4: return .`remove`(
            `index`: try FfiConverterUInt32.read(from: &buf)
        )
        
        case 5: return .`pushBack`(
            `value`: try FfiConverterTypeRoomListEntry.read(from: &buf)
        )
        
        case 6: return .`pushFront`(
            `value`: try FfiConverterTypeRoomListEntry.read(from: &buf)
        )
        
        case 7: return .`popBack`
        
        case 8: return .`popFront`
        
        case 9: return .`clear`
        
        case 10: return .`reset`(
            `values`: try FfiConverterSequenceTypeRoomListEntry.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: SlidingSyncListRoomsListDiff, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .`append`(`values`):
            writeInt(&buf, Int32(1))
            FfiConverterSequenceTypeRoomListEntry.write(`values`, into: &buf)
            
        
        case let .`insert`(`index`,`value`):
            writeInt(&buf, Int32(2))
            FfiConverterUInt32.write(`index`, into: &buf)
            FfiConverterTypeRoomListEntry.write(`value`, into: &buf)
            
        
        case let .`set`(`index`,`value`):
            writeInt(&buf, Int32(3))
            FfiConverterUInt32.write(`index`, into: &buf)
            FfiConverterTypeRoomListEntry.write(`value`, into: &buf)
            
        
        case let .`remove`(`index`):
            writeInt(&buf, Int32(4))
            FfiConverterUInt32.write(`index`, into: &buf)
            
        
        case let .`pushBack`(`value`):
            writeInt(&buf, Int32(5))
            FfiConverterTypeRoomListEntry.write(`value`, into: &buf)
            
        
        case let .`pushFront`(`value`):
            writeInt(&buf, Int32(6))
            FfiConverterTypeRoomListEntry.write(`value`, into: &buf)
            
        
        case .`popBack`:
            writeInt(&buf, Int32(7))
        
        
        case .`popFront`:
            writeInt(&buf, Int32(8))
        
        
        case .`clear`:
            writeInt(&buf, Int32(9))
        
        
        case let .`reset`(`values`):
            writeInt(&buf, Int32(10))
            FfiConverterSequenceTypeRoomListEntry.write(`values`, into: &buf)
            
        }
    }
}


public func FfiConverterTypeSlidingSyncListRoomsListDiff_lift(_ buf: RustBuffer) throws -> SlidingSyncListRoomsListDiff {
    return try FfiConverterTypeSlidingSyncListRoomsListDiff.lift(buf)
}

public func FfiConverterTypeSlidingSyncListRoomsListDiff_lower(_ value: SlidingSyncListRoomsListDiff) -> RustBuffer {
    return FfiConverterTypeSlidingSyncListRoomsListDiff.lower(value)
}


extension SlidingSyncListRoomsListDiff: Equatable, Hashable {}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum SlidingSyncMode {
    
    case `paging`
    case `growing`
    case `selective`
}

public struct FfiConverterTypeSlidingSyncMode: FfiConverterRustBuffer {
    typealias SwiftType = SlidingSyncMode

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SlidingSyncMode {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .`paging`
        
        case 2: return .`growing`
        
        case 3: return .`selective`
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: SlidingSyncMode, into buf: inout [UInt8]) {
        switch value {
        
        
        case .`paging`:
            writeInt(&buf, Int32(1))
        
        
        case .`growing`:
            writeInt(&buf, Int32(2))
        
        
        case .`selective`:
            writeInt(&buf, Int32(3))
        
        }
    }
}


public func FfiConverterTypeSlidingSyncMode_lift(_ buf: RustBuffer) throws -> SlidingSyncMode {
    return try FfiConverterTypeSlidingSyncMode.lift(buf)
}

public func FfiConverterTypeSlidingSyncMode_lower(_ value: SlidingSyncMode) -> RustBuffer {
    return FfiConverterTypeSlidingSyncMode.lower(value)
}


extension SlidingSyncMode: Equatable, Hashable {}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum SlidingSyncState {
    
    case `notLoaded`
    case `preloaded`
    case `partiallyLoaded`
    case `fullyLoaded`
}

public struct FfiConverterTypeSlidingSyncState: FfiConverterRustBuffer {
    typealias SwiftType = SlidingSyncState

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SlidingSyncState {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .`notLoaded`
        
        case 2: return .`preloaded`
        
        case 3: return .`partiallyLoaded`
        
        case 4: return .`fullyLoaded`
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: SlidingSyncState, into buf: inout [UInt8]) {
        switch value {
        
        
        case .`notLoaded`:
            writeInt(&buf, Int32(1))
        
        
        case .`preloaded`:
            writeInt(&buf, Int32(2))
        
        
        case .`partiallyLoaded`:
            writeInt(&buf, Int32(3))
        
        
        case .`fullyLoaded`:
            writeInt(&buf, Int32(4))
        
        }
    }
}


public func FfiConverterTypeSlidingSyncState_lift(_ buf: RustBuffer) throws -> SlidingSyncState {
    return try FfiConverterTypeSlidingSyncState.lift(buf)
}

public func FfiConverterTypeSlidingSyncState_lower(_ value: SlidingSyncState) -> RustBuffer {
    return FfiConverterTypeSlidingSyncState.lower(value)
}


extension SlidingSyncState: Equatable, Hashable {}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum TimelineChange {
    
    case `append`
    case `clear`
    case `insert`
    case `set`
    case `remove`
    case `pushBack`
    case `pushFront`
    case `popBack`
    case `popFront`
    case `reset`
}

public struct FfiConverterTypeTimelineChange: FfiConverterRustBuffer {
    typealias SwiftType = TimelineChange

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TimelineChange {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .`append`
        
        case 2: return .`clear`
        
        case 3: return .`insert`
        
        case 4: return .`set`
        
        case 5: return .`remove`
        
        case 6: return .`pushBack`
        
        case 7: return .`pushFront`
        
        case 8: return .`popBack`
        
        case 9: return .`popFront`
        
        case 10: return .`reset`
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: TimelineChange, into buf: inout [UInt8]) {
        switch value {
        
        
        case .`append`:
            writeInt(&buf, Int32(1))
        
        
        case .`clear`:
            writeInt(&buf, Int32(2))
        
        
        case .`insert`:
            writeInt(&buf, Int32(3))
        
        
        case .`set`:
            writeInt(&buf, Int32(4))
        
        
        case .`remove`:
            writeInt(&buf, Int32(5))
        
        
        case .`pushBack`:
            writeInt(&buf, Int32(6))
        
        
        case .`pushFront`:
            writeInt(&buf, Int32(7))
        
        
        case .`popBack`:
            writeInt(&buf, Int32(8))
        
        
        case .`popFront`:
            writeInt(&buf, Int32(9))
        
        
        case .`reset`:
            writeInt(&buf, Int32(10))
        
        }
    }
}


public func FfiConverterTypeTimelineChange_lift(_ buf: RustBuffer) throws -> TimelineChange {
    return try FfiConverterTypeTimelineChange.lift(buf)
}

public func FfiConverterTypeTimelineChange_lower(_ value: TimelineChange) -> RustBuffer {
    return FfiConverterTypeTimelineChange.lower(value)
}


extension TimelineChange: Equatable, Hashable {}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum TimelineItemContentKind {
    
    case `message`
    case `redactedMessage`
    case `sticker`(`body`: String, `info`: ImageInfo, `url`: String)
    case `unableToDecrypt`(`msg`: EncryptedMessage)
    case `roomMembership`(`userId`: String, `change`: MembershipChange?)
    case `profileChange`(`displayName`: String?, `prevDisplayName`: String?, `avatarUrl`: String?, `prevAvatarUrl`: String?)
    case `state`(`stateKey`: String, `content`: OtherState)
    case `failedToParseMessageLike`(`eventType`: String, `error`: String)
    case `failedToParseState`(`eventType`: String, `stateKey`: String, `error`: String)
}

public struct FfiConverterTypeTimelineItemContentKind: FfiConverterRustBuffer {
    typealias SwiftType = TimelineItemContentKind

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TimelineItemContentKind {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .`message`
        
        case 2: return .`redactedMessage`
        
        case 3: return .`sticker`(
            `body`: try FfiConverterString.read(from: &buf), 
            `info`: try FfiConverterTypeImageInfo.read(from: &buf), 
            `url`: try FfiConverterString.read(from: &buf)
        )
        
        case 4: return .`unableToDecrypt`(
            `msg`: try FfiConverterTypeEncryptedMessage.read(from: &buf)
        )
        
        case 5: return .`roomMembership`(
            `userId`: try FfiConverterString.read(from: &buf), 
            `change`: try FfiConverterOptionTypeMembershipChange.read(from: &buf)
        )
        
        case 6: return .`profileChange`(
            `displayName`: try FfiConverterOptionString.read(from: &buf), 
            `prevDisplayName`: try FfiConverterOptionString.read(from: &buf), 
            `avatarUrl`: try FfiConverterOptionString.read(from: &buf), 
            `prevAvatarUrl`: try FfiConverterOptionString.read(from: &buf)
        )
        
        case 7: return .`state`(
            `stateKey`: try FfiConverterString.read(from: &buf), 
            `content`: try FfiConverterTypeOtherState.read(from: &buf)
        )
        
        case 8: return .`failedToParseMessageLike`(
            `eventType`: try FfiConverterString.read(from: &buf), 
            `error`: try FfiConverterString.read(from: &buf)
        )
        
        case 9: return .`failedToParseState`(
            `eventType`: try FfiConverterString.read(from: &buf), 
            `stateKey`: try FfiConverterString.read(from: &buf), 
            `error`: try FfiConverterString.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: TimelineItemContentKind, into buf: inout [UInt8]) {
        switch value {
        
        
        case .`message`:
            writeInt(&buf, Int32(1))
        
        
        case .`redactedMessage`:
            writeInt(&buf, Int32(2))
        
        
        case let .`sticker`(`body`,`info`,`url`):
            writeInt(&buf, Int32(3))
            FfiConverterString.write(`body`, into: &buf)
            FfiConverterTypeImageInfo.write(`info`, into: &buf)
            FfiConverterString.write(`url`, into: &buf)
            
        
        case let .`unableToDecrypt`(`msg`):
            writeInt(&buf, Int32(4))
            FfiConverterTypeEncryptedMessage.write(`msg`, into: &buf)
            
        
        case let .`roomMembership`(`userId`,`change`):
            writeInt(&buf, Int32(5))
            FfiConverterString.write(`userId`, into: &buf)
            FfiConverterOptionTypeMembershipChange.write(`change`, into: &buf)
            
        
        case let .`profileChange`(`displayName`,`prevDisplayName`,`avatarUrl`,`prevAvatarUrl`):
            writeInt(&buf, Int32(6))
            FfiConverterOptionString.write(`displayName`, into: &buf)
            FfiConverterOptionString.write(`prevDisplayName`, into: &buf)
            FfiConverterOptionString.write(`avatarUrl`, into: &buf)
            FfiConverterOptionString.write(`prevAvatarUrl`, into: &buf)
            
        
        case let .`state`(`stateKey`,`content`):
            writeInt(&buf, Int32(7))
            FfiConverterString.write(`stateKey`, into: &buf)
            FfiConverterTypeOtherState.write(`content`, into: &buf)
            
        
        case let .`failedToParseMessageLike`(`eventType`,`error`):
            writeInt(&buf, Int32(8))
            FfiConverterString.write(`eventType`, into: &buf)
            FfiConverterString.write(`error`, into: &buf)
            
        
        case let .`failedToParseState`(`eventType`,`stateKey`,`error`):
            writeInt(&buf, Int32(9))
            FfiConverterString.write(`eventType`, into: &buf)
            FfiConverterString.write(`stateKey`, into: &buf)
            FfiConverterString.write(`error`, into: &buf)
            
        }
    }
}


public func FfiConverterTypeTimelineItemContentKind_lift(_ buf: RustBuffer) throws -> TimelineItemContentKind {
    return try FfiConverterTypeTimelineItemContentKind.lift(buf)
}

public func FfiConverterTypeTimelineItemContentKind_lower(_ value: TimelineItemContentKind) -> RustBuffer {
    return FfiConverterTypeTimelineItemContentKind.lower(value)
}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum VirtualTimelineItem {
    
    case `dayDivider`(`ts`: UInt64)
    case `readMarker`
    case `loadingIndicator`
    case `timelineStart`
}

public struct FfiConverterTypeVirtualTimelineItem: FfiConverterRustBuffer {
    typealias SwiftType = VirtualTimelineItem

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> VirtualTimelineItem {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .`dayDivider`(
            `ts`: try FfiConverterUInt64.read(from: &buf)
        )
        
        case 2: return .`readMarker`
        
        case 3: return .`loadingIndicator`
        
        case 4: return .`timelineStart`
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: VirtualTimelineItem, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .`dayDivider`(`ts`):
            writeInt(&buf, Int32(1))
            FfiConverterUInt64.write(`ts`, into: &buf)
            
        
        case .`readMarker`:
            writeInt(&buf, Int32(2))
        
        
        case .`loadingIndicator`:
            writeInt(&buf, Int32(3))
        
        
        case .`timelineStart`:
            writeInt(&buf, Int32(4))
        
        }
    }
}


public func FfiConverterTypeVirtualTimelineItem_lift(_ buf: RustBuffer) throws -> VirtualTimelineItem {
    return try FfiConverterTypeVirtualTimelineItem.lift(buf)
}

public func FfiConverterTypeVirtualTimelineItem_lower(_ value: VirtualTimelineItem) -> RustBuffer {
    return FfiConverterTypeVirtualTimelineItem.lower(value)
}


extension VirtualTimelineItem: Equatable, Hashable {}



public enum AuthenticationError {

    
    
    // Simple error enums only carry a message
    case ClientMissing(message: String)
    
    // Simple error enums only carry a message
    case InvalidServerName(message: String)
    
    // Simple error enums only carry a message
    case SlidingSyncNotAvailable(message: String)
    
    // Simple error enums only carry a message
    case SessionMissing(message: String)
    
    // Simple error enums only carry a message
    case Generic(message: String)
    
}

public struct FfiConverterTypeAuthenticationError: FfiConverterRustBuffer {
    typealias SwiftType = AuthenticationError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AuthenticationError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .ClientMissing(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 2: return .InvalidServerName(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 3: return .SlidingSyncNotAvailable(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 4: return .SessionMissing(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 5: return .Generic(
            message: try FfiConverterString.read(from: &buf)
        )
        

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: AuthenticationError, into buf: inout [UInt8]) {
        switch value {

        

        
        case let .ClientMissing(message):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(message, into: &buf)
        case let .InvalidServerName(message):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(message, into: &buf)
        case let .SlidingSyncNotAvailable(message):
            writeInt(&buf, Int32(3))
            FfiConverterString.write(message, into: &buf)
        case let .SessionMissing(message):
            writeInt(&buf, Int32(4))
            FfiConverterString.write(message, into: &buf)
        case let .Generic(message):
            writeInt(&buf, Int32(5))
            FfiConverterString.write(message, into: &buf)

        
        }
    }
}


extension AuthenticationError: Equatable, Hashable {}

extension AuthenticationError: Error { }


public enum ClientError {

    
    
    case Generic(`msg`: String)
}

public struct FfiConverterTypeClientError: FfiConverterRustBuffer {
    typealias SwiftType = ClientError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ClientError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .Generic(
            `msg`: try FfiConverterString.read(from: &buf)
            )

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ClientError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case let .Generic(`msg`):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(`msg`, into: &buf)
            
        }
    }
}


extension ClientError: Equatable, Hashable {}

extension ClientError: Error { }


public enum SlidingSyncError {

    
    
    case BadResponse(`msg`: String)
    case BuildMissingField(`msg`: String)
    case RequestGeneratorHasNotBeenInitialized(`msg`: String)
    case CannotModifyRanges(`msg`: String)
    case InvalidRange(`start`: UInt32, `end`: UInt32)
    case Unknown(`error`: String)
}

public struct FfiConverterTypeSlidingSyncError: FfiConverterRustBuffer {
    typealias SwiftType = SlidingSyncError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SlidingSyncError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .BadResponse(
            `msg`: try FfiConverterString.read(from: &buf)
            )
        case 2: return .BuildMissingField(
            `msg`: try FfiConverterString.read(from: &buf)
            )
        case 3: return .RequestGeneratorHasNotBeenInitialized(
            `msg`: try FfiConverterString.read(from: &buf)
            )
        case 4: return .CannotModifyRanges(
            `msg`: try FfiConverterString.read(from: &buf)
            )
        case 5: return .InvalidRange(
            `start`: try FfiConverterUInt32.read(from: &buf), 
            `end`: try FfiConverterUInt32.read(from: &buf)
            )
        case 6: return .Unknown(
            `error`: try FfiConverterString.read(from: &buf)
            )

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: SlidingSyncError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case let .BadResponse(`msg`):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(`msg`, into: &buf)
            
        
        case let .BuildMissingField(`msg`):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(`msg`, into: &buf)
            
        
        case let .RequestGeneratorHasNotBeenInitialized(`msg`):
            writeInt(&buf, Int32(3))
            FfiConverterString.write(`msg`, into: &buf)
            
        
        case let .CannotModifyRanges(`msg`):
            writeInt(&buf, Int32(4))
            FfiConverterString.write(`msg`, into: &buf)
            
        
        case let .InvalidRange(`start`,`end`):
            writeInt(&buf, Int32(5))
            FfiConverterUInt32.write(`start`, into: &buf)
            FfiConverterUInt32.write(`end`, into: &buf)
            
        
        case let .Unknown(`error`):
            writeInt(&buf, Int32(6))
            FfiConverterString.write(`error`, into: &buf)
            
        }
    }
}


extension SlidingSyncError: Equatable, Hashable {}

extension SlidingSyncError: Error { }

fileprivate extension NSLock {
    func withLock<T>(f: () throws -> T) rethrows -> T {
        self.lock()
        defer { self.unlock() }
        return try f()
    }
}

fileprivate typealias UniFFICallbackHandle = UInt64
fileprivate class UniFFICallbackHandleMap<T> {
    private var leftMap: [UniFFICallbackHandle: T] = [:]
    private var counter: [UniFFICallbackHandle: UInt64] = [:]
    private var rightMap: [ObjectIdentifier: UniFFICallbackHandle] = [:]

    private let lock = NSLock()
    private var currentHandle: UniFFICallbackHandle = 0
    private let stride: UniFFICallbackHandle = 1

    func insert(obj: T) -> UniFFICallbackHandle {
        lock.withLock {
            let id = ObjectIdentifier(obj as AnyObject)
            let handle = rightMap[id] ?? {
                currentHandle += stride
                let handle = currentHandle
                leftMap[handle] = obj
                rightMap[id] = handle
                return handle
            }()
            counter[handle] = (counter[handle] ?? 0) + 1
            return handle
        }
    }

    func get(handle: UniFFICallbackHandle) -> T? {
        lock.withLock {
            leftMap[handle]
        }
    }

    func delete(handle: UniFFICallbackHandle) {
        remove(handle: handle)
    }

    @discardableResult
    func remove(handle: UniFFICallbackHandle) -> T? {
        lock.withLock {
            defer { counter[handle] = (counter[handle] ?? 1) - 1 }
            guard counter[handle] == 1 else { return leftMap[handle] }
            let obj = leftMap.removeValue(forKey: handle)
            if let obj = obj {
                rightMap.removeValue(forKey: ObjectIdentifier(obj as AnyObject))
            }
            return obj
        }
    }
}

// Magic number for the Rust proxy to call using the same mechanism as every other method,
// to free the callback once it's dropped by Rust.
private let IDX_CALLBACK_FREE: Int32 = 0
// Callback return codes
private let UNIFFI_CALLBACK_SUCCESS: Int32 = 0
private let UNIFFI_CALLBACK_ERROR: Int32 = 1
private let UNIFFI_CALLBACK_UNEXPECTED_ERROR: Int32 = 2

// Declaration and FfiConverters for ClientDelegate Callback Interface

public protocol ClientDelegate : AnyObject {
    func `didReceiveAuthError`(`isSoftLogout`: Bool) 
    
}

// The ForeignCallback that is passed to Rust.
fileprivate let foreignCallbackCallbackInterfaceClientDelegate : ForeignCallback =
    { (handle: UniFFICallbackHandle, method: Int32, argsData: UnsafePointer<UInt8>, argsLen: Int32, out_buf: UnsafeMutablePointer<RustBuffer>) -> Int32 in
    

    func `invokeDidReceiveAuthError`(_ swiftCallbackInterface: ClientDelegate, _ argsData: UnsafePointer<UInt8>, _ argsLen: Int32, _ out_buf: UnsafeMutablePointer<RustBuffer>) throws -> Int32 {
        var reader = createReader(data: Data(bytes: argsData, count: Int(argsLen)))
        func makeCall() throws -> Int32 {
            try swiftCallbackInterface.`didReceiveAuthError`(
                    `isSoftLogout`:  try FfiConverterBool.read(from: &reader)
                    )
            return UNIFFI_CALLBACK_SUCCESS
        }
        return try makeCall()
    }


    switch method {
        case IDX_CALLBACK_FREE:
            FfiConverterCallbackInterfaceClientDelegate.drop(handle: handle)
            // Sucessful return
            // See docs of ForeignCallback in `uniffi_core/src/ffi/foreigncallbacks.rs`
            return UNIFFI_CALLBACK_SUCCESS
        case 1:
            let cb: ClientDelegate
            do {
                cb = try FfiConverterCallbackInterfaceClientDelegate.lift(handle)
            } catch {
                out_buf.pointee = FfiConverterString.lower("ClientDelegate: Invalid handle")
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }
            do {
                return try `invokeDidReceiveAuthError`(cb, argsData, argsLen, out_buf)
            } catch let error {
                out_buf.pointee = FfiConverterString.lower(String(describing: error))
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }
        
        // This should never happen, because an out of bounds method index won't
        // ever be used. Once we can catch errors, we should return an InternalError.
        // https://github.com/mozilla/uniffi-rs/issues/351
        default:
            // An unexpected error happened.
            // See docs of ForeignCallback in `uniffi_core/src/ffi/foreigncallbacks.rs`
            return UNIFFI_CALLBACK_UNEXPECTED_ERROR
    }
}

// FfiConverter protocol for callback interfaces
fileprivate struct FfiConverterCallbackInterfaceClientDelegate {
    private static let initCallbackOnce: () = {
        // Swift ensures this initializer code will once run once, even when accessed by multiple threads.
        try! rustCall { (err: UnsafeMutablePointer<RustCallStatus>) in
            ffi_matrix_sdk_ffi_8d0d_ClientDelegate_init_callback(foreignCallbackCallbackInterfaceClientDelegate, err)
        }
    }()

    private static func ensureCallbackinitialized() {
        _ = initCallbackOnce
    }

    static func drop(handle: UniFFICallbackHandle) {
        handleMap.remove(handle: handle)
    }

    private static var handleMap = UniFFICallbackHandleMap<ClientDelegate>()
}

extension FfiConverterCallbackInterfaceClientDelegate : FfiConverter {
    typealias SwiftType = ClientDelegate
    // We can use Handle as the FfiType because it's a typealias to UInt64
    typealias FfiType = UniFFICallbackHandle

    public static func lift(_ handle: UniFFICallbackHandle) throws -> SwiftType {
        ensureCallbackinitialized();
        guard let callback = handleMap.get(handle: handle) else {
            throw UniffiInternalError.unexpectedStaleHandle
        }
        return callback
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        ensureCallbackinitialized();
        let handle: UniFFICallbackHandle = try readInt(&buf)
        return try lift(handle)
    }

    public static func lower(_ v: SwiftType) -> UniFFICallbackHandle {
        ensureCallbackinitialized();
        return handleMap.insert(obj: v)
    }

    public static func write(_ v: SwiftType, into buf: inout [UInt8]) {
        ensureCallbackinitialized();
        writeInt(&buf, lower(v))
    }
}



// Declaration and FfiConverters for SessionVerificationControllerDelegate Callback Interface

public protocol SessionVerificationControllerDelegate : AnyObject {
    func `didAcceptVerificationRequest`() 
    func `didStartSasVerification`() 
    func `didReceiveVerificationData`(`data`: [SessionVerificationEmoji]) 
    func `didFail`() 
    func `didCancel`() 
    func `didFinish`() 
    
}

// The ForeignCallback that is passed to Rust.
fileprivate let foreignCallbackCallbackInterfaceSessionVerificationControllerDelegate : ForeignCallback =
    { (handle: UniFFICallbackHandle, method: Int32, argsData: UnsafePointer<UInt8>, argsLen: Int32, out_buf: UnsafeMutablePointer<RustBuffer>) -> Int32 in
    

    func `invokeDidAcceptVerificationRequest`(_ swiftCallbackInterface: SessionVerificationControllerDelegate, _ argsData: UnsafePointer<UInt8>, _ argsLen: Int32, _ out_buf: UnsafeMutablePointer<RustBuffer>) throws -> Int32 {
        func makeCall() throws -> Int32 {
            try swiftCallbackInterface.`didAcceptVerificationRequest`(
                    )
            return UNIFFI_CALLBACK_SUCCESS
        }
        return try makeCall()
    }

    func `invokeDidStartSasVerification`(_ swiftCallbackInterface: SessionVerificationControllerDelegate, _ argsData: UnsafePointer<UInt8>, _ argsLen: Int32, _ out_buf: UnsafeMutablePointer<RustBuffer>) throws -> Int32 {
        func makeCall() throws -> Int32 {
            try swiftCallbackInterface.`didStartSasVerification`(
                    )
            return UNIFFI_CALLBACK_SUCCESS
        }
        return try makeCall()
    }

    func `invokeDidReceiveVerificationData`(_ swiftCallbackInterface: SessionVerificationControllerDelegate, _ argsData: UnsafePointer<UInt8>, _ argsLen: Int32, _ out_buf: UnsafeMutablePointer<RustBuffer>) throws -> Int32 {
        var reader = createReader(data: Data(bytes: argsData, count: Int(argsLen)))
        func makeCall() throws -> Int32 {
            try swiftCallbackInterface.`didReceiveVerificationData`(
                    `data`:  try FfiConverterSequenceTypeSessionVerificationEmoji.read(from: &reader)
                    )
            return UNIFFI_CALLBACK_SUCCESS
        }
        return try makeCall()
    }

    func `invokeDidFail`(_ swiftCallbackInterface: SessionVerificationControllerDelegate, _ argsData: UnsafePointer<UInt8>, _ argsLen: Int32, _ out_buf: UnsafeMutablePointer<RustBuffer>) throws -> Int32 {
        func makeCall() throws -> Int32 {
            try swiftCallbackInterface.`didFail`(
                    )
            return UNIFFI_CALLBACK_SUCCESS
        }
        return try makeCall()
    }

    func `invokeDidCancel`(_ swiftCallbackInterface: SessionVerificationControllerDelegate, _ argsData: UnsafePointer<UInt8>, _ argsLen: Int32, _ out_buf: UnsafeMutablePointer<RustBuffer>) throws -> Int32 {
        func makeCall() throws -> Int32 {
            try swiftCallbackInterface.`didCancel`(
                    )
            return UNIFFI_CALLBACK_SUCCESS
        }
        return try makeCall()
    }

    func `invokeDidFinish`(_ swiftCallbackInterface: SessionVerificationControllerDelegate, _ argsData: UnsafePointer<UInt8>, _ argsLen: Int32, _ out_buf: UnsafeMutablePointer<RustBuffer>) throws -> Int32 {
        func makeCall() throws -> Int32 {
            try swiftCallbackInterface.`didFinish`(
                    )
            return UNIFFI_CALLBACK_SUCCESS
        }
        return try makeCall()
    }


    switch method {
        case IDX_CALLBACK_FREE:
            FfiConverterCallbackInterfaceSessionVerificationControllerDelegate.drop(handle: handle)
            // Sucessful return
            // See docs of ForeignCallback in `uniffi_core/src/ffi/foreigncallbacks.rs`
            return UNIFFI_CALLBACK_SUCCESS
        case 1:
            let cb: SessionVerificationControllerDelegate
            do {
                cb = try FfiConverterCallbackInterfaceSessionVerificationControllerDelegate.lift(handle)
            } catch {
                out_buf.pointee = FfiConverterString.lower("SessionVerificationControllerDelegate: Invalid handle")
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }
            do {
                return try `invokeDidAcceptVerificationRequest`(cb, argsData, argsLen, out_buf)
            } catch let error {
                out_buf.pointee = FfiConverterString.lower(String(describing: error))
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }
        case 2:
            let cb: SessionVerificationControllerDelegate
            do {
                cb = try FfiConverterCallbackInterfaceSessionVerificationControllerDelegate.lift(handle)
            } catch {
                out_buf.pointee = FfiConverterString.lower("SessionVerificationControllerDelegate: Invalid handle")
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }
            do {
                return try `invokeDidStartSasVerification`(cb, argsData, argsLen, out_buf)
            } catch let error {
                out_buf.pointee = FfiConverterString.lower(String(describing: error))
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }
        case 3:
            let cb: SessionVerificationControllerDelegate
            do {
                cb = try FfiConverterCallbackInterfaceSessionVerificationControllerDelegate.lift(handle)
            } catch {
                out_buf.pointee = FfiConverterString.lower("SessionVerificationControllerDelegate: Invalid handle")
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }
            do {
                return try `invokeDidReceiveVerificationData`(cb, argsData, argsLen, out_buf)
            } catch let error {
                out_buf.pointee = FfiConverterString.lower(String(describing: error))
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }
        case 4:
            let cb: SessionVerificationControllerDelegate
            do {
                cb = try FfiConverterCallbackInterfaceSessionVerificationControllerDelegate.lift(handle)
            } catch {
                out_buf.pointee = FfiConverterString.lower("SessionVerificationControllerDelegate: Invalid handle")
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }
            do {
                return try `invokeDidFail`(cb, argsData, argsLen, out_buf)
            } catch let error {
                out_buf.pointee = FfiConverterString.lower(String(describing: error))
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }
        case 5:
            let cb: SessionVerificationControllerDelegate
            do {
                cb = try FfiConverterCallbackInterfaceSessionVerificationControllerDelegate.lift(handle)
            } catch {
                out_buf.pointee = FfiConverterString.lower("SessionVerificationControllerDelegate: Invalid handle")
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }
            do {
                return try `invokeDidCancel`(cb, argsData, argsLen, out_buf)
            } catch let error {
                out_buf.pointee = FfiConverterString.lower(String(describing: error))
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }
        case 6:
            let cb: SessionVerificationControllerDelegate
            do {
                cb = try FfiConverterCallbackInterfaceSessionVerificationControllerDelegate.lift(handle)
            } catch {
                out_buf.pointee = FfiConverterString.lower("SessionVerificationControllerDelegate: Invalid handle")
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }
            do {
                return try `invokeDidFinish`(cb, argsData, argsLen, out_buf)
            } catch let error {
                out_buf.pointee = FfiConverterString.lower(String(describing: error))
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }
        
        // This should never happen, because an out of bounds method index won't
        // ever be used. Once we can catch errors, we should return an InternalError.
        // https://github.com/mozilla/uniffi-rs/issues/351
        default:
            // An unexpected error happened.
            // See docs of ForeignCallback in `uniffi_core/src/ffi/foreigncallbacks.rs`
            return UNIFFI_CALLBACK_UNEXPECTED_ERROR
    }
}

// FfiConverter protocol for callback interfaces
fileprivate struct FfiConverterCallbackInterfaceSessionVerificationControllerDelegate {
    private static let initCallbackOnce: () = {
        // Swift ensures this initializer code will once run once, even when accessed by multiple threads.
        try! rustCall { (err: UnsafeMutablePointer<RustCallStatus>) in
            ffi_matrix_sdk_ffi_8d0d_SessionVerificationControllerDelegate_init_callback(foreignCallbackCallbackInterfaceSessionVerificationControllerDelegate, err)
        }
    }()

    private static func ensureCallbackinitialized() {
        _ = initCallbackOnce
    }

    static func drop(handle: UniFFICallbackHandle) {
        handleMap.remove(handle: handle)
    }

    private static var handleMap = UniFFICallbackHandleMap<SessionVerificationControllerDelegate>()
}

extension FfiConverterCallbackInterfaceSessionVerificationControllerDelegate : FfiConverter {
    typealias SwiftType = SessionVerificationControllerDelegate
    // We can use Handle as the FfiType because it's a typealias to UInt64
    typealias FfiType = UniFFICallbackHandle

    public static func lift(_ handle: UniFFICallbackHandle) throws -> SwiftType {
        ensureCallbackinitialized();
        guard let callback = handleMap.get(handle: handle) else {
            throw UniffiInternalError.unexpectedStaleHandle
        }
        return callback
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        ensureCallbackinitialized();
        let handle: UniFFICallbackHandle = try readInt(&buf)
        return try lift(handle)
    }

    public static func lower(_ v: SwiftType) -> UniFFICallbackHandle {
        ensureCallbackinitialized();
        return handleMap.insert(obj: v)
    }

    public static func write(_ v: SwiftType, into buf: inout [UInt8]) {
        ensureCallbackinitialized();
        writeInt(&buf, lower(v))
    }
}



// Declaration and FfiConverters for SlidingSyncListRoomItemsObserver Callback Interface

public protocol SlidingSyncListRoomItemsObserver : AnyObject {
    func `didReceiveUpdate`() 
    
}

// The ForeignCallback that is passed to Rust.
fileprivate let foreignCallbackCallbackInterfaceSlidingSyncListRoomItemsObserver : ForeignCallback =
    { (handle: UniFFICallbackHandle, method: Int32, argsData: UnsafePointer<UInt8>, argsLen: Int32, out_buf: UnsafeMutablePointer<RustBuffer>) -> Int32 in
    

    func `invokeDidReceiveUpdate`(_ swiftCallbackInterface: SlidingSyncListRoomItemsObserver, _ argsData: UnsafePointer<UInt8>, _ argsLen: Int32, _ out_buf: UnsafeMutablePointer<RustBuffer>) throws -> Int32 {
        func makeCall() throws -> Int32 {
            try swiftCallbackInterface.`didReceiveUpdate`(
                    )
            return UNIFFI_CALLBACK_SUCCESS
        }
        return try makeCall()
    }


    switch method {
        case IDX_CALLBACK_FREE:
            FfiConverterCallbackInterfaceSlidingSyncListRoomItemsObserver.drop(handle: handle)
            // Sucessful return
            // See docs of ForeignCallback in `uniffi_core/src/ffi/foreigncallbacks.rs`
            return UNIFFI_CALLBACK_SUCCESS
        case 1:
            let cb: SlidingSyncListRoomItemsObserver
            do {
                cb = try FfiConverterCallbackInterfaceSlidingSyncListRoomItemsObserver.lift(handle)
            } catch {
                out_buf.pointee = FfiConverterString.lower("SlidingSyncListRoomItemsObserver: Invalid handle")
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }
            do {
                return try `invokeDidReceiveUpdate`(cb, argsData, argsLen, out_buf)
            } catch let error {
                out_buf.pointee = FfiConverterString.lower(String(describing: error))
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }
        
        // This should never happen, because an out of bounds method index won't
        // ever be used. Once we can catch errors, we should return an InternalError.
        // https://github.com/mozilla/uniffi-rs/issues/351
        default:
            // An unexpected error happened.
            // See docs of ForeignCallback in `uniffi_core/src/ffi/foreigncallbacks.rs`
            return UNIFFI_CALLBACK_UNEXPECTED_ERROR
    }
}

// FfiConverter protocol for callback interfaces
fileprivate struct FfiConverterCallbackInterfaceSlidingSyncListRoomItemsObserver {
    private static let initCallbackOnce: () = {
        // Swift ensures this initializer code will once run once, even when accessed by multiple threads.
        try! rustCall { (err: UnsafeMutablePointer<RustCallStatus>) in
            ffi_matrix_sdk_ffi_8d0d_SlidingSyncListRoomItemsObserver_init_callback(foreignCallbackCallbackInterfaceSlidingSyncListRoomItemsObserver, err)
        }
    }()

    private static func ensureCallbackinitialized() {
        _ = initCallbackOnce
    }

    static func drop(handle: UniFFICallbackHandle) {
        handleMap.remove(handle: handle)
    }

    private static var handleMap = UniFFICallbackHandleMap<SlidingSyncListRoomItemsObserver>()
}

extension FfiConverterCallbackInterfaceSlidingSyncListRoomItemsObserver : FfiConverter {
    typealias SwiftType = SlidingSyncListRoomItemsObserver
    // We can use Handle as the FfiType because it's a typealias to UInt64
    typealias FfiType = UniFFICallbackHandle

    public static func lift(_ handle: UniFFICallbackHandle) throws -> SwiftType {
        ensureCallbackinitialized();
        guard let callback = handleMap.get(handle: handle) else {
            throw UniffiInternalError.unexpectedStaleHandle
        }
        return callback
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        ensureCallbackinitialized();
        let handle: UniFFICallbackHandle = try readInt(&buf)
        return try lift(handle)
    }

    public static func lower(_ v: SwiftType) -> UniFFICallbackHandle {
        ensureCallbackinitialized();
        return handleMap.insert(obj: v)
    }

    public static func write(_ v: SwiftType, into buf: inout [UInt8]) {
        ensureCallbackinitialized();
        writeInt(&buf, lower(v))
    }
}



// Declaration and FfiConverters for SlidingSyncListRoomListObserver Callback Interface

public protocol SlidingSyncListRoomListObserver : AnyObject {
    func `didReceiveUpdate`(`diff`: SlidingSyncListRoomsListDiff) 
    
}

// The ForeignCallback that is passed to Rust.
fileprivate let foreignCallbackCallbackInterfaceSlidingSyncListRoomListObserver : ForeignCallback =
    { (handle: UniFFICallbackHandle, method: Int32, argsData: UnsafePointer<UInt8>, argsLen: Int32, out_buf: UnsafeMutablePointer<RustBuffer>) -> Int32 in
    

    func `invokeDidReceiveUpdate`(_ swiftCallbackInterface: SlidingSyncListRoomListObserver, _ argsData: UnsafePointer<UInt8>, _ argsLen: Int32, _ out_buf: UnsafeMutablePointer<RustBuffer>) throws -> Int32 {
        var reader = createReader(data: Data(bytes: argsData, count: Int(argsLen)))
        func makeCall() throws -> Int32 {
            try swiftCallbackInterface.`didReceiveUpdate`(
                    `diff`:  try FfiConverterTypeSlidingSyncListRoomsListDiff.read(from: &reader)
                    )
            return UNIFFI_CALLBACK_SUCCESS
        }
        return try makeCall()
    }


    switch method {
        case IDX_CALLBACK_FREE:
            FfiConverterCallbackInterfaceSlidingSyncListRoomListObserver.drop(handle: handle)
            // Sucessful return
            // See docs of ForeignCallback in `uniffi_core/src/ffi/foreigncallbacks.rs`
            return UNIFFI_CALLBACK_SUCCESS
        case 1:
            let cb: SlidingSyncListRoomListObserver
            do {
                cb = try FfiConverterCallbackInterfaceSlidingSyncListRoomListObserver.lift(handle)
            } catch {
                out_buf.pointee = FfiConverterString.lower("SlidingSyncListRoomListObserver: Invalid handle")
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }
            do {
                return try `invokeDidReceiveUpdate`(cb, argsData, argsLen, out_buf)
            } catch let error {
                out_buf.pointee = FfiConverterString.lower(String(describing: error))
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }
        
        // This should never happen, because an out of bounds method index won't
        // ever be used. Once we can catch errors, we should return an InternalError.
        // https://github.com/mozilla/uniffi-rs/issues/351
        default:
            // An unexpected error happened.
            // See docs of ForeignCallback in `uniffi_core/src/ffi/foreigncallbacks.rs`
            return UNIFFI_CALLBACK_UNEXPECTED_ERROR
    }
}

// FfiConverter protocol for callback interfaces
fileprivate struct FfiConverterCallbackInterfaceSlidingSyncListRoomListObserver {
    private static let initCallbackOnce: () = {
        // Swift ensures this initializer code will once run once, even when accessed by multiple threads.
        try! rustCall { (err: UnsafeMutablePointer<RustCallStatus>) in
            ffi_matrix_sdk_ffi_8d0d_SlidingSyncListRoomListObserver_init_callback(foreignCallbackCallbackInterfaceSlidingSyncListRoomListObserver, err)
        }
    }()

    private static func ensureCallbackinitialized() {
        _ = initCallbackOnce
    }

    static func drop(handle: UniFFICallbackHandle) {
        handleMap.remove(handle: handle)
    }

    private static var handleMap = UniFFICallbackHandleMap<SlidingSyncListRoomListObserver>()
}

extension FfiConverterCallbackInterfaceSlidingSyncListRoomListObserver : FfiConverter {
    typealias SwiftType = SlidingSyncListRoomListObserver
    // We can use Handle as the FfiType because it's a typealias to UInt64
    typealias FfiType = UniFFICallbackHandle

    public static func lift(_ handle: UniFFICallbackHandle) throws -> SwiftType {
        ensureCallbackinitialized();
        guard let callback = handleMap.get(handle: handle) else {
            throw UniffiInternalError.unexpectedStaleHandle
        }
        return callback
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        ensureCallbackinitialized();
        let handle: UniFFICallbackHandle = try readInt(&buf)
        return try lift(handle)
    }

    public static func lower(_ v: SwiftType) -> UniFFICallbackHandle {
        ensureCallbackinitialized();
        return handleMap.insert(obj: v)
    }

    public static func write(_ v: SwiftType, into buf: inout [UInt8]) {
        ensureCallbackinitialized();
        writeInt(&buf, lower(v))
    }
}



// Declaration and FfiConverters for SlidingSyncListRoomsCountObserver Callback Interface

public protocol SlidingSyncListRoomsCountObserver : AnyObject {
    func `didReceiveUpdate`(`count`: UInt32) 
    
}

// The ForeignCallback that is passed to Rust.
fileprivate let foreignCallbackCallbackInterfaceSlidingSyncListRoomsCountObserver : ForeignCallback =
    { (handle: UniFFICallbackHandle, method: Int32, argsData: UnsafePointer<UInt8>, argsLen: Int32, out_buf: UnsafeMutablePointer<RustBuffer>) -> Int32 in
    

    func `invokeDidReceiveUpdate`(_ swiftCallbackInterface: SlidingSyncListRoomsCountObserver, _ argsData: UnsafePointer<UInt8>, _ argsLen: Int32, _ out_buf: UnsafeMutablePointer<RustBuffer>) throws -> Int32 {
        var reader = createReader(data: Data(bytes: argsData, count: Int(argsLen)))
        func makeCall() throws -> Int32 {
            try swiftCallbackInterface.`didReceiveUpdate`(
                    `count`:  try FfiConverterUInt32.read(from: &reader)
                    )
            return UNIFFI_CALLBACK_SUCCESS
        }
        return try makeCall()
    }


    switch method {
        case IDX_CALLBACK_FREE:
            FfiConverterCallbackInterfaceSlidingSyncListRoomsCountObserver.drop(handle: handle)
            // Sucessful return
            // See docs of ForeignCallback in `uniffi_core/src/ffi/foreigncallbacks.rs`
            return UNIFFI_CALLBACK_SUCCESS
        case 1:
            let cb: SlidingSyncListRoomsCountObserver
            do {
                cb = try FfiConverterCallbackInterfaceSlidingSyncListRoomsCountObserver.lift(handle)
            } catch {
                out_buf.pointee = FfiConverterString.lower("SlidingSyncListRoomsCountObserver: Invalid handle")
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }
            do {
                return try `invokeDidReceiveUpdate`(cb, argsData, argsLen, out_buf)
            } catch let error {
                out_buf.pointee = FfiConverterString.lower(String(describing: error))
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }
        
        // This should never happen, because an out of bounds method index won't
        // ever be used. Once we can catch errors, we should return an InternalError.
        // https://github.com/mozilla/uniffi-rs/issues/351
        default:
            // An unexpected error happened.
            // See docs of ForeignCallback in `uniffi_core/src/ffi/foreigncallbacks.rs`
            return UNIFFI_CALLBACK_UNEXPECTED_ERROR
    }
}

// FfiConverter protocol for callback interfaces
fileprivate struct FfiConverterCallbackInterfaceSlidingSyncListRoomsCountObserver {
    private static let initCallbackOnce: () = {
        // Swift ensures this initializer code will once run once, even when accessed by multiple threads.
        try! rustCall { (err: UnsafeMutablePointer<RustCallStatus>) in
            ffi_matrix_sdk_ffi_8d0d_SlidingSyncListRoomsCountObserver_init_callback(foreignCallbackCallbackInterfaceSlidingSyncListRoomsCountObserver, err)
        }
    }()

    private static func ensureCallbackinitialized() {
        _ = initCallbackOnce
    }

    static func drop(handle: UniFFICallbackHandle) {
        handleMap.remove(handle: handle)
    }

    private static var handleMap = UniFFICallbackHandleMap<SlidingSyncListRoomsCountObserver>()
}

extension FfiConverterCallbackInterfaceSlidingSyncListRoomsCountObserver : FfiConverter {
    typealias SwiftType = SlidingSyncListRoomsCountObserver
    // We can use Handle as the FfiType because it's a typealias to UInt64
    typealias FfiType = UniFFICallbackHandle

    public static func lift(_ handle: UniFFICallbackHandle) throws -> SwiftType {
        ensureCallbackinitialized();
        guard let callback = handleMap.get(handle: handle) else {
            throw UniffiInternalError.unexpectedStaleHandle
        }
        return callback
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        ensureCallbackinitialized();
        let handle: UniFFICallbackHandle = try readInt(&buf)
        return try lift(handle)
    }

    public static func lower(_ v: SwiftType) -> UniFFICallbackHandle {
        ensureCallbackinitialized();
        return handleMap.insert(obj: v)
    }

    public static func write(_ v: SwiftType, into buf: inout [UInt8]) {
        ensureCallbackinitialized();
        writeInt(&buf, lower(v))
    }
}



// Declaration and FfiConverters for SlidingSyncListStateObserver Callback Interface

public protocol SlidingSyncListStateObserver : AnyObject {
    func `didReceiveUpdate`(`newState`: SlidingSyncState) 
    
}

// The ForeignCallback that is passed to Rust.
fileprivate let foreignCallbackCallbackInterfaceSlidingSyncListStateObserver : ForeignCallback =
    { (handle: UniFFICallbackHandle, method: Int32, argsData: UnsafePointer<UInt8>, argsLen: Int32, out_buf: UnsafeMutablePointer<RustBuffer>) -> Int32 in
    

    func `invokeDidReceiveUpdate`(_ swiftCallbackInterface: SlidingSyncListStateObserver, _ argsData: UnsafePointer<UInt8>, _ argsLen: Int32, _ out_buf: UnsafeMutablePointer<RustBuffer>) throws -> Int32 {
        var reader = createReader(data: Data(bytes: argsData, count: Int(argsLen)))
        func makeCall() throws -> Int32 {
            try swiftCallbackInterface.`didReceiveUpdate`(
                    `newState`:  try FfiConverterTypeSlidingSyncState.read(from: &reader)
                    )
            return UNIFFI_CALLBACK_SUCCESS
        }
        return try makeCall()
    }


    switch method {
        case IDX_CALLBACK_FREE:
            FfiConverterCallbackInterfaceSlidingSyncListStateObserver.drop(handle: handle)
            // Sucessful return
            // See docs of ForeignCallback in `uniffi_core/src/ffi/foreigncallbacks.rs`
            return UNIFFI_CALLBACK_SUCCESS
        case 1:
            let cb: SlidingSyncListStateObserver
            do {
                cb = try FfiConverterCallbackInterfaceSlidingSyncListStateObserver.lift(handle)
            } catch {
                out_buf.pointee = FfiConverterString.lower("SlidingSyncListStateObserver: Invalid handle")
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }
            do {
                return try `invokeDidReceiveUpdate`(cb, argsData, argsLen, out_buf)
            } catch let error {
                out_buf.pointee = FfiConverterString.lower(String(describing: error))
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }
        
        // This should never happen, because an out of bounds method index won't
        // ever be used. Once we can catch errors, we should return an InternalError.
        // https://github.com/mozilla/uniffi-rs/issues/351
        default:
            // An unexpected error happened.
            // See docs of ForeignCallback in `uniffi_core/src/ffi/foreigncallbacks.rs`
            return UNIFFI_CALLBACK_UNEXPECTED_ERROR
    }
}

// FfiConverter protocol for callback interfaces
fileprivate struct FfiConverterCallbackInterfaceSlidingSyncListStateObserver {
    private static let initCallbackOnce: () = {
        // Swift ensures this initializer code will once run once, even when accessed by multiple threads.
        try! rustCall { (err: UnsafeMutablePointer<RustCallStatus>) in
            ffi_matrix_sdk_ffi_8d0d_SlidingSyncListStateObserver_init_callback(foreignCallbackCallbackInterfaceSlidingSyncListStateObserver, err)
        }
    }()

    private static func ensureCallbackinitialized() {
        _ = initCallbackOnce
    }

    static func drop(handle: UniFFICallbackHandle) {
        handleMap.remove(handle: handle)
    }

    private static var handleMap = UniFFICallbackHandleMap<SlidingSyncListStateObserver>()
}

extension FfiConverterCallbackInterfaceSlidingSyncListStateObserver : FfiConverter {
    typealias SwiftType = SlidingSyncListStateObserver
    // We can use Handle as the FfiType because it's a typealias to UInt64
    typealias FfiType = UniFFICallbackHandle

    public static func lift(_ handle: UniFFICallbackHandle) throws -> SwiftType {
        ensureCallbackinitialized();
        guard let callback = handleMap.get(handle: handle) else {
            throw UniffiInternalError.unexpectedStaleHandle
        }
        return callback
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        ensureCallbackinitialized();
        let handle: UniFFICallbackHandle = try readInt(&buf)
        return try lift(handle)
    }

    public static func lower(_ v: SwiftType) -> UniFFICallbackHandle {
        ensureCallbackinitialized();
        return handleMap.insert(obj: v)
    }

    public static func write(_ v: SwiftType, into buf: inout [UInt8]) {
        ensureCallbackinitialized();
        writeInt(&buf, lower(v))
    }
}



// Declaration and FfiConverters for SlidingSyncObserver Callback Interface

public protocol SlidingSyncObserver : AnyObject {
    func `didReceiveSyncUpdate`(`summary`: UpdateSummary) 
    
}

// The ForeignCallback that is passed to Rust.
fileprivate let foreignCallbackCallbackInterfaceSlidingSyncObserver : ForeignCallback =
    { (handle: UniFFICallbackHandle, method: Int32, argsData: UnsafePointer<UInt8>, argsLen: Int32, out_buf: UnsafeMutablePointer<RustBuffer>) -> Int32 in
    

    func `invokeDidReceiveSyncUpdate`(_ swiftCallbackInterface: SlidingSyncObserver, _ argsData: UnsafePointer<UInt8>, _ argsLen: Int32, _ out_buf: UnsafeMutablePointer<RustBuffer>) throws -> Int32 {
        var reader = createReader(data: Data(bytes: argsData, count: Int(argsLen)))
        func makeCall() throws -> Int32 {
            try swiftCallbackInterface.`didReceiveSyncUpdate`(
                    `summary`:  try FfiConverterTypeUpdateSummary.read(from: &reader)
                    )
            return UNIFFI_CALLBACK_SUCCESS
        }
        return try makeCall()
    }


    switch method {
        case IDX_CALLBACK_FREE:
            FfiConverterCallbackInterfaceSlidingSyncObserver.drop(handle: handle)
            // Sucessful return
            // See docs of ForeignCallback in `uniffi_core/src/ffi/foreigncallbacks.rs`
            return UNIFFI_CALLBACK_SUCCESS
        case 1:
            let cb: SlidingSyncObserver
            do {
                cb = try FfiConverterCallbackInterfaceSlidingSyncObserver.lift(handle)
            } catch {
                out_buf.pointee = FfiConverterString.lower("SlidingSyncObserver: Invalid handle")
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }
            do {
                return try `invokeDidReceiveSyncUpdate`(cb, argsData, argsLen, out_buf)
            } catch let error {
                out_buf.pointee = FfiConverterString.lower(String(describing: error))
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }
        
        // This should never happen, because an out of bounds method index won't
        // ever be used. Once we can catch errors, we should return an InternalError.
        // https://github.com/mozilla/uniffi-rs/issues/351
        default:
            // An unexpected error happened.
            // See docs of ForeignCallback in `uniffi_core/src/ffi/foreigncallbacks.rs`
            return UNIFFI_CALLBACK_UNEXPECTED_ERROR
    }
}

// FfiConverter protocol for callback interfaces
fileprivate struct FfiConverterCallbackInterfaceSlidingSyncObserver {
    private static let initCallbackOnce: () = {
        // Swift ensures this initializer code will once run once, even when accessed by multiple threads.
        try! rustCall { (err: UnsafeMutablePointer<RustCallStatus>) in
            ffi_matrix_sdk_ffi_8d0d_SlidingSyncObserver_init_callback(foreignCallbackCallbackInterfaceSlidingSyncObserver, err)
        }
    }()

    private static func ensureCallbackinitialized() {
        _ = initCallbackOnce
    }

    static func drop(handle: UniFFICallbackHandle) {
        handleMap.remove(handle: handle)
    }

    private static var handleMap = UniFFICallbackHandleMap<SlidingSyncObserver>()
}

extension FfiConverterCallbackInterfaceSlidingSyncObserver : FfiConverter {
    typealias SwiftType = SlidingSyncObserver
    // We can use Handle as the FfiType because it's a typealias to UInt64
    typealias FfiType = UniFFICallbackHandle

    public static func lift(_ handle: UniFFICallbackHandle) throws -> SwiftType {
        ensureCallbackinitialized();
        guard let callback = handleMap.get(handle: handle) else {
            throw UniffiInternalError.unexpectedStaleHandle
        }
        return callback
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        ensureCallbackinitialized();
        let handle: UniFFICallbackHandle = try readInt(&buf)
        return try lift(handle)
    }

    public static func lower(_ v: SwiftType) -> UniFFICallbackHandle {
        ensureCallbackinitialized();
        return handleMap.insert(obj: v)
    }

    public static func write(_ v: SwiftType, into buf: inout [UInt8]) {
        ensureCallbackinitialized();
        writeInt(&buf, lower(v))
    }
}



// Declaration and FfiConverters for TimelineListener Callback Interface

public protocol TimelineListener : AnyObject {
    func `onUpdate`(`update`: TimelineDiff) 
    
}

// The ForeignCallback that is passed to Rust.
fileprivate let foreignCallbackCallbackInterfaceTimelineListener : ForeignCallback =
    { (handle: UniFFICallbackHandle, method: Int32, argsData: UnsafePointer<UInt8>, argsLen: Int32, out_buf: UnsafeMutablePointer<RustBuffer>) -> Int32 in
    

    func `invokeOnUpdate`(_ swiftCallbackInterface: TimelineListener, _ argsData: UnsafePointer<UInt8>, _ argsLen: Int32, _ out_buf: UnsafeMutablePointer<RustBuffer>) throws -> Int32 {
        var reader = createReader(data: Data(bytes: argsData, count: Int(argsLen)))
        func makeCall() throws -> Int32 {
            try swiftCallbackInterface.`onUpdate`(
                    `update`:  try FfiConverterTypeTimelineDiff.read(from: &reader)
                    )
            return UNIFFI_CALLBACK_SUCCESS
        }
        return try makeCall()
    }


    switch method {
        case IDX_CALLBACK_FREE:
            FfiConverterCallbackInterfaceTimelineListener.drop(handle: handle)
            // Sucessful return
            // See docs of ForeignCallback in `uniffi_core/src/ffi/foreigncallbacks.rs`
            return UNIFFI_CALLBACK_SUCCESS
        case 1:
            let cb: TimelineListener
            do {
                cb = try FfiConverterCallbackInterfaceTimelineListener.lift(handle)
            } catch {
                out_buf.pointee = FfiConverterString.lower("TimelineListener: Invalid handle")
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }
            do {
                return try `invokeOnUpdate`(cb, argsData, argsLen, out_buf)
            } catch let error {
                out_buf.pointee = FfiConverterString.lower(String(describing: error))
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }
        
        // This should never happen, because an out of bounds method index won't
        // ever be used. Once we can catch errors, we should return an InternalError.
        // https://github.com/mozilla/uniffi-rs/issues/351
        default:
            // An unexpected error happened.
            // See docs of ForeignCallback in `uniffi_core/src/ffi/foreigncallbacks.rs`
            return UNIFFI_CALLBACK_UNEXPECTED_ERROR
    }
}

// FfiConverter protocol for callback interfaces
fileprivate struct FfiConverterCallbackInterfaceTimelineListener {
    private static let initCallbackOnce: () = {
        // Swift ensures this initializer code will once run once, even when accessed by multiple threads.
        try! rustCall { (err: UnsafeMutablePointer<RustCallStatus>) in
            ffi_matrix_sdk_ffi_8d0d_TimelineListener_init_callback(foreignCallbackCallbackInterfaceTimelineListener, err)
        }
    }()

    private static func ensureCallbackinitialized() {
        _ = initCallbackOnce
    }

    static func drop(handle: UniFFICallbackHandle) {
        handleMap.remove(handle: handle)
    }

    private static var handleMap = UniFFICallbackHandleMap<TimelineListener>()
}

extension FfiConverterCallbackInterfaceTimelineListener : FfiConverter {
    typealias SwiftType = TimelineListener
    // We can use Handle as the FfiType because it's a typealias to UInt64
    typealias FfiType = UniFFICallbackHandle

    public static func lift(_ handle: UniFFICallbackHandle) throws -> SwiftType {
        ensureCallbackinitialized();
        guard let callback = handleMap.get(handle: handle) else {
            throw UniffiInternalError.unexpectedStaleHandle
        }
        return callback
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        ensureCallbackinitialized();
        let handle: UniFFICallbackHandle = try readInt(&buf)
        return try lift(handle)
    }

    public static func lower(_ v: SwiftType) -> UniFFICallbackHandle {
        ensureCallbackinitialized();
        return handleMap.insert(obj: v)
    }

    public static func write(_ v: SwiftType, into buf: inout [UInt8]) {
        ensureCallbackinitialized();
        writeInt(&buf, lower(v))
    }
}

fileprivate struct FfiConverterOptionUInt32: FfiConverterRustBuffer {
    typealias SwiftType = UInt32?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterUInt32.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterUInt32.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionInt32: FfiConverterRustBuffer {
    typealias SwiftType = Int32?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterInt32.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterInt32.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionUInt64: FfiConverterRustBuffer {
    typealias SwiftType = UInt64?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterUInt64.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterUInt64.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionBool: FfiConverterRustBuffer {
    typealias SwiftType = Bool?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterBool.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterBool.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionString: FfiConverterRustBuffer {
    typealias SwiftType = String?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterString.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterString.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeEventTimelineItem: FfiConverterRustBuffer {
    typealias SwiftType = EventTimelineItem?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeEventTimelineItem.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeEventTimelineItem.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeHomeserverLoginDetails: FfiConverterRustBuffer {
    typealias SwiftType = HomeserverLoginDetails?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeHomeserverLoginDetails.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeHomeserverLoginDetails.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeMediaSource: FfiConverterRustBuffer {
    typealias SwiftType = MediaSource?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeMediaSource.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeMediaSource.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeMessage: FfiConverterRustBuffer {
    typealias SwiftType = Message?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeMessage.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeMessage.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeRoom: FfiConverterRustBuffer {
    typealias SwiftType = Room?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeRoom.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeRoom.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeRoomMember: FfiConverterRustBuffer {
    typealias SwiftType = RoomMember?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeRoomMember.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeRoomMember.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeSlidingSyncList: FfiConverterRustBuffer {
    typealias SwiftType = SlidingSyncList?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeSlidingSyncList.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeSlidingSyncList.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeSlidingSyncRoom: FfiConverterRustBuffer {
    typealias SwiftType = SlidingSyncRoom?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeSlidingSyncRoom.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeSlidingSyncRoom.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeTimelineItem: FfiConverterRustBuffer {
    typealias SwiftType = TimelineItem?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeTimelineItem.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeTimelineItem.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeAudioInfo: FfiConverterRustBuffer {
    typealias SwiftType = AudioInfo?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeAudioInfo.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeAudioInfo.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeFileInfo: FfiConverterRustBuffer {
    typealias SwiftType = FileInfo?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeFileInfo.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeFileInfo.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeFormattedBody: FfiConverterRustBuffer {
    typealias SwiftType = FormattedBody?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeFormattedBody.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeFormattedBody.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeImageInfo: FfiConverterRustBuffer {
    typealias SwiftType = ImageInfo?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeImageInfo.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeImageInfo.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeInReplyToDetails: FfiConverterRustBuffer {
    typealias SwiftType = InReplyToDetails?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeInReplyToDetails.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeInReplyToDetails.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeInsertData: FfiConverterRustBuffer {
    typealias SwiftType = InsertData?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeInsertData.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeInsertData.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeNotificationItem: FfiConverterRustBuffer {
    typealias SwiftType = NotificationItem?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeNotificationItem.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeNotificationItem.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeRoomSubscription: FfiConverterRustBuffer {
    typealias SwiftType = RoomSubscription?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeRoomSubscription.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeRoomSubscription.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeSetData: FfiConverterRustBuffer {
    typealias SwiftType = SetData?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeSetData.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeSetData.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeThumbnailInfo: FfiConverterRustBuffer {
    typealias SwiftType = ThumbnailInfo?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeThumbnailInfo.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeThumbnailInfo.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeVideoInfo: FfiConverterRustBuffer {
    typealias SwiftType = VideoInfo?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeVideoInfo.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeVideoInfo.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeEventSendState: FfiConverterRustBuffer {
    typealias SwiftType = EventSendState?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeEventSendState.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeEventSendState.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeMembershipChange: FfiConverterRustBuffer {
    typealias SwiftType = MembershipChange?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeMembershipChange.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeMembershipChange.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeMessageType: FfiConverterRustBuffer {
    typealias SwiftType = MessageType?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeMessageType.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeMessageType.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypePushFormat: FfiConverterRustBuffer {
    typealias SwiftType = PushFormat?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypePushFormat.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypePushFormat.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeVirtualTimelineItem: FfiConverterRustBuffer {
    typealias SwiftType = VirtualTimelineItem?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeVirtualTimelineItem.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeVirtualTimelineItem.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionCallbackInterfaceClientDelegate: FfiConverterRustBuffer {
    typealias SwiftType = ClientDelegate?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterCallbackInterfaceClientDelegate.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterCallbackInterfaceClientDelegate.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionCallbackInterfaceSessionVerificationControllerDelegate: FfiConverterRustBuffer {
    typealias SwiftType = SessionVerificationControllerDelegate?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterCallbackInterfaceSessionVerificationControllerDelegate.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterCallbackInterfaceSessionVerificationControllerDelegate.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionCallbackInterfaceSlidingSyncObserver: FfiConverterRustBuffer {
    typealias SwiftType = SlidingSyncObserver?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterCallbackInterfaceSlidingSyncObserver.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterCallbackInterfaceSlidingSyncObserver.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionSequenceString: FfiConverterRustBuffer {
    typealias SwiftType = [String]?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterSequenceString.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterSequenceString.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionSequenceTypeTimelineItem: FfiConverterRustBuffer {
    typealias SwiftType = [TimelineItem]?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterSequenceTypeTimelineItem.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterSequenceTypeTimelineItem.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionSequenceTypeReaction: FfiConverterRustBuffer {
    typealias SwiftType = [Reaction]?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterSequenceTypeReaction.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterSequenceTypeReaction.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionSequenceTypeRequiredState: FfiConverterRustBuffer {
    typealias SwiftType = [RequiredState]?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterSequenceTypeRequiredState.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterSequenceTypeRequiredState.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterSequenceUInt8: FfiConverterRustBuffer {
    typealias SwiftType = [UInt8]

    public static func write(_ value: [UInt8], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterUInt8.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [UInt8] {
        let len: Int32 = try readInt(&buf)
        var seq = [UInt8]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterUInt8.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceString: FfiConverterRustBuffer {
    typealias SwiftType = [String]

    public static func write(_ value: [String], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterString.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String] {
        let len: Int32 = try readInt(&buf)
        var seq = [String]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterString.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeRoom: FfiConverterRustBuffer {
    typealias SwiftType = [Room]

    public static func write(_ value: [Room], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeRoom.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Room] {
        let len: Int32 = try readInt(&buf)
        var seq = [Room]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeRoom.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeRoomMember: FfiConverterRustBuffer {
    typealias SwiftType = [RoomMember]

    public static func write(_ value: [RoomMember], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeRoomMember.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [RoomMember] {
        let len: Int32 = try readInt(&buf)
        var seq = [RoomMember]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeRoomMember.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeSessionVerificationEmoji: FfiConverterRustBuffer {
    typealias SwiftType = [SessionVerificationEmoji]

    public static func write(_ value: [SessionVerificationEmoji], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeSessionVerificationEmoji.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [SessionVerificationEmoji] {
        let len: Int32 = try readInt(&buf)
        var seq = [SessionVerificationEmoji]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeSessionVerificationEmoji.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeTimelineItem: FfiConverterRustBuffer {
    typealias SwiftType = [TimelineItem]

    public static func write(_ value: [TimelineItem], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeTimelineItem.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [TimelineItem] {
        let len: Int32 = try readInt(&buf)
        var seq = [TimelineItem]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeTimelineItem.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeReaction: FfiConverterRustBuffer {
    typealias SwiftType = [Reaction]

    public static func write(_ value: [Reaction], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeReaction.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Reaction] {
        let len: Int32 = try readInt(&buf)
        var seq = [Reaction]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeReaction.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeRequiredState: FfiConverterRustBuffer {
    typealias SwiftType = [RequiredState]

    public static func write(_ value: [RequiredState], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeRequiredState.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [RequiredState] {
        let len: Int32 = try readInt(&buf)
        var seq = [RequiredState]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeRequiredState.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeUserProfile: FfiConverterRustBuffer {
    typealias SwiftType = [UserProfile]

    public static func write(_ value: [UserProfile], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeUserProfile.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [UserProfile] {
        let len: Int32 = try readInt(&buf)
        var seq = [UserProfile]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeUserProfile.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeRoomListEntry: FfiConverterRustBuffer {
    typealias SwiftType = [RoomListEntry]

    public static func write(_ value: [RoomListEntry], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeRoomListEntry.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [RoomListEntry] {
        let len: Int32 = try readInt(&buf)
        var seq = [RoomListEntry]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeRoomListEntry.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceOptionTypeSlidingSyncRoom: FfiConverterRustBuffer {
    typealias SwiftType = [SlidingSyncRoom?]

    public static func write(_ value: [SlidingSyncRoom?], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterOptionTypeSlidingSyncRoom.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [SlidingSyncRoom?] {
        let len: Int32 = try readInt(&buf)
        var seq = [SlidingSyncRoom?]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterOptionTypeSlidingSyncRoom.read(from: &buf))
        }
        return seq
    }
}

public func `genTransactionId`()  -> String {
    return try!  FfiConverterString.lift(
        try! rustCall() {
    _uniffi_matrix_sdk_ffi_gen_transaction_id_4593($0)
}
    )
}

public func `mediaSourceFromUrl`(`url`: String)  -> MediaSource {
    return try!  FfiConverterTypeMediaSource.lift(
        try! rustCall() {
    _uniffi_matrix_sdk_ffi_media_source_from_url_3a26(
        FfiConverterString.lower(`url`), $0)
}
    )
}

public func `messageEventContentFromMarkdown`(`md`: String)  -> RoomMessageEventContent {
    return try!  FfiConverterTypeRoomMessageEventContent.lift(
        try! rustCall() {
    _uniffi_matrix_sdk_ffi_message_event_content_from_markdown_df5b(
        FfiConverterString.lower(`md`), $0)
}
    )
}

public func `setupOtlpTracing`(`filter`: String, `clientName`: String, `user`: String, `password`: String, `otlpEndpoint`: String)  {
    try! rustCall() {
    _uniffi_matrix_sdk_ffi_setup_otlp_tracing_5801(
        FfiConverterString.lower(`filter`), 
        FfiConverterString.lower(`clientName`), 
        FfiConverterString.lower(`user`), 
        FfiConverterString.lower(`password`), 
        FfiConverterString.lower(`otlpEndpoint`), $0)
}
}



public func `setupTracing`(`filter`: String)  {
    try! rustCall() {
    _uniffi_matrix_sdk_ffi_setup_tracing_ac08(
        FfiConverterString.lower(`filter`), $0)
}
}



/**
 * Top level initializers and tear down methods.
 *
 * This is generated by uniffi.
 */
public enum MatrixSdkFfiLifecycle {
    /**
     * Initialize the FFI and Rust library. This should be only called once per application.
     */
    func initialize() {
    }
}