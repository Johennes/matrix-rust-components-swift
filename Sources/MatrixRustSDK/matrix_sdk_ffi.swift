// This file was autogenerated by some hot garbage in the `uniffi` crate.
// Trust me, you don't want to mess with it!
import Foundation

// Depending on the consumer's build setup, the low-level FFI code
// might be in a separate module, or it might be compiled inline into
// this module. This is a bit of light hackery to work with both.
#if canImport(matrix_sdk_ffiFFI)
import matrix_sdk_ffiFFI
#endif

fileprivate extension RustBuffer {
    // Allocate a new buffer, copying the contents of a `UInt8` array.
    init(bytes: [UInt8]) {
        let rbuf = bytes.withUnsafeBufferPointer { ptr in
            RustBuffer.from(ptr)
        }
        self.init(capacity: rbuf.capacity, len: rbuf.len, data: rbuf.data)
    }

    static func from(_ ptr: UnsafeBufferPointer<UInt8>) -> RustBuffer {
        try! rustCall { ffi_matrix_sdk_ffi_rustbuffer_from_bytes(ForeignBytes(bufferPointer: ptr), $0) }
    }

    // Frees the buffer in place.
    // The buffer must not be used after this is called.
    func deallocate() {
        try! rustCall { ffi_matrix_sdk_ffi_rustbuffer_free(self, $0) }
    }
}

fileprivate extension ForeignBytes {
    init(bufferPointer: UnsafeBufferPointer<UInt8>) {
        self.init(len: Int32(bufferPointer.count), data: bufferPointer.baseAddress)
    }
}

// For every type used in the interface, we provide helper methods for conveniently
// lifting and lowering that type from C-compatible data, and for reading and writing
// values of that type in a buffer.

// Helper classes/extensions that don't change.
// Someday, this will be in a library of its own.

fileprivate extension Data {
    init(rustBuffer: RustBuffer) {
        // TODO: This copies the buffer. Can we read directly from a
        // Rust buffer?
        self.init(bytes: rustBuffer.data!, count: Int(rustBuffer.len))
    }
}

// Define reader functionality.  Normally this would be defined in a class or
// struct, but we use standalone functions instead in order to make external
// types work.
//
// With external types, one swift source file needs to be able to call the read
// method on another source file's FfiConverter, but then what visibility
// should Reader have?
// - If Reader is fileprivate, then this means the read() must also
//   be fileprivate, which doesn't work with external types.
// - If Reader is internal/public, we'll get compile errors since both source
//   files will try define the same type.
//
// Instead, the read() method and these helper functions input a tuple of data

fileprivate func createReader(data: Data) -> (data: Data, offset: Data.Index) {
    (data: data, offset: 0)
}

// Reads an integer at the current offset, in big-endian order, and advances
// the offset on success. Throws if reading the integer would move the
// offset past the end of the buffer.
fileprivate func readInt<T: FixedWidthInteger>(_ reader: inout (data: Data, offset: Data.Index)) throws -> T {
    let range = reader.offset..<reader.offset + MemoryLayout<T>.size
    guard reader.data.count >= range.upperBound else {
        throw UniffiInternalError.bufferOverflow
    }
    if T.self == UInt8.self {
        let value = reader.data[reader.offset]
        reader.offset += 1
        return value as! T
    }
    var value: T = 0
    let _ = withUnsafeMutableBytes(of: &value, { reader.data.copyBytes(to: $0, from: range)})
    reader.offset = range.upperBound
    return value.bigEndian
}

// Reads an arbitrary number of bytes, to be used to read
// raw bytes, this is useful when lifting strings
fileprivate func readBytes(_ reader: inout (data: Data, offset: Data.Index), count: Int) throws -> Array<UInt8> {
    let range = reader.offset..<(reader.offset+count)
    guard reader.data.count >= range.upperBound else {
        throw UniffiInternalError.bufferOverflow
    }
    var value = [UInt8](repeating: 0, count: count)
    value.withUnsafeMutableBufferPointer({ buffer in
        reader.data.copyBytes(to: buffer, from: range)
    })
    reader.offset = range.upperBound
    return value
}

// Reads a float at the current offset.
fileprivate func readFloat(_ reader: inout (data: Data, offset: Data.Index)) throws -> Float {
    return Float(bitPattern: try readInt(&reader))
}

// Reads a float at the current offset.
fileprivate func readDouble(_ reader: inout (data: Data, offset: Data.Index)) throws -> Double {
    return Double(bitPattern: try readInt(&reader))
}

// Indicates if the offset has reached the end of the buffer.
fileprivate func hasRemaining(_ reader: (data: Data, offset: Data.Index)) -> Bool {
    return reader.offset < reader.data.count
}

// Define writer functionality.  Normally this would be defined in a class or
// struct, but we use standalone functions instead in order to make external
// types work.  See the above discussion on Readers for details.

fileprivate func createWriter() -> [UInt8] {
    return []
}

fileprivate func writeBytes<S>(_ writer: inout [UInt8], _ byteArr: S) where S: Sequence, S.Element == UInt8 {
    writer.append(contentsOf: byteArr)
}

// Writes an integer in big-endian order.
//
// Warning: make sure what you are trying to write
// is in the correct type!
fileprivate func writeInt<T: FixedWidthInteger>(_ writer: inout [UInt8], _ value: T) {
    var value = value.bigEndian
    withUnsafeBytes(of: &value) { writer.append(contentsOf: $0) }
}

fileprivate func writeFloat(_ writer: inout [UInt8], _ value: Float) {
    writeInt(&writer, value.bitPattern)
}

fileprivate func writeDouble(_ writer: inout [UInt8], _ value: Double) {
    writeInt(&writer, value.bitPattern)
}

// Protocol for types that transfer other types across the FFI. This is
// analogous go the Rust trait of the same name.
fileprivate protocol FfiConverter {
    associatedtype FfiType
    associatedtype SwiftType

    static func lift(_ value: FfiType) throws -> SwiftType
    static func lower(_ value: SwiftType) -> FfiType
    static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType
    static func write(_ value: SwiftType, into buf: inout [UInt8])
}

// Types conforming to `Primitive` pass themselves directly over the FFI.
fileprivate protocol FfiConverterPrimitive: FfiConverter where FfiType == SwiftType { }

extension FfiConverterPrimitive {
    public static func lift(_ value: FfiType) throws -> SwiftType {
        return value
    }

    public static func lower(_ value: SwiftType) -> FfiType {
        return value
    }
}

// Types conforming to `FfiConverterRustBuffer` lift and lower into a `RustBuffer`.
// Used for complex types where it's hard to write a custom lift/lower.
fileprivate protocol FfiConverterRustBuffer: FfiConverter where FfiType == RustBuffer {}

extension FfiConverterRustBuffer {
    public static func lift(_ buf: RustBuffer) throws -> SwiftType {
        var reader = createReader(data: Data(rustBuffer: buf))
        let value = try read(from: &reader)
        if hasRemaining(reader) {
            throw UniffiInternalError.incompleteData
        }
        buf.deallocate()
        return value
    }

    public static func lower(_ value: SwiftType) -> RustBuffer {
          var writer = createWriter()
          write(value, into: &writer)
          return RustBuffer(bytes: writer)
    }
}
// An error type for FFI errors. These errors occur at the UniFFI level, not
// the library level.
fileprivate enum UniffiInternalError: LocalizedError {
    case bufferOverflow
    case incompleteData
    case unexpectedOptionalTag
    case unexpectedEnumCase
    case unexpectedNullPointer
    case unexpectedRustCallStatusCode
    case unexpectedRustCallError
    case unexpectedStaleHandle
    case rustPanic(_ message: String)

    public var errorDescription: String? {
        switch self {
        case .bufferOverflow: return "Reading the requested value would read past the end of the buffer"
        case .incompleteData: return "The buffer still has data after lifting its containing value"
        case .unexpectedOptionalTag: return "Unexpected optional tag; should be 0 or 1"
        case .unexpectedEnumCase: return "Raw enum value doesn't match any cases"
        case .unexpectedNullPointer: return "Raw pointer value was null"
        case .unexpectedRustCallStatusCode: return "Unexpected RustCallStatus code"
        case .unexpectedRustCallError: return "CALL_ERROR but no errorClass specified"
        case .unexpectedStaleHandle: return "The object in the handle map has been dropped already"
        case let .rustPanic(message): return message
        }
    }
}

fileprivate let CALL_SUCCESS: Int8 = 0
fileprivate let CALL_ERROR: Int8 = 1
fileprivate let CALL_PANIC: Int8 = 2

fileprivate extension RustCallStatus {
    init() {
        self.init(
            code: CALL_SUCCESS,
            errorBuf: RustBuffer.init(
                capacity: 0,
                len: 0,
                data: nil
            )
        )
    }
}

private func rustCall<T>(_ callback: (UnsafeMutablePointer<RustCallStatus>) -> T) throws -> T {
    try makeRustCall(callback, errorHandler: nil)
}

private func rustCallWithError<T>(
    _ errorHandler: @escaping (RustBuffer) throws -> Error,
    _ callback: (UnsafeMutablePointer<RustCallStatus>) -> T) throws -> T {
    try makeRustCall(callback, errorHandler: errorHandler)
}

private func makeRustCall<T>(
    _ callback: (UnsafeMutablePointer<RustCallStatus>) -> T,
    errorHandler: ((RustBuffer) throws -> Error)?
) throws -> T {
    uniffiEnsureInitialized()
    var callStatus = RustCallStatus.init()
    let returnedVal = callback(&callStatus)
    try uniffiCheckCallStatus(callStatus: callStatus, errorHandler: errorHandler)
    return returnedVal
}

private func uniffiCheckCallStatus(
    callStatus: RustCallStatus,
    errorHandler: ((RustBuffer) throws -> Error)?
) throws {
    switch callStatus.code {
        case CALL_SUCCESS:
            return

        case CALL_ERROR:
            if let errorHandler = errorHandler {
                throw try errorHandler(callStatus.errorBuf)
            } else {
                callStatus.errorBuf.deallocate()
                throw UniffiInternalError.unexpectedRustCallError
            }

        case CALL_PANIC:
            // When the rust code sees a panic, it tries to construct a RustBuffer
            // with the message.  But if that code panics, then it just sends back
            // an empty buffer.
            if callStatus.errorBuf.len > 0 {
                throw UniffiInternalError.rustPanic(try FfiConverterString.lift(callStatus.errorBuf))
            } else {
                callStatus.errorBuf.deallocate()
                throw UniffiInternalError.rustPanic("Rust panic")
            }

        default:
            throw UniffiInternalError.unexpectedRustCallStatusCode
    }
}

// Public interface members begin here.


fileprivate struct FfiConverterUInt8: FfiConverterPrimitive {
    typealias FfiType = UInt8
    typealias SwiftType = UInt8

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt8 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: UInt8, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

fileprivate struct FfiConverterUInt16: FfiConverterPrimitive {
    typealias FfiType = UInt16
    typealias SwiftType = UInt16

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt16 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

fileprivate struct FfiConverterUInt32: FfiConverterPrimitive {
    typealias FfiType = UInt32
    typealias SwiftType = UInt32

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt32 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

fileprivate struct FfiConverterInt32: FfiConverterPrimitive {
    typealias FfiType = Int32
    typealias SwiftType = Int32

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Int32 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: Int32, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

fileprivate struct FfiConverterUInt64: FfiConverterPrimitive {
    typealias FfiType = UInt64
    typealias SwiftType = UInt64

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt64 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

fileprivate struct FfiConverterInt64: FfiConverterPrimitive {
    typealias FfiType = Int64
    typealias SwiftType = Int64

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Int64 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: Int64, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

fileprivate struct FfiConverterBool : FfiConverter {
    typealias FfiType = Int8
    typealias SwiftType = Bool

    public static func lift(_ value: Int8) throws -> Bool {
        return value != 0
    }

    public static func lower(_ value: Bool) -> Int8 {
        return value ? 1 : 0
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Bool {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: Bool, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

fileprivate struct FfiConverterString: FfiConverter {
    typealias SwiftType = String
    typealias FfiType = RustBuffer

    public static func lift(_ value: RustBuffer) throws -> String {
        defer {
            value.deallocate()
        }
        if value.data == nil {
            return String()
        }
        let bytes = UnsafeBufferPointer<UInt8>(start: value.data!, count: Int(value.len))
        return String(bytes: bytes, encoding: String.Encoding.utf8)!
    }

    public static func lower(_ value: String) -> RustBuffer {
        return value.utf8CString.withUnsafeBufferPointer { ptr in
            // The swift string gives us int8_t, we want uint8_t.
            ptr.withMemoryRebound(to: UInt8.self) { ptr in
                // The swift string gives us a trailing null byte, we don't want it.
                let buf = UnsafeBufferPointer(rebasing: ptr.prefix(upTo: ptr.count - 1))
                return RustBuffer.from(buf)
            }
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> String {
        let len: Int32 = try readInt(&buf)
        return String(bytes: try readBytes(&buf, count: Int(len)), encoding: String.Encoding.utf8)!
    }

    public static func write(_ value: String, into buf: inout [UInt8]) {
        let len = Int32(value.utf8.count)
        writeInt(&buf, len)
        writeBytes(&buf, value.utf8)
    }
}

fileprivate struct FfiConverterDuration: FfiConverterRustBuffer {
    typealias SwiftType = TimeInterval

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TimeInterval {
        let seconds: UInt64 = try readInt(&buf)
        let nanoseconds: UInt32 = try readInt(&buf)
        return Double(seconds) + (Double(nanoseconds) / 1.0e9)
    }

    public static func write(_ value: TimeInterval, into buf: inout [UInt8]) {
        if value.rounded(.down) > Double(Int64.max) {
            fatalError("Duration overflow, exceeds max bounds supported by Uniffi")
        }

        if value < 0 {
            fatalError("Invalid duration, must be non-negative")
        }

        let seconds = UInt64(value)
        let nanoseconds = UInt32((value - Double(seconds)) * 1.0e9)
        writeInt(&buf, seconds)
        writeInt(&buf, nanoseconds)
    }
}


public protocol AuthenticationServiceProtocol {
    func configureHomeserver(serverNameOrHomeserverUrl: String)  throws
    func homeserverDetails()   -> HomeserverLoginDetails?
    func login(username: String, password: String, initialDeviceName: String?, deviceId: String?)  throws -> Client
    func loginWithOidcCallback(authenticationData: OidcAuthenticationData, callbackUrl: String)  throws -> Client
    func urlForOidcLogin()  throws -> OidcAuthenticationData
    
}

public class AuthenticationService: AuthenticationServiceProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }
    public convenience init(basePath: String, passphrase: String?, userAgent: String?, oidcConfiguration: OidcConfiguration?, customSlidingSyncProxy: String?)  {
        self.init(unsafeFromRawPointer: try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_constructor_authenticationservice_new(
        FfiConverterString.lower(basePath),
        FfiConverterOptionString.lower(passphrase),
        FfiConverterOptionString.lower(userAgent),
        FfiConverterOptionTypeOidcConfiguration.lower(oidcConfiguration),
        FfiConverterOptionString.lower(customSlidingSyncProxy),$0)
})
    }

    deinit {
        try! rustCall { uniffi_matrix_sdk_ffi_fn_free_authenticationservice(pointer, $0) }
    }

    

    
    

    public func configureHomeserver(serverNameOrHomeserverUrl: String) throws {
        try 
    rustCallWithError(FfiConverterTypeAuthenticationError.lift) {
    uniffi_matrix_sdk_ffi_fn_method_authenticationservice_configure_homeserver(self.pointer, 
        FfiConverterString.lower(serverNameOrHomeserverUrl),$0
    )
}
    }

    public func homeserverDetails()  -> HomeserverLoginDetails? {
        return try!  FfiConverterOptionTypeHomeserverLoginDetails.lift(
            try! 
    rustCall() {
    
    uniffi_matrix_sdk_ffi_fn_method_authenticationservice_homeserver_details(self.pointer, $0
    )
}
        )
    }

    public func login(username: String, password: String, initialDeviceName: String?, deviceId: String?) throws -> Client {
        return try  FfiConverterTypeClient.lift(
            try 
    rustCallWithError(FfiConverterTypeAuthenticationError.lift) {
    uniffi_matrix_sdk_ffi_fn_method_authenticationservice_login(self.pointer, 
        FfiConverterString.lower(username),
        FfiConverterString.lower(password),
        FfiConverterOptionString.lower(initialDeviceName),
        FfiConverterOptionString.lower(deviceId),$0
    )
}
        )
    }

    public func loginWithOidcCallback(authenticationData: OidcAuthenticationData, callbackUrl: String) throws -> Client {
        return try  FfiConverterTypeClient.lift(
            try 
    rustCallWithError(FfiConverterTypeAuthenticationError.lift) {
    uniffi_matrix_sdk_ffi_fn_method_authenticationservice_login_with_oidc_callback(self.pointer, 
        FfiConverterTypeOidcAuthenticationData.lower(authenticationData),
        FfiConverterString.lower(callbackUrl),$0
    )
}
        )
    }

    public func urlForOidcLogin() throws -> OidcAuthenticationData {
        return try  FfiConverterTypeOidcAuthenticationData.lift(
            try 
    rustCallWithError(FfiConverterTypeAuthenticationError.lift) {
    uniffi_matrix_sdk_ffi_fn_method_authenticationservice_url_for_oidc_login(self.pointer, $0
    )
}
        )
    }
}

public struct FfiConverterTypeAuthenticationService: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = AuthenticationService

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AuthenticationService {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: AuthenticationService, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> AuthenticationService {
        return AuthenticationService(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: AuthenticationService) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}


public func FfiConverterTypeAuthenticationService_lift(_ pointer: UnsafeMutableRawPointer) throws -> AuthenticationService {
    return try FfiConverterTypeAuthenticationService.lift(pointer)
}

public func FfiConverterTypeAuthenticationService_lower(_ value: AuthenticationService) -> UnsafeMutableRawPointer {
    return FfiConverterTypeAuthenticationService.lower(value)
}


public protocol ClientProtocol {
    func accountData(eventType: String)  throws -> String?
    func accountUrl()   -> String?
    func avatarUrl()  throws -> String?
    func cachedAvatarUrl()  throws -> String?
    func createRoom(request: CreateRoomParameters)  throws -> String
    func deviceId()  throws -> String
    func displayName()  throws -> String
    func getDmRoom(userId: String)  throws -> Room?
    func getMediaContent(mediaSource: MediaSource)  throws -> [UInt8]
    func getMediaFile(mediaSource: MediaSource, body: String?, mimeType: String, tempDir: String?)  throws -> MediaFileHandle
    func getMediaThumbnail(mediaSource: MediaSource, width: UInt64, height: UInt64)  throws -> [UInt8]
    func getNotificationSettings()   -> NotificationSettings
    func getProfile(userId: String)  throws -> UserProfile
    func getSessionVerificationController()  throws -> SessionVerificationController
    func homeserver()   -> String
    func ignoreUser(userId: String)  throws
    func login(username: String, password: String, initialDeviceName: String?, deviceId: String?)  throws
    func logout()  throws -> String?
    func notificationClient()  throws -> NotificationClientBuilder
    func restoreSession(session: Session)  throws
    func rooms()   -> [Room]
    func searchUsers(searchTerm: String, limit: UInt64)  throws -> SearchUsersResults
    func session()  throws -> Session
    func setAccountData(eventType: String, content: String)  throws
    func setDelegate(delegate: ClientDelegate?)  
    func setDisplayName(name: String)  throws
    func setPusher(identifiers: PusherIdentifiers, kind: PusherKind, appDisplayName: String, deviceDisplayName: String, profileTag: String?, lang: String)  throws
    func syncService()   -> SyncServiceBuilder
    func unignoreUser(userId: String)  throws
    func uploadMedia(mimeType: String, data: [UInt8], progressWatcher: ProgressWatcher?)  throws -> String
    func userId()  throws -> String
    
}

public class Client: ClientProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { uniffi_matrix_sdk_ffi_fn_free_client(pointer, $0) }
    }

    

    
    

    public func accountData(eventType: String) throws -> String? {
        return try  FfiConverterOptionString.lift(
            try 
    rustCallWithError(FfiConverterTypeClientError.lift) {
    uniffi_matrix_sdk_ffi_fn_method_client_account_data(self.pointer, 
        FfiConverterString.lower(eventType),$0
    )
}
        )
    }

    public func accountUrl()  -> String? {
        return try!  FfiConverterOptionString.lift(
            try! 
    rustCall() {
    
    uniffi_matrix_sdk_ffi_fn_method_client_account_url(self.pointer, $0
    )
}
        )
    }

    public func avatarUrl() throws -> String? {
        return try  FfiConverterOptionString.lift(
            try 
    rustCallWithError(FfiConverterTypeClientError.lift) {
    uniffi_matrix_sdk_ffi_fn_method_client_avatar_url(self.pointer, $0
    )
}
        )
    }

    public func cachedAvatarUrl() throws -> String? {
        return try  FfiConverterOptionString.lift(
            try 
    rustCallWithError(FfiConverterTypeClientError.lift) {
    uniffi_matrix_sdk_ffi_fn_method_client_cached_avatar_url(self.pointer, $0
    )
}
        )
    }

    public func createRoom(request: CreateRoomParameters) throws -> String {
        return try  FfiConverterString.lift(
            try 
    rustCallWithError(FfiConverterTypeClientError.lift) {
    uniffi_matrix_sdk_ffi_fn_method_client_create_room(self.pointer, 
        FfiConverterTypeCreateRoomParameters.lower(request),$0
    )
}
        )
    }

    public func deviceId() throws -> String {
        return try  FfiConverterString.lift(
            try 
    rustCallWithError(FfiConverterTypeClientError.lift) {
    uniffi_matrix_sdk_ffi_fn_method_client_device_id(self.pointer, $0
    )
}
        )
    }

    public func displayName() throws -> String {
        return try  FfiConverterString.lift(
            try 
    rustCallWithError(FfiConverterTypeClientError.lift) {
    uniffi_matrix_sdk_ffi_fn_method_client_display_name(self.pointer, $0
    )
}
        )
    }

    public func getDmRoom(userId: String) throws -> Room? {
        return try  FfiConverterOptionTypeRoom.lift(
            try 
    rustCallWithError(FfiConverterTypeClientError.lift) {
    uniffi_matrix_sdk_ffi_fn_method_client_get_dm_room(self.pointer, 
        FfiConverterString.lower(userId),$0
    )
}
        )
    }

    public func getMediaContent(mediaSource: MediaSource) throws -> [UInt8] {
        return try  FfiConverterSequenceUInt8.lift(
            try 
    rustCallWithError(FfiConverterTypeClientError.lift) {
    uniffi_matrix_sdk_ffi_fn_method_client_get_media_content(self.pointer, 
        FfiConverterTypeMediaSource.lower(mediaSource),$0
    )
}
        )
    }

    public func getMediaFile(mediaSource: MediaSource, body: String?, mimeType: String, tempDir: String?) throws -> MediaFileHandle {
        return try  FfiConverterTypeMediaFileHandle.lift(
            try 
    rustCallWithError(FfiConverterTypeClientError.lift) {
    uniffi_matrix_sdk_ffi_fn_method_client_get_media_file(self.pointer, 
        FfiConverterTypeMediaSource.lower(mediaSource),
        FfiConverterOptionString.lower(body),
        FfiConverterString.lower(mimeType),
        FfiConverterOptionString.lower(tempDir),$0
    )
}
        )
    }

    public func getMediaThumbnail(mediaSource: MediaSource, width: UInt64, height: UInt64) throws -> [UInt8] {
        return try  FfiConverterSequenceUInt8.lift(
            try 
    rustCallWithError(FfiConverterTypeClientError.lift) {
    uniffi_matrix_sdk_ffi_fn_method_client_get_media_thumbnail(self.pointer, 
        FfiConverterTypeMediaSource.lower(mediaSource),
        FfiConverterUInt64.lower(width),
        FfiConverterUInt64.lower(height),$0
    )
}
        )
    }

    public func getNotificationSettings()  -> NotificationSettings {
        return try!  FfiConverterTypeNotificationSettings.lift(
            try! 
    rustCall() {
    
    uniffi_matrix_sdk_ffi_fn_method_client_get_notification_settings(self.pointer, $0
    )
}
        )
    }

    public func getProfile(userId: String) throws -> UserProfile {
        return try  FfiConverterTypeUserProfile.lift(
            try 
    rustCallWithError(FfiConverterTypeClientError.lift) {
    uniffi_matrix_sdk_ffi_fn_method_client_get_profile(self.pointer, 
        FfiConverterString.lower(userId),$0
    )
}
        )
    }

    public func getSessionVerificationController() throws -> SessionVerificationController {
        return try  FfiConverterTypeSessionVerificationController.lift(
            try 
    rustCallWithError(FfiConverterTypeClientError.lift) {
    uniffi_matrix_sdk_ffi_fn_method_client_get_session_verification_controller(self.pointer, $0
    )
}
        )
    }

    public func homeserver()  -> String {
        return try!  FfiConverterString.lift(
            try! 
    rustCall() {
    
    uniffi_matrix_sdk_ffi_fn_method_client_homeserver(self.pointer, $0
    )
}
        )
    }

    public func ignoreUser(userId: String) throws {
        try 
    rustCallWithError(FfiConverterTypeClientError.lift) {
    uniffi_matrix_sdk_ffi_fn_method_client_ignore_user(self.pointer, 
        FfiConverterString.lower(userId),$0
    )
}
    }

    public func login(username: String, password: String, initialDeviceName: String?, deviceId: String?) throws {
        try 
    rustCallWithError(FfiConverterTypeClientError.lift) {
    uniffi_matrix_sdk_ffi_fn_method_client_login(self.pointer, 
        FfiConverterString.lower(username),
        FfiConverterString.lower(password),
        FfiConverterOptionString.lower(initialDeviceName),
        FfiConverterOptionString.lower(deviceId),$0
    )
}
    }

    public func logout() throws -> String? {
        return try  FfiConverterOptionString.lift(
            try 
    rustCallWithError(FfiConverterTypeClientError.lift) {
    uniffi_matrix_sdk_ffi_fn_method_client_logout(self.pointer, $0
    )
}
        )
    }

    public func notificationClient() throws -> NotificationClientBuilder {
        return try  FfiConverterTypeNotificationClientBuilder.lift(
            try 
    rustCallWithError(FfiConverterTypeClientError.lift) {
    uniffi_matrix_sdk_ffi_fn_method_client_notification_client(self.pointer, $0
    )
}
        )
    }

    public func restoreSession(session: Session) throws {
        try 
    rustCallWithError(FfiConverterTypeClientError.lift) {
    uniffi_matrix_sdk_ffi_fn_method_client_restore_session(self.pointer, 
        FfiConverterTypeSession.lower(session),$0
    )
}
    }

    public func rooms()  -> [Room] {
        return try!  FfiConverterSequenceTypeRoom.lift(
            try! 
    rustCall() {
    
    uniffi_matrix_sdk_ffi_fn_method_client_rooms(self.pointer, $0
    )
}
        )
    }

    public func searchUsers(searchTerm: String, limit: UInt64) throws -> SearchUsersResults {
        return try  FfiConverterTypeSearchUsersResults.lift(
            try 
    rustCallWithError(FfiConverterTypeClientError.lift) {
    uniffi_matrix_sdk_ffi_fn_method_client_search_users(self.pointer, 
        FfiConverterString.lower(searchTerm),
        FfiConverterUInt64.lower(limit),$0
    )
}
        )
    }

    public func session() throws -> Session {
        return try  FfiConverterTypeSession.lift(
            try 
    rustCallWithError(FfiConverterTypeClientError.lift) {
    uniffi_matrix_sdk_ffi_fn_method_client_session(self.pointer, $0
    )
}
        )
    }

    public func setAccountData(eventType: String, content: String) throws {
        try 
    rustCallWithError(FfiConverterTypeClientError.lift) {
    uniffi_matrix_sdk_ffi_fn_method_client_set_account_data(self.pointer, 
        FfiConverterString.lower(eventType),
        FfiConverterString.lower(content),$0
    )
}
    }

    public func setDelegate(delegate: ClientDelegate?)  {
        try! 
    rustCall() {
    
    uniffi_matrix_sdk_ffi_fn_method_client_set_delegate(self.pointer, 
        FfiConverterOptionCallbackInterfaceClientDelegate.lower(delegate),$0
    )
}
    }

    public func setDisplayName(name: String) throws {
        try 
    rustCallWithError(FfiConverterTypeClientError.lift) {
    uniffi_matrix_sdk_ffi_fn_method_client_set_display_name(self.pointer, 
        FfiConverterString.lower(name),$0
    )
}
    }

    public func setPusher(identifiers: PusherIdentifiers, kind: PusherKind, appDisplayName: String, deviceDisplayName: String, profileTag: String?, lang: String) throws {
        try 
    rustCallWithError(FfiConverterTypeClientError.lift) {
    uniffi_matrix_sdk_ffi_fn_method_client_set_pusher(self.pointer, 
        FfiConverterTypePusherIdentifiers.lower(identifiers),
        FfiConverterTypePusherKind.lower(kind),
        FfiConverterString.lower(appDisplayName),
        FfiConverterString.lower(deviceDisplayName),
        FfiConverterOptionString.lower(profileTag),
        FfiConverterString.lower(lang),$0
    )
}
    }

    public func syncService()  -> SyncServiceBuilder {
        return try!  FfiConverterTypeSyncServiceBuilder.lift(
            try! 
    rustCall() {
    
    uniffi_matrix_sdk_ffi_fn_method_client_sync_service(self.pointer, $0
    )
}
        )
    }

    public func unignoreUser(userId: String) throws {
        try 
    rustCallWithError(FfiConverterTypeClientError.lift) {
    uniffi_matrix_sdk_ffi_fn_method_client_unignore_user(self.pointer, 
        FfiConverterString.lower(userId),$0
    )
}
    }

    public func uploadMedia(mimeType: String, data: [UInt8], progressWatcher: ProgressWatcher?) throws -> String {
        return try  FfiConverterString.lift(
            try 
    rustCallWithError(FfiConverterTypeClientError.lift) {
    uniffi_matrix_sdk_ffi_fn_method_client_upload_media(self.pointer, 
        FfiConverterString.lower(mimeType),
        FfiConverterSequenceUInt8.lower(data),
        FfiConverterOptionCallbackInterfaceProgressWatcher.lower(progressWatcher),$0
    )
}
        )
    }

    public func userId() throws -> String {
        return try  FfiConverterString.lift(
            try 
    rustCallWithError(FfiConverterTypeClientError.lift) {
    uniffi_matrix_sdk_ffi_fn_method_client_user_id(self.pointer, $0
    )
}
        )
    }
}

public struct FfiConverterTypeClient: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Client

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Client {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Client, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Client {
        return Client(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Client) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}


public func FfiConverterTypeClient_lift(_ pointer: UnsafeMutableRawPointer) throws -> Client {
    return try FfiConverterTypeClient.lift(pointer)
}

public func FfiConverterTypeClient_lower(_ value: Client) -> UnsafeMutableRawPointer {
    return FfiConverterTypeClient.lower(value)
}


public protocol ClientBuilderProtocol {
    func basePath(path: String)   -> ClientBuilder
    func build()  throws -> Client
    func disableAutomaticTokenRefresh()   -> ClientBuilder
    func disableSslVerification()   -> ClientBuilder
    func homeserverUrl(url: String)   -> ClientBuilder
    func passphrase(passphrase: String?)   -> ClientBuilder
    func proxy(url: String)   -> ClientBuilder
    func serverName(serverName: String)   -> ClientBuilder
    func serverVersions(versions: [String])   -> ClientBuilder
    func slidingSyncProxy(slidingSyncProxy: String?)   -> ClientBuilder
    func userAgent(userAgent: String)   -> ClientBuilder
    func username(username: String)   -> ClientBuilder
    
}

public class ClientBuilder: ClientBuilderProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }
    public convenience init()  {
        self.init(unsafeFromRawPointer: try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_constructor_clientbuilder_new($0)
})
    }

    deinit {
        try! rustCall { uniffi_matrix_sdk_ffi_fn_free_clientbuilder(pointer, $0) }
    }

    

    
    

    public func basePath(path: String)  -> ClientBuilder {
        return try!  FfiConverterTypeClientBuilder.lift(
            try! 
    rustCall() {
    
    uniffi_matrix_sdk_ffi_fn_method_clientbuilder_base_path(self.pointer, 
        FfiConverterString.lower(path),$0
    )
}
        )
    }

    public func build() throws -> Client {
        return try  FfiConverterTypeClient.lift(
            try 
    rustCallWithError(FfiConverterTypeClientError.lift) {
    uniffi_matrix_sdk_ffi_fn_method_clientbuilder_build(self.pointer, $0
    )
}
        )
    }

    public func disableAutomaticTokenRefresh()  -> ClientBuilder {
        return try!  FfiConverterTypeClientBuilder.lift(
            try! 
    rustCall() {
    
    uniffi_matrix_sdk_ffi_fn_method_clientbuilder_disable_automatic_token_refresh(self.pointer, $0
    )
}
        )
    }

    public func disableSslVerification()  -> ClientBuilder {
        return try!  FfiConverterTypeClientBuilder.lift(
            try! 
    rustCall() {
    
    uniffi_matrix_sdk_ffi_fn_method_clientbuilder_disable_ssl_verification(self.pointer, $0
    )
}
        )
    }

    public func homeserverUrl(url: String)  -> ClientBuilder {
        return try!  FfiConverterTypeClientBuilder.lift(
            try! 
    rustCall() {
    
    uniffi_matrix_sdk_ffi_fn_method_clientbuilder_homeserver_url(self.pointer, 
        FfiConverterString.lower(url),$0
    )
}
        )
    }

    public func passphrase(passphrase: String?)  -> ClientBuilder {
        return try!  FfiConverterTypeClientBuilder.lift(
            try! 
    rustCall() {
    
    uniffi_matrix_sdk_ffi_fn_method_clientbuilder_passphrase(self.pointer, 
        FfiConverterOptionString.lower(passphrase),$0
    )
}
        )
    }

    public func proxy(url: String)  -> ClientBuilder {
        return try!  FfiConverterTypeClientBuilder.lift(
            try! 
    rustCall() {
    
    uniffi_matrix_sdk_ffi_fn_method_clientbuilder_proxy(self.pointer, 
        FfiConverterString.lower(url),$0
    )
}
        )
    }

    public func serverName(serverName: String)  -> ClientBuilder {
        return try!  FfiConverterTypeClientBuilder.lift(
            try! 
    rustCall() {
    
    uniffi_matrix_sdk_ffi_fn_method_clientbuilder_server_name(self.pointer, 
        FfiConverterString.lower(serverName),$0
    )
}
        )
    }

    public func serverVersions(versions: [String])  -> ClientBuilder {
        return try!  FfiConverterTypeClientBuilder.lift(
            try! 
    rustCall() {
    
    uniffi_matrix_sdk_ffi_fn_method_clientbuilder_server_versions(self.pointer, 
        FfiConverterSequenceString.lower(versions),$0
    )
}
        )
    }

    public func slidingSyncProxy(slidingSyncProxy: String?)  -> ClientBuilder {
        return try!  FfiConverterTypeClientBuilder.lift(
            try! 
    rustCall() {
    
    uniffi_matrix_sdk_ffi_fn_method_clientbuilder_sliding_sync_proxy(self.pointer, 
        FfiConverterOptionString.lower(slidingSyncProxy),$0
    )
}
        )
    }

    public func userAgent(userAgent: String)  -> ClientBuilder {
        return try!  FfiConverterTypeClientBuilder.lift(
            try! 
    rustCall() {
    
    uniffi_matrix_sdk_ffi_fn_method_clientbuilder_user_agent(self.pointer, 
        FfiConverterString.lower(userAgent),$0
    )
}
        )
    }

    public func username(username: String)  -> ClientBuilder {
        return try!  FfiConverterTypeClientBuilder.lift(
            try! 
    rustCall() {
    
    uniffi_matrix_sdk_ffi_fn_method_clientbuilder_username(self.pointer, 
        FfiConverterString.lower(username),$0
    )
}
        )
    }
}

public struct FfiConverterTypeClientBuilder: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = ClientBuilder

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ClientBuilder {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: ClientBuilder, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ClientBuilder {
        return ClientBuilder(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: ClientBuilder) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}


public func FfiConverterTypeClientBuilder_lift(_ pointer: UnsafeMutableRawPointer) throws -> ClientBuilder {
    return try FfiConverterTypeClientBuilder.lift(pointer)
}

public func FfiConverterTypeClientBuilder_lower(_ value: ClientBuilder) -> UnsafeMutableRawPointer {
    return FfiConverterTypeClientBuilder.lower(value)
}


public protocol EventTimelineItemProtocol {
    func content()   -> TimelineItemContent
    func debugInfo()   -> EventTimelineItemDebugInfo
    func eventId()   -> String?
    func isEditable()   -> Bool
    func isLocal()   -> Bool
    func isOwn()   -> Bool
    func isRemote()   -> Bool
    func localSendState()   -> EventSendState?
    func origin()   -> EventItemOrigin?
    func reactions()   -> [Reaction]
    func readReceipts()   -> [String: Receipt]
    func sender()   -> String
    func senderProfile()   -> ProfileDetails
    func timestamp()   -> UInt64
    func transactionId()   -> String?
    
}

public class EventTimelineItem: EventTimelineItemProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { uniffi_matrix_sdk_ffi_fn_free_eventtimelineitem(pointer, $0) }
    }

    

    
    

    public func content()  -> TimelineItemContent {
        return try!  FfiConverterTypeTimelineItemContent.lift(
            try! 
    rustCall() {
    
    uniffi_matrix_sdk_ffi_fn_method_eventtimelineitem_content(self.pointer, $0
    )
}
        )
    }

    public func debugInfo()  -> EventTimelineItemDebugInfo {
        return try!  FfiConverterTypeEventTimelineItemDebugInfo.lift(
            try! 
    rustCall() {
    
    uniffi_matrix_sdk_ffi_fn_method_eventtimelineitem_debug_info(self.pointer, $0
    )
}
        )
    }

    public func eventId()  -> String? {
        return try!  FfiConverterOptionString.lift(
            try! 
    rustCall() {
    
    uniffi_matrix_sdk_ffi_fn_method_eventtimelineitem_event_id(self.pointer, $0
    )
}
        )
    }

    public func isEditable()  -> Bool {
        return try!  FfiConverterBool.lift(
            try! 
    rustCall() {
    
    uniffi_matrix_sdk_ffi_fn_method_eventtimelineitem_is_editable(self.pointer, $0
    )
}
        )
    }

    public func isLocal()  -> Bool {
        return try!  FfiConverterBool.lift(
            try! 
    rustCall() {
    
    uniffi_matrix_sdk_ffi_fn_method_eventtimelineitem_is_local(self.pointer, $0
    )
}
        )
    }

    public func isOwn()  -> Bool {
        return try!  FfiConverterBool.lift(
            try! 
    rustCall() {
    
    uniffi_matrix_sdk_ffi_fn_method_eventtimelineitem_is_own(self.pointer, $0
    )
}
        )
    }

    public func isRemote()  -> Bool {
        return try!  FfiConverterBool.lift(
            try! 
    rustCall() {
    
    uniffi_matrix_sdk_ffi_fn_method_eventtimelineitem_is_remote(self.pointer, $0
    )
}
        )
    }

    public func localSendState()  -> EventSendState? {
        return try!  FfiConverterOptionTypeEventSendState.lift(
            try! 
    rustCall() {
    
    uniffi_matrix_sdk_ffi_fn_method_eventtimelineitem_local_send_state(self.pointer, $0
    )
}
        )
    }

    public func origin()  -> EventItemOrigin? {
        return try!  FfiConverterOptionTypeEventItemOrigin.lift(
            try! 
    rustCall() {
    
    uniffi_matrix_sdk_ffi_fn_method_eventtimelineitem_origin(self.pointer, $0
    )
}
        )
    }

    public func reactions()  -> [Reaction] {
        return try!  FfiConverterSequenceTypeReaction.lift(
            try! 
    rustCall() {
    
    uniffi_matrix_sdk_ffi_fn_method_eventtimelineitem_reactions(self.pointer, $0
    )
}
        )
    }

    public func readReceipts()  -> [String: Receipt] {
        return try!  FfiConverterDictionaryStringTypeReceipt.lift(
            try! 
    rustCall() {
    
    uniffi_matrix_sdk_ffi_fn_method_eventtimelineitem_read_receipts(self.pointer, $0
    )
}
        )
    }

    public func sender()  -> String {
        return try!  FfiConverterString.lift(
            try! 
    rustCall() {
    
    uniffi_matrix_sdk_ffi_fn_method_eventtimelineitem_sender(self.pointer, $0
    )
}
        )
    }

    public func senderProfile()  -> ProfileDetails {
        return try!  FfiConverterTypeProfileDetails.lift(
            try! 
    rustCall() {
    
    uniffi_matrix_sdk_ffi_fn_method_eventtimelineitem_sender_profile(self.pointer, $0
    )
}
        )
    }

    public func timestamp()  -> UInt64 {
        return try!  FfiConverterUInt64.lift(
            try! 
    rustCall() {
    
    uniffi_matrix_sdk_ffi_fn_method_eventtimelineitem_timestamp(self.pointer, $0
    )
}
        )
    }

    public func transactionId()  -> String? {
        return try!  FfiConverterOptionString.lift(
            try! 
    rustCall() {
    
    uniffi_matrix_sdk_ffi_fn_method_eventtimelineitem_transaction_id(self.pointer, $0
    )
}
        )
    }
}

public struct FfiConverterTypeEventTimelineItem: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = EventTimelineItem

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> EventTimelineItem {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: EventTimelineItem, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> EventTimelineItem {
        return EventTimelineItem(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: EventTimelineItem) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}


public func FfiConverterTypeEventTimelineItem_lift(_ pointer: UnsafeMutableRawPointer) throws -> EventTimelineItem {
    return try FfiConverterTypeEventTimelineItem.lift(pointer)
}

public func FfiConverterTypeEventTimelineItem_lower(_ value: EventTimelineItem) -> UnsafeMutableRawPointer {
    return FfiConverterTypeEventTimelineItem.lower(value)
}


public protocol HomeserverLoginDetailsProtocol {
    func supportsOidcLogin()   -> Bool
    func supportsPasswordLogin()   -> Bool
    func url()   -> String
    
}

public class HomeserverLoginDetails: HomeserverLoginDetailsProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { uniffi_matrix_sdk_ffi_fn_free_homeserverlogindetails(pointer, $0) }
    }

    

    
    

    public func supportsOidcLogin()  -> Bool {
        return try!  FfiConverterBool.lift(
            try! 
    rustCall() {
    
    uniffi_matrix_sdk_ffi_fn_method_homeserverlogindetails_supports_oidc_login(self.pointer, $0
    )
}
        )
    }

    public func supportsPasswordLogin()  -> Bool {
        return try!  FfiConverterBool.lift(
            try! 
    rustCall() {
    
    uniffi_matrix_sdk_ffi_fn_method_homeserverlogindetails_supports_password_login(self.pointer, $0
    )
}
        )
    }

    public func url()  -> String {
        return try!  FfiConverterString.lift(
            try! 
    rustCall() {
    
    uniffi_matrix_sdk_ffi_fn_method_homeserverlogindetails_url(self.pointer, $0
    )
}
        )
    }
}

public struct FfiConverterTypeHomeserverLoginDetails: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = HomeserverLoginDetails

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> HomeserverLoginDetails {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: HomeserverLoginDetails, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> HomeserverLoginDetails {
        return HomeserverLoginDetails(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: HomeserverLoginDetails) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}


public func FfiConverterTypeHomeserverLoginDetails_lift(_ pointer: UnsafeMutableRawPointer) throws -> HomeserverLoginDetails {
    return try FfiConverterTypeHomeserverLoginDetails.lift(pointer)
}

public func FfiConverterTypeHomeserverLoginDetails_lower(_ value: HomeserverLoginDetails) -> UnsafeMutableRawPointer {
    return FfiConverterTypeHomeserverLoginDetails.lower(value)
}


public protocol MediaFileHandleProtocol {
    func path()   -> String
    
}

public class MediaFileHandle: MediaFileHandleProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { uniffi_matrix_sdk_ffi_fn_free_mediafilehandle(pointer, $0) }
    }

    

    
    

    public func path()  -> String {
        return try!  FfiConverterString.lift(
            try! 
    rustCall() {
    
    uniffi_matrix_sdk_ffi_fn_method_mediafilehandle_path(self.pointer, $0
    )
}
        )
    }
}

public struct FfiConverterTypeMediaFileHandle: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = MediaFileHandle

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MediaFileHandle {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: MediaFileHandle, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> MediaFileHandle {
        return MediaFileHandle(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: MediaFileHandle) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}


public func FfiConverterTypeMediaFileHandle_lift(_ pointer: UnsafeMutableRawPointer) throws -> MediaFileHandle {
    return try FfiConverterTypeMediaFileHandle.lift(pointer)
}

public func FfiConverterTypeMediaFileHandle_lower(_ value: MediaFileHandle) -> UnsafeMutableRawPointer {
    return FfiConverterTypeMediaFileHandle.lower(value)
}


public protocol MediaSourceProtocol {
    func toJson()   -> String
    func url()   -> String
    
}

public class MediaSource: MediaSourceProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { uniffi_matrix_sdk_ffi_fn_free_mediasource(pointer, $0) }
    }

    

    public static func fromJson(json: String) throws -> MediaSource {
        return MediaSource(unsafeFromRawPointer: try rustCallWithError(FfiConverterTypeClientError.lift) {
    uniffi_matrix_sdk_ffi_fn_constructor_mediasource_from_json(
        FfiConverterString.lower(json),$0)
})
    }

    

    
    

    public func toJson()  -> String {
        return try!  FfiConverterString.lift(
            try! 
    rustCall() {
    
    uniffi_matrix_sdk_ffi_fn_method_mediasource_to_json(self.pointer, $0
    )
}
        )
    }

    public func url()  -> String {
        return try!  FfiConverterString.lift(
            try! 
    rustCall() {
    
    uniffi_matrix_sdk_ffi_fn_method_mediasource_url(self.pointer, $0
    )
}
        )
    }
}

public struct FfiConverterTypeMediaSource: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = MediaSource

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MediaSource {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: MediaSource, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> MediaSource {
        return MediaSource(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: MediaSource) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}


public func FfiConverterTypeMediaSource_lift(_ pointer: UnsafeMutableRawPointer) throws -> MediaSource {
    return try FfiConverterTypeMediaSource.lift(pointer)
}

public func FfiConverterTypeMediaSource_lower(_ value: MediaSource) -> UnsafeMutableRawPointer {
    return FfiConverterTypeMediaSource.lower(value)
}


public protocol MessageProtocol {
    func body()   -> String
    func inReplyTo()   -> InReplyToDetails?
    func isEdited()   -> Bool
    func msgtype()   -> MessageType?
    
}

public class Message: MessageProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { uniffi_matrix_sdk_ffi_fn_free_message(pointer, $0) }
    }

    

    
    

    public func body()  -> String {
        return try!  FfiConverterString.lift(
            try! 
    rustCall() {
    
    uniffi_matrix_sdk_ffi_fn_method_message_body(self.pointer, $0
    )
}
        )
    }

    public func inReplyTo()  -> InReplyToDetails? {
        return try!  FfiConverterOptionTypeInReplyToDetails.lift(
            try! 
    rustCall() {
    
    uniffi_matrix_sdk_ffi_fn_method_message_in_reply_to(self.pointer, $0
    )
}
        )
    }

    public func isEdited()  -> Bool {
        return try!  FfiConverterBool.lift(
            try! 
    rustCall() {
    
    uniffi_matrix_sdk_ffi_fn_method_message_is_edited(self.pointer, $0
    )
}
        )
    }

    public func msgtype()  -> MessageType? {
        return try!  FfiConverterOptionTypeMessageType.lift(
            try! 
    rustCall() {
    
    uniffi_matrix_sdk_ffi_fn_method_message_msgtype(self.pointer, $0
    )
}
        )
    }
}

public struct FfiConverterTypeMessage: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Message

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Message {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Message, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Message {
        return Message(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Message) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}


public func FfiConverterTypeMessage_lift(_ pointer: UnsafeMutableRawPointer) throws -> Message {
    return try FfiConverterTypeMessage.lift(pointer)
}

public func FfiConverterTypeMessage_lower(_ value: Message) -> UnsafeMutableRawPointer {
    return FfiConverterTypeMessage.lower(value)
}


public protocol NotificationClientProtocol {
    func getNotification(roomId: String, eventId: String)  throws -> NotificationItem?
    
}

public class NotificationClient: NotificationClientProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { uniffi_matrix_sdk_ffi_fn_free_notificationclient(pointer, $0) }
    }

    

    
    

    public func getNotification(roomId: String, eventId: String) throws -> NotificationItem? {
        return try  FfiConverterOptionTypeNotificationItem.lift(
            try 
    rustCallWithError(FfiConverterTypeClientError.lift) {
    uniffi_matrix_sdk_ffi_fn_method_notificationclient_get_notification(self.pointer, 
        FfiConverterString.lower(roomId),
        FfiConverterString.lower(eventId),$0
    )
}
        )
    }
}

public struct FfiConverterTypeNotificationClient: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = NotificationClient

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NotificationClient {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: NotificationClient, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> NotificationClient {
        return NotificationClient(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: NotificationClient) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}


public func FfiConverterTypeNotificationClient_lift(_ pointer: UnsafeMutableRawPointer) throws -> NotificationClient {
    return try FfiConverterTypeNotificationClient.lift(pointer)
}

public func FfiConverterTypeNotificationClient_lower(_ value: NotificationClient) -> UnsafeMutableRawPointer {
    return FfiConverterTypeNotificationClient.lower(value)
}


public protocol NotificationClientBuilderProtocol {
    func filterByPushRules()   -> NotificationClientBuilder
    func finish()   -> NotificationClient
    func retryDecryption(withCrossProcessLock: Bool)   -> NotificationClientBuilder
    
}

public class NotificationClientBuilder: NotificationClientBuilderProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { uniffi_matrix_sdk_ffi_fn_free_notificationclientbuilder(pointer, $0) }
    }

    

    
    

    public func filterByPushRules()  -> NotificationClientBuilder {
        return try!  FfiConverterTypeNotificationClientBuilder.lift(
            try! 
    rustCall() {
    
    uniffi_matrix_sdk_ffi_fn_method_notificationclientbuilder_filter_by_push_rules(self.pointer, $0
    )
}
        )
    }

    public func finish()  -> NotificationClient {
        return try!  FfiConverterTypeNotificationClient.lift(
            try! 
    rustCall() {
    
    uniffi_matrix_sdk_ffi_fn_method_notificationclientbuilder_finish(self.pointer, $0
    )
}
        )
    }

    public func retryDecryption(withCrossProcessLock: Bool)  -> NotificationClientBuilder {
        return try!  FfiConverterTypeNotificationClientBuilder.lift(
            try! 
    rustCall() {
    
    uniffi_matrix_sdk_ffi_fn_method_notificationclientbuilder_retry_decryption(self.pointer, 
        FfiConverterBool.lower(withCrossProcessLock),$0
    )
}
        )
    }
}

public struct FfiConverterTypeNotificationClientBuilder: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = NotificationClientBuilder

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NotificationClientBuilder {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: NotificationClientBuilder, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> NotificationClientBuilder {
        return NotificationClientBuilder(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: NotificationClientBuilder) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}


public func FfiConverterTypeNotificationClientBuilder_lift(_ pointer: UnsafeMutableRawPointer) throws -> NotificationClientBuilder {
    return try FfiConverterTypeNotificationClientBuilder.lift(pointer)
}

public func FfiConverterTypeNotificationClientBuilder_lower(_ value: NotificationClientBuilder) -> UnsafeMutableRawPointer {
    return FfiConverterTypeNotificationClientBuilder.lower(value)
}


public protocol NotificationSettingsProtocol {
    func containsKeywordsRules() async  -> Bool
    func getDefaultRoomNotificationMode(isEncrypted: Bool, isOneToOne: Bool) async  -> RoomNotificationMode
    func getRoomNotificationSettings(roomId: String, isEncrypted: Bool, isOneToOne: Bool) async throws -> RoomNotificationSettings
    func getRoomsWithUserDefinedRules(enabled: Bool?) async  -> [String]
    func getUserDefinedRoomNotificationMode(roomId: String) async throws -> RoomNotificationMode?
    func isCallEnabled() async throws -> Bool
    func isRoomMentionEnabled() async throws -> Bool
    func isUserMentionEnabled() async throws -> Bool
    func restoreDefaultRoomNotificationMode(roomId: String) async throws
    func setCallEnabled(enabled: Bool) async throws
    func setDefaultRoomNotificationMode(isEncrypted: Bool, isOneToOne: Bool, mode: RoomNotificationMode) async throws
    func setDelegate(delegate: NotificationSettingsDelegate?)  
    func setRoomMentionEnabled(enabled: Bool) async throws
    func setRoomNotificationMode(roomId: String, mode: RoomNotificationMode) async throws
    func setUserMentionEnabled(enabled: Bool) async throws
    func unmuteRoom(roomId: String, isEncrypted: Bool, isOneToOne: Bool) async throws
    
}

public class NotificationSettings: NotificationSettingsProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { uniffi_matrix_sdk_ffi_fn_free_notificationsettings(pointer, $0) }
    }

    

    
    

    public func containsKeywordsRules() async  -> Bool {
        // Suspend the function and call the scaffolding function, passing it a callback handler from
        // `AsyncTypes.swift`
        //
        // Make sure to hold on to a reference to the continuation in the top-level scope so that
        // it's not freed before the callback is invoked.
        var continuation: CheckedContinuation<Bool, Error>? = nil
        return try!  await withCheckedThrowingContinuation {
            continuation = $0
            try! rustCall() {
                uniffi_matrix_sdk_ffi_fn_method_notificationsettings_contains_keywords_rules(
                    self.pointer,
                    
                    FfiConverterForeignExecutor.lower(UniFfiForeignExecutor()),
                    uniffiFutureCallbackHandlerBool,
                    &continuation,
                    $0
                )
            }
        }
    }

    

    public func getDefaultRoomNotificationMode(isEncrypted: Bool, isOneToOne: Bool) async  -> RoomNotificationMode {
        // Suspend the function and call the scaffolding function, passing it a callback handler from
        // `AsyncTypes.swift`
        //
        // Make sure to hold on to a reference to the continuation in the top-level scope so that
        // it's not freed before the callback is invoked.
        var continuation: CheckedContinuation<RoomNotificationMode, Error>? = nil
        return try!  await withCheckedThrowingContinuation {
            continuation = $0
            try! rustCall() {
                uniffi_matrix_sdk_ffi_fn_method_notificationsettings_get_default_room_notification_mode(
                    self.pointer,
                    
        FfiConverterBool.lower(isEncrypted),
        FfiConverterBool.lower(isOneToOne),
                    FfiConverterForeignExecutor.lower(UniFfiForeignExecutor()),
                    uniffiFutureCallbackHandlerTypeRoomNotificationMode,
                    &continuation,
                    $0
                )
            }
        }
    }

    

    public func getRoomNotificationSettings(roomId: String, isEncrypted: Bool, isOneToOne: Bool) async throws -> RoomNotificationSettings {
        // Suspend the function and call the scaffolding function, passing it a callback handler from
        // `AsyncTypes.swift`
        //
        // Make sure to hold on to a reference to the continuation in the top-level scope so that
        // it's not freed before the callback is invoked.
        var continuation: CheckedContinuation<RoomNotificationSettings, Error>? = nil
        return try  await withCheckedThrowingContinuation {
            continuation = $0
            try! rustCall() {
                uniffi_matrix_sdk_ffi_fn_method_notificationsettings_get_room_notification_settings(
                    self.pointer,
                    
        FfiConverterString.lower(roomId),
        FfiConverterBool.lower(isEncrypted),
        FfiConverterBool.lower(isOneToOne),
                    FfiConverterForeignExecutor.lower(UniFfiForeignExecutor()),
                    uniffiFutureCallbackHandlerTypeRoomNotificationSettingsTypeNotificationSettingsError,
                    &continuation,
                    $0
                )
            }
        }
    }

    

    public func getRoomsWithUserDefinedRules(enabled: Bool?) async  -> [String] {
        // Suspend the function and call the scaffolding function, passing it a callback handler from
        // `AsyncTypes.swift`
        //
        // Make sure to hold on to a reference to the continuation in the top-level scope so that
        // it's not freed before the callback is invoked.
        var continuation: CheckedContinuation<[String], Error>? = nil
        return try!  await withCheckedThrowingContinuation {
            continuation = $0
            try! rustCall() {
                uniffi_matrix_sdk_ffi_fn_method_notificationsettings_get_rooms_with_user_defined_rules(
                    self.pointer,
                    
        FfiConverterOptionBool.lower(enabled),
                    FfiConverterForeignExecutor.lower(UniFfiForeignExecutor()),
                    uniffiFutureCallbackHandlerSequenceString,
                    &continuation,
                    $0
                )
            }
        }
    }

    

    public func getUserDefinedRoomNotificationMode(roomId: String) async throws -> RoomNotificationMode? {
        // Suspend the function and call the scaffolding function, passing it a callback handler from
        // `AsyncTypes.swift`
        //
        // Make sure to hold on to a reference to the continuation in the top-level scope so that
        // it's not freed before the callback is invoked.
        var continuation: CheckedContinuation<RoomNotificationMode?, Error>? = nil
        return try  await withCheckedThrowingContinuation {
            continuation = $0
            try! rustCall() {
                uniffi_matrix_sdk_ffi_fn_method_notificationsettings_get_user_defined_room_notification_mode(
                    self.pointer,
                    
        FfiConverterString.lower(roomId),
                    FfiConverterForeignExecutor.lower(UniFfiForeignExecutor()),
                    uniffiFutureCallbackHandlerOptionTypeRoomNotificationModeTypeNotificationSettingsError,
                    &continuation,
                    $0
                )
            }
        }
    }

    

    public func isCallEnabled() async throws -> Bool {
        // Suspend the function and call the scaffolding function, passing it a callback handler from
        // `AsyncTypes.swift`
        //
        // Make sure to hold on to a reference to the continuation in the top-level scope so that
        // it's not freed before the callback is invoked.
        var continuation: CheckedContinuation<Bool, Error>? = nil
        return try  await withCheckedThrowingContinuation {
            continuation = $0
            try! rustCall() {
                uniffi_matrix_sdk_ffi_fn_method_notificationsettings_is_call_enabled(
                    self.pointer,
                    
                    FfiConverterForeignExecutor.lower(UniFfiForeignExecutor()),
                    uniffiFutureCallbackHandlerBoolTypeNotificationSettingsError,
                    &continuation,
                    $0
                )
            }
        }
    }

    

    public func isRoomMentionEnabled() async throws -> Bool {
        // Suspend the function and call the scaffolding function, passing it a callback handler from
        // `AsyncTypes.swift`
        //
        // Make sure to hold on to a reference to the continuation in the top-level scope so that
        // it's not freed before the callback is invoked.
        var continuation: CheckedContinuation<Bool, Error>? = nil
        return try  await withCheckedThrowingContinuation {
            continuation = $0
            try! rustCall() {
                uniffi_matrix_sdk_ffi_fn_method_notificationsettings_is_room_mention_enabled(
                    self.pointer,
                    
                    FfiConverterForeignExecutor.lower(UniFfiForeignExecutor()),
                    uniffiFutureCallbackHandlerBoolTypeNotificationSettingsError,
                    &continuation,
                    $0
                )
            }
        }
    }

    

    public func isUserMentionEnabled() async throws -> Bool {
        // Suspend the function and call the scaffolding function, passing it a callback handler from
        // `AsyncTypes.swift`
        //
        // Make sure to hold on to a reference to the continuation in the top-level scope so that
        // it's not freed before the callback is invoked.
        var continuation: CheckedContinuation<Bool, Error>? = nil
        return try  await withCheckedThrowingContinuation {
            continuation = $0
            try! rustCall() {
                uniffi_matrix_sdk_ffi_fn_method_notificationsettings_is_user_mention_enabled(
                    self.pointer,
                    
                    FfiConverterForeignExecutor.lower(UniFfiForeignExecutor()),
                    uniffiFutureCallbackHandlerBoolTypeNotificationSettingsError,
                    &continuation,
                    $0
                )
            }
        }
    }

    

    public func restoreDefaultRoomNotificationMode(roomId: String) async throws {
        // Suspend the function and call the scaffolding function, passing it a callback handler from
        // `AsyncTypes.swift`
        //
        // Make sure to hold on to a reference to the continuation in the top-level scope so that
        // it's not freed before the callback is invoked.
        var continuation: CheckedContinuation<(), Error>? = nil
        return try  await withCheckedThrowingContinuation {
            continuation = $0
            try! rustCall() {
                uniffi_matrix_sdk_ffi_fn_method_notificationsettings_restore_default_room_notification_mode(
                    self.pointer,
                    
        FfiConverterString.lower(roomId),
                    FfiConverterForeignExecutor.lower(UniFfiForeignExecutor()),
                    uniffiFutureCallbackHandlerVoidTypeNotificationSettingsError,
                    &continuation,
                    $0
                )
            }
        }
    }

    

    public func setCallEnabled(enabled: Bool) async throws {
        // Suspend the function and call the scaffolding function, passing it a callback handler from
        // `AsyncTypes.swift`
        //
        // Make sure to hold on to a reference to the continuation in the top-level scope so that
        // it's not freed before the callback is invoked.
        var continuation: CheckedContinuation<(), Error>? = nil
        return try  await withCheckedThrowingContinuation {
            continuation = $0
            try! rustCall() {
                uniffi_matrix_sdk_ffi_fn_method_notificationsettings_set_call_enabled(
                    self.pointer,
                    
        FfiConverterBool.lower(enabled),
                    FfiConverterForeignExecutor.lower(UniFfiForeignExecutor()),
                    uniffiFutureCallbackHandlerVoidTypeNotificationSettingsError,
                    &continuation,
                    $0
                )
            }
        }
    }

    

    public func setDefaultRoomNotificationMode(isEncrypted: Bool, isOneToOne: Bool, mode: RoomNotificationMode) async throws {
        // Suspend the function and call the scaffolding function, passing it a callback handler from
        // `AsyncTypes.swift`
        //
        // Make sure to hold on to a reference to the continuation in the top-level scope so that
        // it's not freed before the callback is invoked.
        var continuation: CheckedContinuation<(), Error>? = nil
        return try  await withCheckedThrowingContinuation {
            continuation = $0
            try! rustCall() {
                uniffi_matrix_sdk_ffi_fn_method_notificationsettings_set_default_room_notification_mode(
                    self.pointer,
                    
        FfiConverterBool.lower(isEncrypted),
        FfiConverterBool.lower(isOneToOne),
        FfiConverterTypeRoomNotificationMode.lower(mode),
                    FfiConverterForeignExecutor.lower(UniFfiForeignExecutor()),
                    uniffiFutureCallbackHandlerVoidTypeNotificationSettingsError,
                    &continuation,
                    $0
                )
            }
        }
    }

    

    public func setDelegate(delegate: NotificationSettingsDelegate?)  {
        try! 
    rustCall() {
    
    uniffi_matrix_sdk_ffi_fn_method_notificationsettings_set_delegate(self.pointer, 
        FfiConverterOptionCallbackInterfaceNotificationSettingsDelegate.lower(delegate),$0
    )
}
    }

    public func setRoomMentionEnabled(enabled: Bool) async throws {
        // Suspend the function and call the scaffolding function, passing it a callback handler from
        // `AsyncTypes.swift`
        //
        // Make sure to hold on to a reference to the continuation in the top-level scope so that
        // it's not freed before the callback is invoked.
        var continuation: CheckedContinuation<(), Error>? = nil
        return try  await withCheckedThrowingContinuation {
            continuation = $0
            try! rustCall() {
                uniffi_matrix_sdk_ffi_fn_method_notificationsettings_set_room_mention_enabled(
                    self.pointer,
                    
        FfiConverterBool.lower(enabled),
                    FfiConverterForeignExecutor.lower(UniFfiForeignExecutor()),
                    uniffiFutureCallbackHandlerVoidTypeNotificationSettingsError,
                    &continuation,
                    $0
                )
            }
        }
    }

    

    public func setRoomNotificationMode(roomId: String, mode: RoomNotificationMode) async throws {
        // Suspend the function and call the scaffolding function, passing it a callback handler from
        // `AsyncTypes.swift`
        //
        // Make sure to hold on to a reference to the continuation in the top-level scope so that
        // it's not freed before the callback is invoked.
        var continuation: CheckedContinuation<(), Error>? = nil
        return try  await withCheckedThrowingContinuation {
            continuation = $0
            try! rustCall() {
                uniffi_matrix_sdk_ffi_fn_method_notificationsettings_set_room_notification_mode(
                    self.pointer,
                    
        FfiConverterString.lower(roomId),
        FfiConverterTypeRoomNotificationMode.lower(mode),
                    FfiConverterForeignExecutor.lower(UniFfiForeignExecutor()),
                    uniffiFutureCallbackHandlerVoidTypeNotificationSettingsError,
                    &continuation,
                    $0
                )
            }
        }
    }

    

    public func setUserMentionEnabled(enabled: Bool) async throws {
        // Suspend the function and call the scaffolding function, passing it a callback handler from
        // `AsyncTypes.swift`
        //
        // Make sure to hold on to a reference to the continuation in the top-level scope so that
        // it's not freed before the callback is invoked.
        var continuation: CheckedContinuation<(), Error>? = nil
        return try  await withCheckedThrowingContinuation {
            continuation = $0
            try! rustCall() {
                uniffi_matrix_sdk_ffi_fn_method_notificationsettings_set_user_mention_enabled(
                    self.pointer,
                    
        FfiConverterBool.lower(enabled),
                    FfiConverterForeignExecutor.lower(UniFfiForeignExecutor()),
                    uniffiFutureCallbackHandlerVoidTypeNotificationSettingsError,
                    &continuation,
                    $0
                )
            }
        }
    }

    

    public func unmuteRoom(roomId: String, isEncrypted: Bool, isOneToOne: Bool) async throws {
        // Suspend the function and call the scaffolding function, passing it a callback handler from
        // `AsyncTypes.swift`
        //
        // Make sure to hold on to a reference to the continuation in the top-level scope so that
        // it's not freed before the callback is invoked.
        var continuation: CheckedContinuation<(), Error>? = nil
        return try  await withCheckedThrowingContinuation {
            continuation = $0
            try! rustCall() {
                uniffi_matrix_sdk_ffi_fn_method_notificationsettings_unmute_room(
                    self.pointer,
                    
        FfiConverterString.lower(roomId),
        FfiConverterBool.lower(isEncrypted),
        FfiConverterBool.lower(isOneToOne),
                    FfiConverterForeignExecutor.lower(UniFfiForeignExecutor()),
                    uniffiFutureCallbackHandlerVoidTypeNotificationSettingsError,
                    &continuation,
                    $0
                )
            }
        }
    }

    
}

public struct FfiConverterTypeNotificationSettings: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = NotificationSettings

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NotificationSettings {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: NotificationSettings, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> NotificationSettings {
        return NotificationSettings(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: NotificationSettings) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}


public func FfiConverterTypeNotificationSettings_lift(_ pointer: UnsafeMutableRawPointer) throws -> NotificationSettings {
    return try FfiConverterTypeNotificationSettings.lift(pointer)
}

public func FfiConverterTypeNotificationSettings_lower(_ value: NotificationSettings) -> UnsafeMutableRawPointer {
    return FfiConverterTypeNotificationSettings.lower(value)
}


public protocol OidcAuthenticationDataProtocol {
    func loginUrl()   -> String
    
}

public class OidcAuthenticationData: OidcAuthenticationDataProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { uniffi_matrix_sdk_ffi_fn_free_oidcauthenticationdata(pointer, $0) }
    }

    

    
    

    public func loginUrl()  -> String {
        return try!  FfiConverterString.lift(
            try! 
    rustCall() {
    
    uniffi_matrix_sdk_ffi_fn_method_oidcauthenticationdata_login_url(self.pointer, $0
    )
}
        )
    }
}

public struct FfiConverterTypeOidcAuthenticationData: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = OidcAuthenticationData

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> OidcAuthenticationData {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: OidcAuthenticationData, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> OidcAuthenticationData {
        return OidcAuthenticationData(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: OidcAuthenticationData) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}


public func FfiConverterTypeOidcAuthenticationData_lift(_ pointer: UnsafeMutableRawPointer) throws -> OidcAuthenticationData {
    return try FfiConverterTypeOidcAuthenticationData.lift(pointer)
}

public func FfiConverterTypeOidcAuthenticationData_lower(_ value: OidcAuthenticationData) -> UnsafeMutableRawPointer {
    return FfiConverterTypeOidcAuthenticationData.lower(value)
}


public protocol RoomProtocol {
    func activeMembersCount()   -> UInt64
    func addTimelineListener(listener: TimelineListener) async  -> RoomTimelineListenerResult
    func alternativeAliases()   -> [String]
    func avatarUrl()   -> String?
    func canUserBan(userId: String) async throws -> Bool
    func canUserInvite(userId: String) async throws -> Bool
    func canUserKick(userId: String) async throws -> Bool
    func canUserRedact(userId: String) async throws -> Bool
    func canUserSendMessage(userId: String, message: MessageLikeEventType) async throws -> Bool
    func canUserSendState(userId: String, stateEvent: StateEventType) async throws -> Bool
    func canUserTriggerRoomNotification(userId: String) async throws -> Bool
    func cancelSend(txnId: String)  
    func canonicalAlias()   -> String?
    func createPoll(question: String, answers: [String], maxSelections: UInt8, pollKind: PollKind, txnId: String?)  throws
    func displayName()  throws -> String
    func edit(newMsg: RoomMessageEventContentWithoutRelation, originalEventId: String, txnId: String?)  throws
    func endPoll(pollStartId: String, text: String, txnId: String?)  throws
    func fetchDetailsForEvent(eventId: String)  throws
    func fetchMembers()  throws -> TaskHandle
    func getTimelineEventContentByEventId(eventId: String)  throws -> RoomMessageEventContentWithoutRelation
    func id()   -> String
    func ignoreUser(userId: String)  throws
    func inviteUserById(userId: String)  throws
    func invitedMembersCount()   -> UInt64
    func inviter()   -> RoomMember?
    func isDirect()   -> Bool
    func isEncrypted()  throws -> Bool
    func isPublic()   -> Bool
    func isSpace()   -> Bool
    func isTombstoned()   -> Bool
    func join()  throws
    func joinedMembersCount()   -> UInt64
    func leave()  throws
    func member(userId: String)  throws -> RoomMember
    func memberAvatarUrl(userId: String)  throws -> String?
    func memberDisplayName(userId: String)  throws -> String?
    func members()  throws -> [RoomMember]
    func membership()   -> Membership
    func name()   -> String?
    func ownUserId()   -> String
    func paginateBackwards(opts: PaginationOptions)  throws
    func redact(eventId: String, reason: String?, txnId: String?)  throws
    func removeAvatar()  throws
    func removeTimeline()  
    func reportContent(eventId: String, score: Int32?, reason: String?)  throws
    func retryDecryption(sessionIds: [String])  
    func retrySend(txnId: String)  
    func roomInfo() async throws -> RoomInfo
    func send(msg: RoomMessageEventContentWithoutRelation, txnId: String?)  
    func sendAudio(url: String, audioInfo: AudioInfo, progressWatcher: ProgressWatcher?)   -> SendAttachmentJoinHandle
    func sendFile(url: String, fileInfo: FileInfo, progressWatcher: ProgressWatcher?)   -> SendAttachmentJoinHandle
    func sendImage(url: String, thumbnailUrl: String, imageInfo: ImageInfo, progressWatcher: ProgressWatcher?)   -> SendAttachmentJoinHandle
    func sendLocation(body: String, geoUri: String, description: String?, zoomLevel: UInt8?, assetType: AssetType?, txnId: String?)  
    func sendPollResponse(pollStartId: String, answers: [String], txnId: String?)  throws
    func sendReadMarker(fullyReadEventId: String, readReceiptEventId: String?)  throws
    func sendReadReceipt(eventId: String)  throws
    func sendReply(msg: RoomMessageEventContentWithoutRelation, inReplyToEventId: String, txnId: String?)  throws
    func sendVideo(url: String, thumbnailUrl: String, videoInfo: VideoInfo, progressWatcher: ProgressWatcher?)   -> SendAttachmentJoinHandle
    func setName(name: String?)  throws
    func setTopic(topic: String)  throws
    func subscribeToBackPaginationStatus(listener: BackPaginationStatusListener)  throws -> TaskHandle
    func subscribeToRoomInfoUpdates(listener: RoomInfoListener)   -> TaskHandle
    func toggleReaction(eventId: String, key: String)  throws
    func topic()   -> String?
    func uploadAvatar(mimeType: String, data: [UInt8])  throws
    
}

public class Room: RoomProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { uniffi_matrix_sdk_ffi_fn_free_room(pointer, $0) }
    }

    

    
    

    public func activeMembersCount()  -> UInt64 {
        return try!  FfiConverterUInt64.lift(
            try! 
    rustCall() {
    
    uniffi_matrix_sdk_ffi_fn_method_room_active_members_count(self.pointer, $0
    )
}
        )
    }

    public func addTimelineListener(listener: TimelineListener) async  -> RoomTimelineListenerResult {
        // Suspend the function and call the scaffolding function, passing it a callback handler from
        // `AsyncTypes.swift`
        //
        // Make sure to hold on to a reference to the continuation in the top-level scope so that
        // it's not freed before the callback is invoked.
        var continuation: CheckedContinuation<RoomTimelineListenerResult, Error>? = nil
        return try!  await withCheckedThrowingContinuation {
            continuation = $0
            try! rustCall() {
                uniffi_matrix_sdk_ffi_fn_method_room_add_timeline_listener(
                    self.pointer,
                    
        FfiConverterCallbackInterfaceTimelineListener.lower(listener),
                    FfiConverterForeignExecutor.lower(UniFfiForeignExecutor()),
                    uniffiFutureCallbackHandlerTypeRoomTimelineListenerResult,
                    &continuation,
                    $0
                )
            }
        }
    }

    

    public func alternativeAliases()  -> [String] {
        return try!  FfiConverterSequenceString.lift(
            try! 
    rustCall() {
    
    uniffi_matrix_sdk_ffi_fn_method_room_alternative_aliases(self.pointer, $0
    )
}
        )
    }

    public func avatarUrl()  -> String? {
        return try!  FfiConverterOptionString.lift(
            try! 
    rustCall() {
    
    uniffi_matrix_sdk_ffi_fn_method_room_avatar_url(self.pointer, $0
    )
}
        )
    }

    public func canUserBan(userId: String) async throws -> Bool {
        // Suspend the function and call the scaffolding function, passing it a callback handler from
        // `AsyncTypes.swift`
        //
        // Make sure to hold on to a reference to the continuation in the top-level scope so that
        // it's not freed before the callback is invoked.
        var continuation: CheckedContinuation<Bool, Error>? = nil
        return try  await withCheckedThrowingContinuation {
            continuation = $0
            try! rustCall() {
                uniffi_matrix_sdk_ffi_fn_method_room_can_user_ban(
                    self.pointer,
                    
        FfiConverterString.lower(userId),
                    FfiConverterForeignExecutor.lower(UniFfiForeignExecutor()),
                    uniffiFutureCallbackHandlerBoolTypeClientError,
                    &continuation,
                    $0
                )
            }
        }
    }

    

    public func canUserInvite(userId: String) async throws -> Bool {
        // Suspend the function and call the scaffolding function, passing it a callback handler from
        // `AsyncTypes.swift`
        //
        // Make sure to hold on to a reference to the continuation in the top-level scope so that
        // it's not freed before the callback is invoked.
        var continuation: CheckedContinuation<Bool, Error>? = nil
        return try  await withCheckedThrowingContinuation {
            continuation = $0
            try! rustCall() {
                uniffi_matrix_sdk_ffi_fn_method_room_can_user_invite(
                    self.pointer,
                    
        FfiConverterString.lower(userId),
                    FfiConverterForeignExecutor.lower(UniFfiForeignExecutor()),
                    uniffiFutureCallbackHandlerBoolTypeClientError,
                    &continuation,
                    $0
                )
            }
        }
    }

    

    public func canUserKick(userId: String) async throws -> Bool {
        // Suspend the function and call the scaffolding function, passing it a callback handler from
        // `AsyncTypes.swift`
        //
        // Make sure to hold on to a reference to the continuation in the top-level scope so that
        // it's not freed before the callback is invoked.
        var continuation: CheckedContinuation<Bool, Error>? = nil
        return try  await withCheckedThrowingContinuation {
            continuation = $0
            try! rustCall() {
                uniffi_matrix_sdk_ffi_fn_method_room_can_user_kick(
                    self.pointer,
                    
        FfiConverterString.lower(userId),
                    FfiConverterForeignExecutor.lower(UniFfiForeignExecutor()),
                    uniffiFutureCallbackHandlerBoolTypeClientError,
                    &continuation,
                    $0
                )
            }
        }
    }

    

    public func canUserRedact(userId: String) async throws -> Bool {
        // Suspend the function and call the scaffolding function, passing it a callback handler from
        // `AsyncTypes.swift`
        //
        // Make sure to hold on to a reference to the continuation in the top-level scope so that
        // it's not freed before the callback is invoked.
        var continuation: CheckedContinuation<Bool, Error>? = nil
        return try  await withCheckedThrowingContinuation {
            continuation = $0
            try! rustCall() {
                uniffi_matrix_sdk_ffi_fn_method_room_can_user_redact(
                    self.pointer,
                    
        FfiConverterString.lower(userId),
                    FfiConverterForeignExecutor.lower(UniFfiForeignExecutor()),
                    uniffiFutureCallbackHandlerBoolTypeClientError,
                    &continuation,
                    $0
                )
            }
        }
    }

    

    public func canUserSendMessage(userId: String, message: MessageLikeEventType) async throws -> Bool {
        // Suspend the function and call the scaffolding function, passing it a callback handler from
        // `AsyncTypes.swift`
        //
        // Make sure to hold on to a reference to the continuation in the top-level scope so that
        // it's not freed before the callback is invoked.
        var continuation: CheckedContinuation<Bool, Error>? = nil
        return try  await withCheckedThrowingContinuation {
            continuation = $0
            try! rustCall() {
                uniffi_matrix_sdk_ffi_fn_method_room_can_user_send_message(
                    self.pointer,
                    
        FfiConverterString.lower(userId),
        FfiConverterTypeMessageLikeEventType.lower(message),
                    FfiConverterForeignExecutor.lower(UniFfiForeignExecutor()),
                    uniffiFutureCallbackHandlerBoolTypeClientError,
                    &continuation,
                    $0
                )
            }
        }
    }

    

    public func canUserSendState(userId: String, stateEvent: StateEventType) async throws -> Bool {
        // Suspend the function and call the scaffolding function, passing it a callback handler from
        // `AsyncTypes.swift`
        //
        // Make sure to hold on to a reference to the continuation in the top-level scope so that
        // it's not freed before the callback is invoked.
        var continuation: CheckedContinuation<Bool, Error>? = nil
        return try  await withCheckedThrowingContinuation {
            continuation = $0
            try! rustCall() {
                uniffi_matrix_sdk_ffi_fn_method_room_can_user_send_state(
                    self.pointer,
                    
        FfiConverterString.lower(userId),
        FfiConverterTypeStateEventType.lower(stateEvent),
                    FfiConverterForeignExecutor.lower(UniFfiForeignExecutor()),
                    uniffiFutureCallbackHandlerBoolTypeClientError,
                    &continuation,
                    $0
                )
            }
        }
    }

    

    public func canUserTriggerRoomNotification(userId: String) async throws -> Bool {
        // Suspend the function and call the scaffolding function, passing it a callback handler from
        // `AsyncTypes.swift`
        //
        // Make sure to hold on to a reference to the continuation in the top-level scope so that
        // it's not freed before the callback is invoked.
        var continuation: CheckedContinuation<Bool, Error>? = nil
        return try  await withCheckedThrowingContinuation {
            continuation = $0
            try! rustCall() {
                uniffi_matrix_sdk_ffi_fn_method_room_can_user_trigger_room_notification(
                    self.pointer,
                    
        FfiConverterString.lower(userId),
                    FfiConverterForeignExecutor.lower(UniFfiForeignExecutor()),
                    uniffiFutureCallbackHandlerBoolTypeClientError,
                    &continuation,
                    $0
                )
            }
        }
    }

    

    public func cancelSend(txnId: String)  {
        try! 
    rustCall() {
    
    uniffi_matrix_sdk_ffi_fn_method_room_cancel_send(self.pointer, 
        FfiConverterString.lower(txnId),$0
    )
}
    }

    public func canonicalAlias()  -> String? {
        return try!  FfiConverterOptionString.lift(
            try! 
    rustCall() {
    
    uniffi_matrix_sdk_ffi_fn_method_room_canonical_alias(self.pointer, $0
    )
}
        )
    }

    public func createPoll(question: String, answers: [String], maxSelections: UInt8, pollKind: PollKind, txnId: String?) throws {
        try 
    rustCallWithError(FfiConverterTypeClientError.lift) {
    uniffi_matrix_sdk_ffi_fn_method_room_create_poll(self.pointer, 
        FfiConverterString.lower(question),
        FfiConverterSequenceString.lower(answers),
        FfiConverterUInt8.lower(maxSelections),
        FfiConverterTypePollKind.lower(pollKind),
        FfiConverterOptionString.lower(txnId),$0
    )
}
    }

    public func displayName() throws -> String {
        return try  FfiConverterString.lift(
            try 
    rustCallWithError(FfiConverterTypeClientError.lift) {
    uniffi_matrix_sdk_ffi_fn_method_room_display_name(self.pointer, $0
    )
}
        )
    }

    public func edit(newMsg: RoomMessageEventContentWithoutRelation, originalEventId: String, txnId: String?) throws {
        try 
    rustCallWithError(FfiConverterTypeClientError.lift) {
    uniffi_matrix_sdk_ffi_fn_method_room_edit(self.pointer, 
        FfiConverterTypeRoomMessageEventContentWithoutRelation.lower(newMsg),
        FfiConverterString.lower(originalEventId),
        FfiConverterOptionString.lower(txnId),$0
    )
}
    }

    public func endPoll(pollStartId: String, text: String, txnId: String?) throws {
        try 
    rustCallWithError(FfiConverterTypeClientError.lift) {
    uniffi_matrix_sdk_ffi_fn_method_room_end_poll(self.pointer, 
        FfiConverterString.lower(pollStartId),
        FfiConverterString.lower(text),
        FfiConverterOptionString.lower(txnId),$0
    )
}
    }

    public func fetchDetailsForEvent(eventId: String) throws {
        try 
    rustCallWithError(FfiConverterTypeClientError.lift) {
    uniffi_matrix_sdk_ffi_fn_method_room_fetch_details_for_event(self.pointer, 
        FfiConverterString.lower(eventId),$0
    )
}
    }

    public func fetchMembers() throws -> TaskHandle {
        return try  FfiConverterTypeTaskHandle.lift(
            try 
    rustCallWithError(FfiConverterTypeClientError.lift) {
    uniffi_matrix_sdk_ffi_fn_method_room_fetch_members(self.pointer, $0
    )
}
        )
    }

    public func getTimelineEventContentByEventId(eventId: String) throws -> RoomMessageEventContentWithoutRelation {
        return try  FfiConverterTypeRoomMessageEventContentWithoutRelation.lift(
            try 
    rustCallWithError(FfiConverterTypeClientError.lift) {
    uniffi_matrix_sdk_ffi_fn_method_room_get_timeline_event_content_by_event_id(self.pointer, 
        FfiConverterString.lower(eventId),$0
    )
}
        )
    }

    public func id()  -> String {
        return try!  FfiConverterString.lift(
            try! 
    rustCall() {
    
    uniffi_matrix_sdk_ffi_fn_method_room_id(self.pointer, $0
    )
}
        )
    }

    public func ignoreUser(userId: String) throws {
        try 
    rustCallWithError(FfiConverterTypeClientError.lift) {
    uniffi_matrix_sdk_ffi_fn_method_room_ignore_user(self.pointer, 
        FfiConverterString.lower(userId),$0
    )
}
    }

    public func inviteUserById(userId: String) throws {
        try 
    rustCallWithError(FfiConverterTypeClientError.lift) {
    uniffi_matrix_sdk_ffi_fn_method_room_invite_user_by_id(self.pointer, 
        FfiConverterString.lower(userId),$0
    )
}
    }

    public func invitedMembersCount()  -> UInt64 {
        return try!  FfiConverterUInt64.lift(
            try! 
    rustCall() {
    
    uniffi_matrix_sdk_ffi_fn_method_room_invited_members_count(self.pointer, $0
    )
}
        )
    }

    public func inviter()  -> RoomMember? {
        return try!  FfiConverterOptionTypeRoomMember.lift(
            try! 
    rustCall() {
    
    uniffi_matrix_sdk_ffi_fn_method_room_inviter(self.pointer, $0
    )
}
        )
    }

    public func isDirect()  -> Bool {
        return try!  FfiConverterBool.lift(
            try! 
    rustCall() {
    
    uniffi_matrix_sdk_ffi_fn_method_room_is_direct(self.pointer, $0
    )
}
        )
    }

    public func isEncrypted() throws -> Bool {
        return try  FfiConverterBool.lift(
            try 
    rustCallWithError(FfiConverterTypeClientError.lift) {
    uniffi_matrix_sdk_ffi_fn_method_room_is_encrypted(self.pointer, $0
    )
}
        )
    }

    public func isPublic()  -> Bool {
        return try!  FfiConverterBool.lift(
            try! 
    rustCall() {
    
    uniffi_matrix_sdk_ffi_fn_method_room_is_public(self.pointer, $0
    )
}
        )
    }

    public func isSpace()  -> Bool {
        return try!  FfiConverterBool.lift(
            try! 
    rustCall() {
    
    uniffi_matrix_sdk_ffi_fn_method_room_is_space(self.pointer, $0
    )
}
        )
    }

    public func isTombstoned()  -> Bool {
        return try!  FfiConverterBool.lift(
            try! 
    rustCall() {
    
    uniffi_matrix_sdk_ffi_fn_method_room_is_tombstoned(self.pointer, $0
    )
}
        )
    }

    public func join() throws {
        try 
    rustCallWithError(FfiConverterTypeClientError.lift) {
    uniffi_matrix_sdk_ffi_fn_method_room_join(self.pointer, $0
    )
}
    }

    public func joinedMembersCount()  -> UInt64 {
        return try!  FfiConverterUInt64.lift(
            try! 
    rustCall() {
    
    uniffi_matrix_sdk_ffi_fn_method_room_joined_members_count(self.pointer, $0
    )
}
        )
    }

    public func leave() throws {
        try 
    rustCallWithError(FfiConverterTypeClientError.lift) {
    uniffi_matrix_sdk_ffi_fn_method_room_leave(self.pointer, $0
    )
}
    }

    public func member(userId: String) throws -> RoomMember {
        return try  FfiConverterTypeRoomMember.lift(
            try 
    rustCallWithError(FfiConverterTypeClientError.lift) {
    uniffi_matrix_sdk_ffi_fn_method_room_member(self.pointer, 
        FfiConverterString.lower(userId),$0
    )
}
        )
    }

    public func memberAvatarUrl(userId: String) throws -> String? {
        return try  FfiConverterOptionString.lift(
            try 
    rustCallWithError(FfiConverterTypeClientError.lift) {
    uniffi_matrix_sdk_ffi_fn_method_room_member_avatar_url(self.pointer, 
        FfiConverterString.lower(userId),$0
    )
}
        )
    }

    public func memberDisplayName(userId: String) throws -> String? {
        return try  FfiConverterOptionString.lift(
            try 
    rustCallWithError(FfiConverterTypeClientError.lift) {
    uniffi_matrix_sdk_ffi_fn_method_room_member_display_name(self.pointer, 
        FfiConverterString.lower(userId),$0
    )
}
        )
    }

    public func members() throws -> [RoomMember] {
        return try  FfiConverterSequenceTypeRoomMember.lift(
            try 
    rustCallWithError(FfiConverterTypeClientError.lift) {
    uniffi_matrix_sdk_ffi_fn_method_room_members(self.pointer, $0
    )
}
        )
    }

    public func membership()  -> Membership {
        return try!  FfiConverterTypeMembership.lift(
            try! 
    rustCall() {
    
    uniffi_matrix_sdk_ffi_fn_method_room_membership(self.pointer, $0
    )
}
        )
    }

    public func name()  -> String? {
        return try!  FfiConverterOptionString.lift(
            try! 
    rustCall() {
    
    uniffi_matrix_sdk_ffi_fn_method_room_name(self.pointer, $0
    )
}
        )
    }

    public func ownUserId()  -> String {
        return try!  FfiConverterString.lift(
            try! 
    rustCall() {
    
    uniffi_matrix_sdk_ffi_fn_method_room_own_user_id(self.pointer, $0
    )
}
        )
    }

    public func paginateBackwards(opts: PaginationOptions) throws {
        try 
    rustCallWithError(FfiConverterTypeClientError.lift) {
    uniffi_matrix_sdk_ffi_fn_method_room_paginate_backwards(self.pointer, 
        FfiConverterTypePaginationOptions.lower(opts),$0
    )
}
    }

    public func redact(eventId: String, reason: String?, txnId: String?) throws {
        try 
    rustCallWithError(FfiConverterTypeClientError.lift) {
    uniffi_matrix_sdk_ffi_fn_method_room_redact(self.pointer, 
        FfiConverterString.lower(eventId),
        FfiConverterOptionString.lower(reason),
        FfiConverterOptionString.lower(txnId),$0
    )
}
    }

    public func removeAvatar() throws {
        try 
    rustCallWithError(FfiConverterTypeClientError.lift) {
    uniffi_matrix_sdk_ffi_fn_method_room_remove_avatar(self.pointer, $0
    )
}
    }

    public func removeTimeline()  {
        try! 
    rustCall() {
    
    uniffi_matrix_sdk_ffi_fn_method_room_remove_timeline(self.pointer, $0
    )
}
    }

    public func reportContent(eventId: String, score: Int32?, reason: String?) throws {
        try 
    rustCallWithError(FfiConverterTypeClientError.lift) {
    uniffi_matrix_sdk_ffi_fn_method_room_report_content(self.pointer, 
        FfiConverterString.lower(eventId),
        FfiConverterOptionInt32.lower(score),
        FfiConverterOptionString.lower(reason),$0
    )
}
    }

    public func retryDecryption(sessionIds: [String])  {
        try! 
    rustCall() {
    
    uniffi_matrix_sdk_ffi_fn_method_room_retry_decryption(self.pointer, 
        FfiConverterSequenceString.lower(sessionIds),$0
    )
}
    }

    public func retrySend(txnId: String)  {
        try! 
    rustCall() {
    
    uniffi_matrix_sdk_ffi_fn_method_room_retry_send(self.pointer, 
        FfiConverterString.lower(txnId),$0
    )
}
    }

    public func roomInfo() async throws -> RoomInfo {
        // Suspend the function and call the scaffolding function, passing it a callback handler from
        // `AsyncTypes.swift`
        //
        // Make sure to hold on to a reference to the continuation in the top-level scope so that
        // it's not freed before the callback is invoked.
        var continuation: CheckedContinuation<RoomInfo, Error>? = nil
        return try  await withCheckedThrowingContinuation {
            continuation = $0
            try! rustCall() {
                uniffi_matrix_sdk_ffi_fn_method_room_room_info(
                    self.pointer,
                    
                    FfiConverterForeignExecutor.lower(UniFfiForeignExecutor()),
                    uniffiFutureCallbackHandlerTypeRoomInfoTypeClientError,
                    &continuation,
                    $0
                )
            }
        }
    }

    

    public func send(msg: RoomMessageEventContentWithoutRelation, txnId: String?)  {
        try! 
    rustCall() {
    
    uniffi_matrix_sdk_ffi_fn_method_room_send(self.pointer, 
        FfiConverterTypeRoomMessageEventContentWithoutRelation.lower(msg),
        FfiConverterOptionString.lower(txnId),$0
    )
}
    }

    public func sendAudio(url: String, audioInfo: AudioInfo, progressWatcher: ProgressWatcher?)  -> SendAttachmentJoinHandle {
        return try!  FfiConverterTypeSendAttachmentJoinHandle.lift(
            try! 
    rustCall() {
    
    uniffi_matrix_sdk_ffi_fn_method_room_send_audio(self.pointer, 
        FfiConverterString.lower(url),
        FfiConverterTypeAudioInfo.lower(audioInfo),
        FfiConverterOptionCallbackInterfaceProgressWatcher.lower(progressWatcher),$0
    )
}
        )
    }

    public func sendFile(url: String, fileInfo: FileInfo, progressWatcher: ProgressWatcher?)  -> SendAttachmentJoinHandle {
        return try!  FfiConverterTypeSendAttachmentJoinHandle.lift(
            try! 
    rustCall() {
    
    uniffi_matrix_sdk_ffi_fn_method_room_send_file(self.pointer, 
        FfiConverterString.lower(url),
        FfiConverterTypeFileInfo.lower(fileInfo),
        FfiConverterOptionCallbackInterfaceProgressWatcher.lower(progressWatcher),$0
    )
}
        )
    }

    public func sendImage(url: String, thumbnailUrl: String, imageInfo: ImageInfo, progressWatcher: ProgressWatcher?)  -> SendAttachmentJoinHandle {
        return try!  FfiConverterTypeSendAttachmentJoinHandle.lift(
            try! 
    rustCall() {
    
    uniffi_matrix_sdk_ffi_fn_method_room_send_image(self.pointer, 
        FfiConverterString.lower(url),
        FfiConverterString.lower(thumbnailUrl),
        FfiConverterTypeImageInfo.lower(imageInfo),
        FfiConverterOptionCallbackInterfaceProgressWatcher.lower(progressWatcher),$0
    )
}
        )
    }

    public func sendLocation(body: String, geoUri: String, description: String?, zoomLevel: UInt8?, assetType: AssetType?, txnId: String?)  {
        try! 
    rustCall() {
    
    uniffi_matrix_sdk_ffi_fn_method_room_send_location(self.pointer, 
        FfiConverterString.lower(body),
        FfiConverterString.lower(geoUri),
        FfiConverterOptionString.lower(description),
        FfiConverterOptionUInt8.lower(zoomLevel),
        FfiConverterOptionTypeAssetType.lower(assetType),
        FfiConverterOptionString.lower(txnId),$0
    )
}
    }

    public func sendPollResponse(pollStartId: String, answers: [String], txnId: String?) throws {
        try 
    rustCallWithError(FfiConverterTypeClientError.lift) {
    uniffi_matrix_sdk_ffi_fn_method_room_send_poll_response(self.pointer, 
        FfiConverterString.lower(pollStartId),
        FfiConverterSequenceString.lower(answers),
        FfiConverterOptionString.lower(txnId),$0
    )
}
    }

    public func sendReadMarker(fullyReadEventId: String, readReceiptEventId: String?) throws {
        try 
    rustCallWithError(FfiConverterTypeClientError.lift) {
    uniffi_matrix_sdk_ffi_fn_method_room_send_read_marker(self.pointer, 
        FfiConverterString.lower(fullyReadEventId),
        FfiConverterOptionString.lower(readReceiptEventId),$0
    )
}
    }

    public func sendReadReceipt(eventId: String) throws {
        try 
    rustCallWithError(FfiConverterTypeClientError.lift) {
    uniffi_matrix_sdk_ffi_fn_method_room_send_read_receipt(self.pointer, 
        FfiConverterString.lower(eventId),$0
    )
}
    }

    public func sendReply(msg: RoomMessageEventContentWithoutRelation, inReplyToEventId: String, txnId: String?) throws {
        try 
    rustCallWithError(FfiConverterTypeClientError.lift) {
    uniffi_matrix_sdk_ffi_fn_method_room_send_reply(self.pointer, 
        FfiConverterTypeRoomMessageEventContentWithoutRelation.lower(msg),
        FfiConverterString.lower(inReplyToEventId),
        FfiConverterOptionString.lower(txnId),$0
    )
}
    }

    public func sendVideo(url: String, thumbnailUrl: String, videoInfo: VideoInfo, progressWatcher: ProgressWatcher?)  -> SendAttachmentJoinHandle {
        return try!  FfiConverterTypeSendAttachmentJoinHandle.lift(
            try! 
    rustCall() {
    
    uniffi_matrix_sdk_ffi_fn_method_room_send_video(self.pointer, 
        FfiConverterString.lower(url),
        FfiConverterString.lower(thumbnailUrl),
        FfiConverterTypeVideoInfo.lower(videoInfo),
        FfiConverterOptionCallbackInterfaceProgressWatcher.lower(progressWatcher),$0
    )
}
        )
    }

    public func setName(name: String?) throws {
        try 
    rustCallWithError(FfiConverterTypeClientError.lift) {
    uniffi_matrix_sdk_ffi_fn_method_room_set_name(self.pointer, 
        FfiConverterOptionString.lower(name),$0
    )
}
    }

    public func setTopic(topic: String) throws {
        try 
    rustCallWithError(FfiConverterTypeClientError.lift) {
    uniffi_matrix_sdk_ffi_fn_method_room_set_topic(self.pointer, 
        FfiConverterString.lower(topic),$0
    )
}
    }

    public func subscribeToBackPaginationStatus(listener: BackPaginationStatusListener) throws -> TaskHandle {
        return try  FfiConverterTypeTaskHandle.lift(
            try 
    rustCallWithError(FfiConverterTypeClientError.lift) {
    uniffi_matrix_sdk_ffi_fn_method_room_subscribe_to_back_pagination_status(self.pointer, 
        FfiConverterCallbackInterfaceBackPaginationStatusListener.lower(listener),$0
    )
}
        )
    }

    public func subscribeToRoomInfoUpdates(listener: RoomInfoListener)  -> TaskHandle {
        return try!  FfiConverterTypeTaskHandle.lift(
            try! 
    rustCall() {
    
    uniffi_matrix_sdk_ffi_fn_method_room_subscribe_to_room_info_updates(self.pointer, 
        FfiConverterCallbackInterfaceRoomInfoListener.lower(listener),$0
    )
}
        )
    }

    public func toggleReaction(eventId: String, key: String) throws {
        try 
    rustCallWithError(FfiConverterTypeClientError.lift) {
    uniffi_matrix_sdk_ffi_fn_method_room_toggle_reaction(self.pointer, 
        FfiConverterString.lower(eventId),
        FfiConverterString.lower(key),$0
    )
}
    }

    public func topic()  -> String? {
        return try!  FfiConverterOptionString.lift(
            try! 
    rustCall() {
    
    uniffi_matrix_sdk_ffi_fn_method_room_topic(self.pointer, $0
    )
}
        )
    }

    public func uploadAvatar(mimeType: String, data: [UInt8]) throws {
        try 
    rustCallWithError(FfiConverterTypeClientError.lift) {
    uniffi_matrix_sdk_ffi_fn_method_room_upload_avatar(self.pointer, 
        FfiConverterString.lower(mimeType),
        FfiConverterSequenceUInt8.lower(data),$0
    )
}
    }
}

public struct FfiConverterTypeRoom: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Room

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Room {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Room, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Room {
        return Room(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Room) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}


public func FfiConverterTypeRoom_lift(_ pointer: UnsafeMutableRawPointer) throws -> Room {
    return try FfiConverterTypeRoom.lift(pointer)
}

public func FfiConverterTypeRoom_lower(_ value: Room) -> UnsafeMutableRawPointer {
    return FfiConverterTypeRoom.lower(value)
}


public protocol RoomListProtocol {
    func entries(listener: RoomListEntriesListener)   -> RoomListEntriesResult
    func entriesWithDynamicFilter(listener: RoomListEntriesListener)   -> RoomListEntriesWithDynamicFilterResult
    func loadingState(listener: RoomListLoadingStateListener)  throws -> RoomListLoadingStateResult
    func room(roomId: String)  throws -> RoomListItem
    
}

public class RoomList: RoomListProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { uniffi_matrix_sdk_ffi_fn_free_roomlist(pointer, $0) }
    }

    

    
    

    public func entries(listener: RoomListEntriesListener)  -> RoomListEntriesResult {
        return try!  FfiConverterTypeRoomListEntriesResult.lift(
            try! 
    rustCall() {
    
    uniffi_matrix_sdk_ffi_fn_method_roomlist_entries(self.pointer, 
        FfiConverterCallbackInterfaceRoomListEntriesListener.lower(listener),$0
    )
}
        )
    }

    public func entriesWithDynamicFilter(listener: RoomListEntriesListener)  -> RoomListEntriesWithDynamicFilterResult {
        return try!  FfiConverterTypeRoomListEntriesWithDynamicFilterResult.lift(
            try! 
    rustCall() {
    
    uniffi_matrix_sdk_ffi_fn_method_roomlist_entries_with_dynamic_filter(self.pointer, 
        FfiConverterCallbackInterfaceRoomListEntriesListener.lower(listener),$0
    )
}
        )
    }

    public func loadingState(listener: RoomListLoadingStateListener) throws -> RoomListLoadingStateResult {
        return try  FfiConverterTypeRoomListLoadingStateResult.lift(
            try 
    rustCallWithError(FfiConverterTypeRoomListError.lift) {
    uniffi_matrix_sdk_ffi_fn_method_roomlist_loading_state(self.pointer, 
        FfiConverterCallbackInterfaceRoomListLoadingStateListener.lower(listener),$0
    )
}
        )
    }

    public func room(roomId: String) throws -> RoomListItem {
        return try  FfiConverterTypeRoomListItem.lift(
            try 
    rustCallWithError(FfiConverterTypeRoomListError.lift) {
    uniffi_matrix_sdk_ffi_fn_method_roomlist_room(self.pointer, 
        FfiConverterString.lower(roomId),$0
    )
}
        )
    }
}

public struct FfiConverterTypeRoomList: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = RoomList

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RoomList {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: RoomList, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> RoomList {
        return RoomList(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: RoomList) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}


public func FfiConverterTypeRoomList_lift(_ pointer: UnsafeMutableRawPointer) throws -> RoomList {
    return try FfiConverterTypeRoomList.lift(pointer)
}

public func FfiConverterTypeRoomList_lower(_ value: RoomList) -> UnsafeMutableRawPointer {
    return FfiConverterTypeRoomList.lower(value)
}


public protocol RoomListEntriesDynamicFilterProtocol {
    func set(kind: RoomListEntriesDynamicFilterKind)   -> Bool
    
}

public class RoomListEntriesDynamicFilter: RoomListEntriesDynamicFilterProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { uniffi_matrix_sdk_ffi_fn_free_roomlistentriesdynamicfilter(pointer, $0) }
    }

    

    
    

    public func set(kind: RoomListEntriesDynamicFilterKind)  -> Bool {
        return try!  FfiConverterBool.lift(
            try! 
    rustCall() {
    
    uniffi_matrix_sdk_ffi_fn_method_roomlistentriesdynamicfilter_set(self.pointer, 
        FfiConverterTypeRoomListEntriesDynamicFilterKind.lower(kind),$0
    )
}
        )
    }
}

public struct FfiConverterTypeRoomListEntriesDynamicFilter: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = RoomListEntriesDynamicFilter

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RoomListEntriesDynamicFilter {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: RoomListEntriesDynamicFilter, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> RoomListEntriesDynamicFilter {
        return RoomListEntriesDynamicFilter(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: RoomListEntriesDynamicFilter) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}


public func FfiConverterTypeRoomListEntriesDynamicFilter_lift(_ pointer: UnsafeMutableRawPointer) throws -> RoomListEntriesDynamicFilter {
    return try FfiConverterTypeRoomListEntriesDynamicFilter.lift(pointer)
}

public func FfiConverterTypeRoomListEntriesDynamicFilter_lower(_ value: RoomListEntriesDynamicFilter) -> UnsafeMutableRawPointer {
    return FfiConverterTypeRoomListEntriesDynamicFilter.lower(value)
}


public protocol RoomListItemProtocol {
    func avatarUrl()   -> String?
    func canonicalAlias()   -> String?
    func fullRoom()   -> Room
    func hasUnreadNotifications()   -> Bool
    func id()   -> String
    func isDirect()   -> Bool
    func latestEvent() async  -> EventTimelineItem?
    func name()   -> String?
    func roomInfo() async throws -> RoomInfo
    func subscribe(settings: RoomSubscription?)  
    func unreadNotifications()   -> UnreadNotificationsCount
    func unsubscribe()  
    
}

public class RoomListItem: RoomListItemProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { uniffi_matrix_sdk_ffi_fn_free_roomlistitem(pointer, $0) }
    }

    

    
    

    public func avatarUrl()  -> String? {
        return try!  FfiConverterOptionString.lift(
            try! 
    rustCall() {
    
    uniffi_matrix_sdk_ffi_fn_method_roomlistitem_avatar_url(self.pointer, $0
    )
}
        )
    }

    public func canonicalAlias()  -> String? {
        return try!  FfiConverterOptionString.lift(
            try! 
    rustCall() {
    
    uniffi_matrix_sdk_ffi_fn_method_roomlistitem_canonical_alias(self.pointer, $0
    )
}
        )
    }

    public func fullRoom()  -> Room {
        return try!  FfiConverterTypeRoom.lift(
            try! 
    rustCall() {
    
    uniffi_matrix_sdk_ffi_fn_method_roomlistitem_full_room(self.pointer, $0
    )
}
        )
    }

    public func hasUnreadNotifications()  -> Bool {
        return try!  FfiConverterBool.lift(
            try! 
    rustCall() {
    
    uniffi_matrix_sdk_ffi_fn_method_roomlistitem_has_unread_notifications(self.pointer, $0
    )
}
        )
    }

    public func id()  -> String {
        return try!  FfiConverterString.lift(
            try! 
    rustCall() {
    
    uniffi_matrix_sdk_ffi_fn_method_roomlistitem_id(self.pointer, $0
    )
}
        )
    }

    public func isDirect()  -> Bool {
        return try!  FfiConverterBool.lift(
            try! 
    rustCall() {
    
    uniffi_matrix_sdk_ffi_fn_method_roomlistitem_is_direct(self.pointer, $0
    )
}
        )
    }

    public func latestEvent() async  -> EventTimelineItem? {
        // Suspend the function and call the scaffolding function, passing it a callback handler from
        // `AsyncTypes.swift`
        //
        // Make sure to hold on to a reference to the continuation in the top-level scope so that
        // it's not freed before the callback is invoked.
        var continuation: CheckedContinuation<EventTimelineItem?, Error>? = nil
        return try!  await withCheckedThrowingContinuation {
            continuation = $0
            try! rustCall() {
                uniffi_matrix_sdk_ffi_fn_method_roomlistitem_latest_event(
                    self.pointer,
                    
                    FfiConverterForeignExecutor.lower(UniFfiForeignExecutor()),
                    uniffiFutureCallbackHandlerOptionTypeEventTimelineItem,
                    &continuation,
                    $0
                )
            }
        }
    }

    

    public func name()  -> String? {
        return try!  FfiConverterOptionString.lift(
            try! 
    rustCall() {
    
    uniffi_matrix_sdk_ffi_fn_method_roomlistitem_name(self.pointer, $0
    )
}
        )
    }

    public func roomInfo() async throws -> RoomInfo {
        // Suspend the function and call the scaffolding function, passing it a callback handler from
        // `AsyncTypes.swift`
        //
        // Make sure to hold on to a reference to the continuation in the top-level scope so that
        // it's not freed before the callback is invoked.
        var continuation: CheckedContinuation<RoomInfo, Error>? = nil
        return try  await withCheckedThrowingContinuation {
            continuation = $0
            try! rustCall() {
                uniffi_matrix_sdk_ffi_fn_method_roomlistitem_room_info(
                    self.pointer,
                    
                    FfiConverterForeignExecutor.lower(UniFfiForeignExecutor()),
                    uniffiFutureCallbackHandlerTypeRoomInfoTypeClientError,
                    &continuation,
                    $0
                )
            }
        }
    }

    

    public func subscribe(settings: RoomSubscription?)  {
        try! 
    rustCall() {
    
    uniffi_matrix_sdk_ffi_fn_method_roomlistitem_subscribe(self.pointer, 
        FfiConverterOptionTypeRoomSubscription.lower(settings),$0
    )
}
    }

    public func unreadNotifications()  -> UnreadNotificationsCount {
        return try!  FfiConverterTypeUnreadNotificationsCount.lift(
            try! 
    rustCall() {
    
    uniffi_matrix_sdk_ffi_fn_method_roomlistitem_unread_notifications(self.pointer, $0
    )
}
        )
    }

    public func unsubscribe()  {
        try! 
    rustCall() {
    
    uniffi_matrix_sdk_ffi_fn_method_roomlistitem_unsubscribe(self.pointer, $0
    )
}
    }
}

public struct FfiConverterTypeRoomListItem: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = RoomListItem

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RoomListItem {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: RoomListItem, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> RoomListItem {
        return RoomListItem(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: RoomListItem) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}


public func FfiConverterTypeRoomListItem_lift(_ pointer: UnsafeMutableRawPointer) throws -> RoomListItem {
    return try FfiConverterTypeRoomListItem.lift(pointer)
}

public func FfiConverterTypeRoomListItem_lower(_ value: RoomListItem) -> UnsafeMutableRawPointer {
    return FfiConverterTypeRoomListItem.lower(value)
}


public protocol RoomListServiceProtocol {
    func allRooms() async throws -> RoomList
    func applyInput(input: RoomListInput) async throws
    func invites() async throws -> RoomList
    func room(roomId: String)  throws -> RoomListItem
    func state(listener: RoomListServiceStateListener)   -> TaskHandle
    
}

public class RoomListService: RoomListServiceProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { uniffi_matrix_sdk_ffi_fn_free_roomlistservice(pointer, $0) }
    }

    

    
    

    public func allRooms() async throws -> RoomList {
        // Suspend the function and call the scaffolding function, passing it a callback handler from
        // `AsyncTypes.swift`
        //
        // Make sure to hold on to a reference to the continuation in the top-level scope so that
        // it's not freed before the callback is invoked.
        var continuation: CheckedContinuation<RoomList, Error>? = nil
        return try  await withCheckedThrowingContinuation {
            continuation = $0
            try! rustCall() {
                uniffi_matrix_sdk_ffi_fn_method_roomlistservice_all_rooms(
                    self.pointer,
                    
                    FfiConverterForeignExecutor.lower(UniFfiForeignExecutor()),
                    uniffiFutureCallbackHandlerTypeRoomListTypeRoomListError,
                    &continuation,
                    $0
                )
            }
        }
    }

    

    public func applyInput(input: RoomListInput) async throws {
        // Suspend the function and call the scaffolding function, passing it a callback handler from
        // `AsyncTypes.swift`
        //
        // Make sure to hold on to a reference to the continuation in the top-level scope so that
        // it's not freed before the callback is invoked.
        var continuation: CheckedContinuation<(), Error>? = nil
        return try  await withCheckedThrowingContinuation {
            continuation = $0
            try! rustCall() {
                uniffi_matrix_sdk_ffi_fn_method_roomlistservice_apply_input(
                    self.pointer,
                    
        FfiConverterTypeRoomListInput.lower(input),
                    FfiConverterForeignExecutor.lower(UniFfiForeignExecutor()),
                    uniffiFutureCallbackHandlerVoidTypeRoomListError,
                    &continuation,
                    $0
                )
            }
        }
    }

    

    public func invites() async throws -> RoomList {
        // Suspend the function and call the scaffolding function, passing it a callback handler from
        // `AsyncTypes.swift`
        //
        // Make sure to hold on to a reference to the continuation in the top-level scope so that
        // it's not freed before the callback is invoked.
        var continuation: CheckedContinuation<RoomList, Error>? = nil
        return try  await withCheckedThrowingContinuation {
            continuation = $0
            try! rustCall() {
                uniffi_matrix_sdk_ffi_fn_method_roomlistservice_invites(
                    self.pointer,
                    
                    FfiConverterForeignExecutor.lower(UniFfiForeignExecutor()),
                    uniffiFutureCallbackHandlerTypeRoomListTypeRoomListError,
                    &continuation,
                    $0
                )
            }
        }
    }

    

    public func room(roomId: String) throws -> RoomListItem {
        return try  FfiConverterTypeRoomListItem.lift(
            try 
    rustCallWithError(FfiConverterTypeRoomListError.lift) {
    uniffi_matrix_sdk_ffi_fn_method_roomlistservice_room(self.pointer, 
        FfiConverterString.lower(roomId),$0
    )
}
        )
    }

    public func state(listener: RoomListServiceStateListener)  -> TaskHandle {
        return try!  FfiConverterTypeTaskHandle.lift(
            try! 
    rustCall() {
    
    uniffi_matrix_sdk_ffi_fn_method_roomlistservice_state(self.pointer, 
        FfiConverterCallbackInterfaceRoomListServiceStateListener.lower(listener),$0
    )
}
        )
    }
}

public struct FfiConverterTypeRoomListService: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = RoomListService

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RoomListService {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: RoomListService, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> RoomListService {
        return RoomListService(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: RoomListService) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}


public func FfiConverterTypeRoomListService_lift(_ pointer: UnsafeMutableRawPointer) throws -> RoomListService {
    return try FfiConverterTypeRoomListService.lift(pointer)
}

public func FfiConverterTypeRoomListService_lower(_ value: RoomListService) -> UnsafeMutableRawPointer {
    return FfiConverterTypeRoomListService.lower(value)
}


public protocol RoomMemberProtocol {
    func avatarUrl()   -> String?
    func canBan()   -> Bool
    func canInvite()   -> Bool
    func canKick()   -> Bool
    func canRedact()   -> Bool
    func canSendMessage(event: MessageLikeEventType)   -> Bool
    func canSendState(stateEvent: StateEventType)   -> Bool
    func canTriggerRoomNotification()   -> Bool
    func displayName()   -> String?
    func ignore()  throws
    func isAccountUser()   -> Bool
    func isIgnored()   -> Bool
    func isNameAmbiguous()   -> Bool
    func membership()   -> MembershipState
    func normalizedPowerLevel()   -> Int64
    func powerLevel()   -> Int64
    func unignore()  throws
    func userId()   -> String
    
}

public class RoomMember: RoomMemberProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { uniffi_matrix_sdk_ffi_fn_free_roommember(pointer, $0) }
    }

    

    
    

    public func avatarUrl()  -> String? {
        return try!  FfiConverterOptionString.lift(
            try! 
    rustCall() {
    
    uniffi_matrix_sdk_ffi_fn_method_roommember_avatar_url(self.pointer, $0
    )
}
        )
    }

    public func canBan()  -> Bool {
        return try!  FfiConverterBool.lift(
            try! 
    rustCall() {
    
    uniffi_matrix_sdk_ffi_fn_method_roommember_can_ban(self.pointer, $0
    )
}
        )
    }

    public func canInvite()  -> Bool {
        return try!  FfiConverterBool.lift(
            try! 
    rustCall() {
    
    uniffi_matrix_sdk_ffi_fn_method_roommember_can_invite(self.pointer, $0
    )
}
        )
    }

    public func canKick()  -> Bool {
        return try!  FfiConverterBool.lift(
            try! 
    rustCall() {
    
    uniffi_matrix_sdk_ffi_fn_method_roommember_can_kick(self.pointer, $0
    )
}
        )
    }

    public func canRedact()  -> Bool {
        return try!  FfiConverterBool.lift(
            try! 
    rustCall() {
    
    uniffi_matrix_sdk_ffi_fn_method_roommember_can_redact(self.pointer, $0
    )
}
        )
    }

    public func canSendMessage(event: MessageLikeEventType)  -> Bool {
        return try!  FfiConverterBool.lift(
            try! 
    rustCall() {
    
    uniffi_matrix_sdk_ffi_fn_method_roommember_can_send_message(self.pointer, 
        FfiConverterTypeMessageLikeEventType.lower(event),$0
    )
}
        )
    }

    public func canSendState(stateEvent: StateEventType)  -> Bool {
        return try!  FfiConverterBool.lift(
            try! 
    rustCall() {
    
    uniffi_matrix_sdk_ffi_fn_method_roommember_can_send_state(self.pointer, 
        FfiConverterTypeStateEventType.lower(stateEvent),$0
    )
}
        )
    }

    public func canTriggerRoomNotification()  -> Bool {
        return try!  FfiConverterBool.lift(
            try! 
    rustCall() {
    
    uniffi_matrix_sdk_ffi_fn_method_roommember_can_trigger_room_notification(self.pointer, $0
    )
}
        )
    }

    public func displayName()  -> String? {
        return try!  FfiConverterOptionString.lift(
            try! 
    rustCall() {
    
    uniffi_matrix_sdk_ffi_fn_method_roommember_display_name(self.pointer, $0
    )
}
        )
    }

    public func ignore() throws {
        try 
    rustCallWithError(FfiConverterTypeClientError.lift) {
    uniffi_matrix_sdk_ffi_fn_method_roommember_ignore(self.pointer, $0
    )
}
    }

    public func isAccountUser()  -> Bool {
        return try!  FfiConverterBool.lift(
            try! 
    rustCall() {
    
    uniffi_matrix_sdk_ffi_fn_method_roommember_is_account_user(self.pointer, $0
    )
}
        )
    }

    public func isIgnored()  -> Bool {
        return try!  FfiConverterBool.lift(
            try! 
    rustCall() {
    
    uniffi_matrix_sdk_ffi_fn_method_roommember_is_ignored(self.pointer, $0
    )
}
        )
    }

    public func isNameAmbiguous()  -> Bool {
        return try!  FfiConverterBool.lift(
            try! 
    rustCall() {
    
    uniffi_matrix_sdk_ffi_fn_method_roommember_is_name_ambiguous(self.pointer, $0
    )
}
        )
    }

    public func membership()  -> MembershipState {
        return try!  FfiConverterTypeMembershipState.lift(
            try! 
    rustCall() {
    
    uniffi_matrix_sdk_ffi_fn_method_roommember_membership(self.pointer, $0
    )
}
        )
    }

    public func normalizedPowerLevel()  -> Int64 {
        return try!  FfiConverterInt64.lift(
            try! 
    rustCall() {
    
    uniffi_matrix_sdk_ffi_fn_method_roommember_normalized_power_level(self.pointer, $0
    )
}
        )
    }

    public func powerLevel()  -> Int64 {
        return try!  FfiConverterInt64.lift(
            try! 
    rustCall() {
    
    uniffi_matrix_sdk_ffi_fn_method_roommember_power_level(self.pointer, $0
    )
}
        )
    }

    public func unignore() throws {
        try 
    rustCallWithError(FfiConverterTypeClientError.lift) {
    uniffi_matrix_sdk_ffi_fn_method_roommember_unignore(self.pointer, $0
    )
}
    }

    public func userId()  -> String {
        return try!  FfiConverterString.lift(
            try! 
    rustCall() {
    
    uniffi_matrix_sdk_ffi_fn_method_roommember_user_id(self.pointer, $0
    )
}
        )
    }
}

public struct FfiConverterTypeRoomMember: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = RoomMember

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RoomMember {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: RoomMember, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> RoomMember {
        return RoomMember(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: RoomMember) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}


public func FfiConverterTypeRoomMember_lift(_ pointer: UnsafeMutableRawPointer) throws -> RoomMember {
    return try FfiConverterTypeRoomMember.lift(pointer)
}

public func FfiConverterTypeRoomMember_lower(_ value: RoomMember) -> UnsafeMutableRawPointer {
    return FfiConverterTypeRoomMember.lower(value)
}


public protocol RoomMessageEventContentWithoutRelationProtocol {
    
}

public class RoomMessageEventContentWithoutRelation: RoomMessageEventContentWithoutRelationProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { uniffi_matrix_sdk_ffi_fn_free_roommessageeventcontentwithoutrelation(pointer, $0) }
    }

    

    
    
}

public struct FfiConverterTypeRoomMessageEventContentWithoutRelation: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = RoomMessageEventContentWithoutRelation

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RoomMessageEventContentWithoutRelation {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: RoomMessageEventContentWithoutRelation, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> RoomMessageEventContentWithoutRelation {
        return RoomMessageEventContentWithoutRelation(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: RoomMessageEventContentWithoutRelation) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}


public func FfiConverterTypeRoomMessageEventContentWithoutRelation_lift(_ pointer: UnsafeMutableRawPointer) throws -> RoomMessageEventContentWithoutRelation {
    return try FfiConverterTypeRoomMessageEventContentWithoutRelation.lift(pointer)
}

public func FfiConverterTypeRoomMessageEventContentWithoutRelation_lower(_ value: RoomMessageEventContentWithoutRelation) -> UnsafeMutableRawPointer {
    return FfiConverterTypeRoomMessageEventContentWithoutRelation.lower(value)
}


public protocol SendAttachmentJoinHandleProtocol {
    func cancel()  
    func join() async throws
    
}

public class SendAttachmentJoinHandle: SendAttachmentJoinHandleProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { uniffi_matrix_sdk_ffi_fn_free_sendattachmentjoinhandle(pointer, $0) }
    }

    

    
    

    public func cancel()  {
        try! 
    rustCall() {
    
    uniffi_matrix_sdk_ffi_fn_method_sendattachmentjoinhandle_cancel(self.pointer, $0
    )
}
    }

    public func join() async throws {
        // Suspend the function and call the scaffolding function, passing it a callback handler from
        // `AsyncTypes.swift`
        //
        // Make sure to hold on to a reference to the continuation in the top-level scope so that
        // it's not freed before the callback is invoked.
        var continuation: CheckedContinuation<(), Error>? = nil
        return try  await withCheckedThrowingContinuation {
            continuation = $0
            try! rustCall() {
                uniffi_matrix_sdk_ffi_fn_method_sendattachmentjoinhandle_join(
                    self.pointer,
                    
                    FfiConverterForeignExecutor.lower(UniFfiForeignExecutor()),
                    uniffiFutureCallbackHandlerVoidTypeRoomError,
                    &continuation,
                    $0
                )
            }
        }
    }

    
}

public struct FfiConverterTypeSendAttachmentJoinHandle: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = SendAttachmentJoinHandle

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SendAttachmentJoinHandle {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: SendAttachmentJoinHandle, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> SendAttachmentJoinHandle {
        return SendAttachmentJoinHandle(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: SendAttachmentJoinHandle) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}


public func FfiConverterTypeSendAttachmentJoinHandle_lift(_ pointer: UnsafeMutableRawPointer) throws -> SendAttachmentJoinHandle {
    return try FfiConverterTypeSendAttachmentJoinHandle.lift(pointer)
}

public func FfiConverterTypeSendAttachmentJoinHandle_lower(_ value: SendAttachmentJoinHandle) -> UnsafeMutableRawPointer {
    return FfiConverterTypeSendAttachmentJoinHandle.lower(value)
}


public protocol SessionVerificationControllerProtocol {
    func approveVerification() async throws
    func cancelVerification() async throws
    func declineVerification() async throws
    func isVerified()   -> Bool
    func requestVerification() async throws
    func setDelegate(delegate: SessionVerificationControllerDelegate?)  
    func startSasVerification() async throws
    
}

public class SessionVerificationController: SessionVerificationControllerProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { uniffi_matrix_sdk_ffi_fn_free_sessionverificationcontroller(pointer, $0) }
    }

    

    
    

    public func approveVerification() async throws {
        // Suspend the function and call the scaffolding function, passing it a callback handler from
        // `AsyncTypes.swift`
        //
        // Make sure to hold on to a reference to the continuation in the top-level scope so that
        // it's not freed before the callback is invoked.
        var continuation: CheckedContinuation<(), Error>? = nil
        return try  await withCheckedThrowingContinuation {
            continuation = $0
            try! rustCall() {
                uniffi_matrix_sdk_ffi_fn_method_sessionverificationcontroller_approve_verification(
                    self.pointer,
                    
                    FfiConverterForeignExecutor.lower(UniFfiForeignExecutor()),
                    uniffiFutureCallbackHandlerVoidTypeClientError,
                    &continuation,
                    $0
                )
            }
        }
    }

    

    public func cancelVerification() async throws {
        // Suspend the function and call the scaffolding function, passing it a callback handler from
        // `AsyncTypes.swift`
        //
        // Make sure to hold on to a reference to the continuation in the top-level scope so that
        // it's not freed before the callback is invoked.
        var continuation: CheckedContinuation<(), Error>? = nil
        return try  await withCheckedThrowingContinuation {
            continuation = $0
            try! rustCall() {
                uniffi_matrix_sdk_ffi_fn_method_sessionverificationcontroller_cancel_verification(
                    self.pointer,
                    
                    FfiConverterForeignExecutor.lower(UniFfiForeignExecutor()),
                    uniffiFutureCallbackHandlerVoidTypeClientError,
                    &continuation,
                    $0
                )
            }
        }
    }

    

    public func declineVerification() async throws {
        // Suspend the function and call the scaffolding function, passing it a callback handler from
        // `AsyncTypes.swift`
        //
        // Make sure to hold on to a reference to the continuation in the top-level scope so that
        // it's not freed before the callback is invoked.
        var continuation: CheckedContinuation<(), Error>? = nil
        return try  await withCheckedThrowingContinuation {
            continuation = $0
            try! rustCall() {
                uniffi_matrix_sdk_ffi_fn_method_sessionverificationcontroller_decline_verification(
                    self.pointer,
                    
                    FfiConverterForeignExecutor.lower(UniFfiForeignExecutor()),
                    uniffiFutureCallbackHandlerVoidTypeClientError,
                    &continuation,
                    $0
                )
            }
        }
    }

    

    public func isVerified()  -> Bool {
        return try!  FfiConverterBool.lift(
            try! 
    rustCall() {
    
    uniffi_matrix_sdk_ffi_fn_method_sessionverificationcontroller_is_verified(self.pointer, $0
    )
}
        )
    }

    public func requestVerification() async throws {
        // Suspend the function and call the scaffolding function, passing it a callback handler from
        // `AsyncTypes.swift`
        //
        // Make sure to hold on to a reference to the continuation in the top-level scope so that
        // it's not freed before the callback is invoked.
        var continuation: CheckedContinuation<(), Error>? = nil
        return try  await withCheckedThrowingContinuation {
            continuation = $0
            try! rustCall() {
                uniffi_matrix_sdk_ffi_fn_method_sessionverificationcontroller_request_verification(
                    self.pointer,
                    
                    FfiConverterForeignExecutor.lower(UniFfiForeignExecutor()),
                    uniffiFutureCallbackHandlerVoidTypeClientError,
                    &continuation,
                    $0
                )
            }
        }
    }

    

    public func setDelegate(delegate: SessionVerificationControllerDelegate?)  {
        try! 
    rustCall() {
    
    uniffi_matrix_sdk_ffi_fn_method_sessionverificationcontroller_set_delegate(self.pointer, 
        FfiConverterOptionCallbackInterfaceSessionVerificationControllerDelegate.lower(delegate),$0
    )
}
    }

    public func startSasVerification() async throws {
        // Suspend the function and call the scaffolding function, passing it a callback handler from
        // `AsyncTypes.swift`
        //
        // Make sure to hold on to a reference to the continuation in the top-level scope so that
        // it's not freed before the callback is invoked.
        var continuation: CheckedContinuation<(), Error>? = nil
        return try  await withCheckedThrowingContinuation {
            continuation = $0
            try! rustCall() {
                uniffi_matrix_sdk_ffi_fn_method_sessionverificationcontroller_start_sas_verification(
                    self.pointer,
                    
                    FfiConverterForeignExecutor.lower(UniFfiForeignExecutor()),
                    uniffiFutureCallbackHandlerVoidTypeClientError,
                    &continuation,
                    $0
                )
            }
        }
    }

    
}

public struct FfiConverterTypeSessionVerificationController: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = SessionVerificationController

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SessionVerificationController {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: SessionVerificationController, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> SessionVerificationController {
        return SessionVerificationController(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: SessionVerificationController) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}


public func FfiConverterTypeSessionVerificationController_lift(_ pointer: UnsafeMutableRawPointer) throws -> SessionVerificationController {
    return try FfiConverterTypeSessionVerificationController.lift(pointer)
}

public func FfiConverterTypeSessionVerificationController_lower(_ value: SessionVerificationController) -> UnsafeMutableRawPointer {
    return FfiConverterTypeSessionVerificationController.lower(value)
}


public protocol SessionVerificationEmojiProtocol {
    func description()   -> String
    func symbol()   -> String
    
}

public class SessionVerificationEmoji: SessionVerificationEmojiProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { uniffi_matrix_sdk_ffi_fn_free_sessionverificationemoji(pointer, $0) }
    }

    

    
    

    public func description()  -> String {
        return try!  FfiConverterString.lift(
            try! 
    rustCall() {
    
    uniffi_matrix_sdk_ffi_fn_method_sessionverificationemoji_description(self.pointer, $0
    )
}
        )
    }

    public func symbol()  -> String {
        return try!  FfiConverterString.lift(
            try! 
    rustCall() {
    
    uniffi_matrix_sdk_ffi_fn_method_sessionverificationemoji_symbol(self.pointer, $0
    )
}
        )
    }
}

public struct FfiConverterTypeSessionVerificationEmoji: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = SessionVerificationEmoji

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SessionVerificationEmoji {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: SessionVerificationEmoji, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> SessionVerificationEmoji {
        return SessionVerificationEmoji(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: SessionVerificationEmoji) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}


public func FfiConverterTypeSessionVerificationEmoji_lift(_ pointer: UnsafeMutableRawPointer) throws -> SessionVerificationEmoji {
    return try FfiConverterTypeSessionVerificationEmoji.lift(pointer)
}

public func FfiConverterTypeSessionVerificationEmoji_lower(_ value: SessionVerificationEmoji) -> UnsafeMutableRawPointer {
    return FfiConverterTypeSessionVerificationEmoji.lower(value)
}


public protocol SpanProtocol {
    func enter()  
    func exit()  
    func isNone()   -> Bool
    
}

public class Span: SpanProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }
    public convenience init(file: String, line: UInt32?, level: LogLevel, target: String, name: String)  {
        self.init(unsafeFromRawPointer: try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_constructor_span_new(
        FfiConverterString.lower(file),
        FfiConverterOptionUInt32.lower(line),
        FfiConverterTypeLogLevel.lower(level),
        FfiConverterString.lower(target),
        FfiConverterString.lower(name),$0)
})
    }

    deinit {
        try! rustCall { uniffi_matrix_sdk_ffi_fn_free_span(pointer, $0) }
    }

    

    public static func current()  -> Span {
        return Span(unsafeFromRawPointer: try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_constructor_span_current($0)
})
    }

    

    
    

    public func enter()  {
        try! 
    rustCall() {
    
    uniffi_matrix_sdk_ffi_fn_method_span_enter(self.pointer, $0
    )
}
    }

    public func exit()  {
        try! 
    rustCall() {
    
    uniffi_matrix_sdk_ffi_fn_method_span_exit(self.pointer, $0
    )
}
    }

    public func isNone()  -> Bool {
        return try!  FfiConverterBool.lift(
            try! 
    rustCall() {
    
    uniffi_matrix_sdk_ffi_fn_method_span_is_none(self.pointer, $0
    )
}
        )
    }
}

public struct FfiConverterTypeSpan: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Span

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Span {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Span, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Span {
        return Span(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Span) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}


public func FfiConverterTypeSpan_lift(_ pointer: UnsafeMutableRawPointer) throws -> Span {
    return try FfiConverterTypeSpan.lift(pointer)
}

public func FfiConverterTypeSpan_lower(_ value: Span) -> UnsafeMutableRawPointer {
    return FfiConverterTypeSpan.lower(value)
}


public protocol SyncServiceProtocol {
    func roomListService()   -> RoomListService
    func start() async 
    func state(listener: SyncServiceStateObserver)   -> TaskHandle
    func stop() async throws
    
}

public class SyncService: SyncServiceProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { uniffi_matrix_sdk_ffi_fn_free_syncservice(pointer, $0) }
    }

    

    
    

    public func roomListService()  -> RoomListService {
        return try!  FfiConverterTypeRoomListService.lift(
            try! 
    rustCall() {
    
    uniffi_matrix_sdk_ffi_fn_method_syncservice_room_list_service(self.pointer, $0
    )
}
        )
    }

    public func start() async  {
        // Suspend the function and call the scaffolding function, passing it a callback handler from
        // `AsyncTypes.swift`
        //
        // Make sure to hold on to a reference to the continuation in the top-level scope so that
        // it's not freed before the callback is invoked.
        var continuation: CheckedContinuation<(), Error>? = nil
        return try!  await withCheckedThrowingContinuation {
            continuation = $0
            try! rustCall() {
                uniffi_matrix_sdk_ffi_fn_method_syncservice_start(
                    self.pointer,
                    
                    FfiConverterForeignExecutor.lower(UniFfiForeignExecutor()),
                    uniffiFutureCallbackHandlerVoid,
                    &continuation,
                    $0
                )
            }
        }
    }

    

    public func state(listener: SyncServiceStateObserver)  -> TaskHandle {
        return try!  FfiConverterTypeTaskHandle.lift(
            try! 
    rustCall() {
    
    uniffi_matrix_sdk_ffi_fn_method_syncservice_state(self.pointer, 
        FfiConverterCallbackInterfaceSyncServiceStateObserver.lower(listener),$0
    )
}
        )
    }

    public func stop() async throws {
        // Suspend the function and call the scaffolding function, passing it a callback handler from
        // `AsyncTypes.swift`
        //
        // Make sure to hold on to a reference to the continuation in the top-level scope so that
        // it's not freed before the callback is invoked.
        var continuation: CheckedContinuation<(), Error>? = nil
        return try  await withCheckedThrowingContinuation {
            continuation = $0
            try! rustCall() {
                uniffi_matrix_sdk_ffi_fn_method_syncservice_stop(
                    self.pointer,
                    
                    FfiConverterForeignExecutor.lower(UniFfiForeignExecutor()),
                    uniffiFutureCallbackHandlerVoidTypeClientError,
                    &continuation,
                    $0
                )
            }
        }
    }

    
}

public struct FfiConverterTypeSyncService: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = SyncService

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SyncService {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: SyncService, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> SyncService {
        return SyncService(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: SyncService) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}


public func FfiConverterTypeSyncService_lift(_ pointer: UnsafeMutableRawPointer) throws -> SyncService {
    return try FfiConverterTypeSyncService.lift(pointer)
}

public func FfiConverterTypeSyncService_lower(_ value: SyncService) -> UnsafeMutableRawPointer {
    return FfiConverterTypeSyncService.lower(value)
}


public protocol SyncServiceBuilderProtocol {
    func finish() async throws -> SyncService
    func withEncryptionSync(withCrossProcessLock: Bool, appIdentifier: String?)   -> SyncServiceBuilder
    
}

public class SyncServiceBuilder: SyncServiceBuilderProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { uniffi_matrix_sdk_ffi_fn_free_syncservicebuilder(pointer, $0) }
    }

    

    
    

    public func finish() async throws -> SyncService {
        // Suspend the function and call the scaffolding function, passing it a callback handler from
        // `AsyncTypes.swift`
        //
        // Make sure to hold on to a reference to the continuation in the top-level scope so that
        // it's not freed before the callback is invoked.
        var continuation: CheckedContinuation<SyncService, Error>? = nil
        return try  await withCheckedThrowingContinuation {
            continuation = $0
            try! rustCall() {
                uniffi_matrix_sdk_ffi_fn_method_syncservicebuilder_finish(
                    self.pointer,
                    
                    FfiConverterForeignExecutor.lower(UniFfiForeignExecutor()),
                    uniffiFutureCallbackHandlerTypeSyncServiceTypeClientError,
                    &continuation,
                    $0
                )
            }
        }
    }

    

    public func withEncryptionSync(withCrossProcessLock: Bool, appIdentifier: String?)  -> SyncServiceBuilder {
        return try!  FfiConverterTypeSyncServiceBuilder.lift(
            try! 
    rustCall() {
    
    uniffi_matrix_sdk_ffi_fn_method_syncservicebuilder_with_encryption_sync(self.pointer, 
        FfiConverterBool.lower(withCrossProcessLock),
        FfiConverterOptionString.lower(appIdentifier),$0
    )
}
        )
    }
}

public struct FfiConverterTypeSyncServiceBuilder: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = SyncServiceBuilder

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SyncServiceBuilder {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: SyncServiceBuilder, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> SyncServiceBuilder {
        return SyncServiceBuilder(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: SyncServiceBuilder) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}


public func FfiConverterTypeSyncServiceBuilder_lift(_ pointer: UnsafeMutableRawPointer) throws -> SyncServiceBuilder {
    return try FfiConverterTypeSyncServiceBuilder.lift(pointer)
}

public func FfiConverterTypeSyncServiceBuilder_lower(_ value: SyncServiceBuilder) -> UnsafeMutableRawPointer {
    return FfiConverterTypeSyncServiceBuilder.lower(value)
}


public protocol TaskHandleProtocol {
    func cancel()  
    func isFinished()   -> Bool
    
}

public class TaskHandle: TaskHandleProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { uniffi_matrix_sdk_ffi_fn_free_taskhandle(pointer, $0) }
    }

    

    
    

    public func cancel()  {
        try! 
    rustCall() {
    
    uniffi_matrix_sdk_ffi_fn_method_taskhandle_cancel(self.pointer, $0
    )
}
    }

    public func isFinished()  -> Bool {
        return try!  FfiConverterBool.lift(
            try! 
    rustCall() {
    
    uniffi_matrix_sdk_ffi_fn_method_taskhandle_is_finished(self.pointer, $0
    )
}
        )
    }
}

public struct FfiConverterTypeTaskHandle: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = TaskHandle

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TaskHandle {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: TaskHandle, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> TaskHandle {
        return TaskHandle(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: TaskHandle) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}


public func FfiConverterTypeTaskHandle_lift(_ pointer: UnsafeMutableRawPointer) throws -> TaskHandle {
    return try FfiConverterTypeTaskHandle.lift(pointer)
}

public func FfiConverterTypeTaskHandle_lower(_ value: TaskHandle) -> UnsafeMutableRawPointer {
    return FfiConverterTypeTaskHandle.lower(value)
}


public protocol TimelineDiffProtocol {
    func append()   -> [TimelineItem]?
    func change()   -> TimelineChange
    func insert()   -> InsertData?
    func pushBack()   -> TimelineItem?
    func pushFront()   -> TimelineItem?
    func remove()   -> UInt32?
    func reset()   -> [TimelineItem]?
    func set()   -> SetData?
    
}

public class TimelineDiff: TimelineDiffProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { uniffi_matrix_sdk_ffi_fn_free_timelinediff(pointer, $0) }
    }

    

    
    

    public func append()  -> [TimelineItem]? {
        return try!  FfiConverterOptionSequenceTypeTimelineItem.lift(
            try! 
    rustCall() {
    
    uniffi_matrix_sdk_ffi_fn_method_timelinediff_append(self.pointer, $0
    )
}
        )
    }

    public func change()  -> TimelineChange {
        return try!  FfiConverterTypeTimelineChange.lift(
            try! 
    rustCall() {
    
    uniffi_matrix_sdk_ffi_fn_method_timelinediff_change(self.pointer, $0
    )
}
        )
    }

    public func insert()  -> InsertData? {
        return try!  FfiConverterOptionTypeInsertData.lift(
            try! 
    rustCall() {
    
    uniffi_matrix_sdk_ffi_fn_method_timelinediff_insert(self.pointer, $0
    )
}
        )
    }

    public func pushBack()  -> TimelineItem? {
        return try!  FfiConverterOptionTypeTimelineItem.lift(
            try! 
    rustCall() {
    
    uniffi_matrix_sdk_ffi_fn_method_timelinediff_push_back(self.pointer, $0
    )
}
        )
    }

    public func pushFront()  -> TimelineItem? {
        return try!  FfiConverterOptionTypeTimelineItem.lift(
            try! 
    rustCall() {
    
    uniffi_matrix_sdk_ffi_fn_method_timelinediff_push_front(self.pointer, $0
    )
}
        )
    }

    public func remove()  -> UInt32? {
        return try!  FfiConverterOptionUInt32.lift(
            try! 
    rustCall() {
    
    uniffi_matrix_sdk_ffi_fn_method_timelinediff_remove(self.pointer, $0
    )
}
        )
    }

    public func reset()  -> [TimelineItem]? {
        return try!  FfiConverterOptionSequenceTypeTimelineItem.lift(
            try! 
    rustCall() {
    
    uniffi_matrix_sdk_ffi_fn_method_timelinediff_reset(self.pointer, $0
    )
}
        )
    }

    public func set()  -> SetData? {
        return try!  FfiConverterOptionTypeSetData.lift(
            try! 
    rustCall() {
    
    uniffi_matrix_sdk_ffi_fn_method_timelinediff_set(self.pointer, $0
    )
}
        )
    }
}

public struct FfiConverterTypeTimelineDiff: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = TimelineDiff

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TimelineDiff {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: TimelineDiff, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> TimelineDiff {
        return TimelineDiff(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: TimelineDiff) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}


public func FfiConverterTypeTimelineDiff_lift(_ pointer: UnsafeMutableRawPointer) throws -> TimelineDiff {
    return try FfiConverterTypeTimelineDiff.lift(pointer)
}

public func FfiConverterTypeTimelineDiff_lower(_ value: TimelineDiff) -> UnsafeMutableRawPointer {
    return FfiConverterTypeTimelineDiff.lower(value)
}


public protocol TimelineEventProtocol {
    func eventId()   -> String
    func eventType()  throws -> TimelineEventType
    func senderId()   -> String
    func timestamp()   -> UInt64
    
}

public class TimelineEvent: TimelineEventProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { uniffi_matrix_sdk_ffi_fn_free_timelineevent(pointer, $0) }
    }

    

    
    

    public func eventId()  -> String {
        return try!  FfiConverterString.lift(
            try! 
    rustCall() {
    
    uniffi_matrix_sdk_ffi_fn_method_timelineevent_event_id(self.pointer, $0
    )
}
        )
    }

    public func eventType() throws -> TimelineEventType {
        return try  FfiConverterTypeTimelineEventType.lift(
            try 
    rustCallWithError(FfiConverterTypeClientError.lift) {
    uniffi_matrix_sdk_ffi_fn_method_timelineevent_event_type(self.pointer, $0
    )
}
        )
    }

    public func senderId()  -> String {
        return try!  FfiConverterString.lift(
            try! 
    rustCall() {
    
    uniffi_matrix_sdk_ffi_fn_method_timelineevent_sender_id(self.pointer, $0
    )
}
        )
    }

    public func timestamp()  -> UInt64 {
        return try!  FfiConverterUInt64.lift(
            try! 
    rustCall() {
    
    uniffi_matrix_sdk_ffi_fn_method_timelineevent_timestamp(self.pointer, $0
    )
}
        )
    }
}

public struct FfiConverterTypeTimelineEvent: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = TimelineEvent

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TimelineEvent {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: TimelineEvent, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> TimelineEvent {
        return TimelineEvent(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: TimelineEvent) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}


public func FfiConverterTypeTimelineEvent_lift(_ pointer: UnsafeMutableRawPointer) throws -> TimelineEvent {
    return try FfiConverterTypeTimelineEvent.lift(pointer)
}

public func FfiConverterTypeTimelineEvent_lower(_ value: TimelineEvent) -> UnsafeMutableRawPointer {
    return FfiConverterTypeTimelineEvent.lower(value)
}


public protocol TimelineItemProtocol {
    func asEvent()   -> EventTimelineItem?
    func asVirtual()   -> VirtualTimelineItem?
    func fmtDebug()   -> String
    func uniqueId()   -> UInt64
    
}

public class TimelineItem: TimelineItemProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { uniffi_matrix_sdk_ffi_fn_free_timelineitem(pointer, $0) }
    }

    

    
    

    public func asEvent()  -> EventTimelineItem? {
        return try!  FfiConverterOptionTypeEventTimelineItem.lift(
            try! 
    rustCall() {
    
    uniffi_matrix_sdk_ffi_fn_method_timelineitem_as_event(self.pointer, $0
    )
}
        )
    }

    public func asVirtual()  -> VirtualTimelineItem? {
        return try!  FfiConverterOptionTypeVirtualTimelineItem.lift(
            try! 
    rustCall() {
    
    uniffi_matrix_sdk_ffi_fn_method_timelineitem_as_virtual(self.pointer, $0
    )
}
        )
    }

    public func fmtDebug()  -> String {
        return try!  FfiConverterString.lift(
            try! 
    rustCall() {
    
    uniffi_matrix_sdk_ffi_fn_method_timelineitem_fmt_debug(self.pointer, $0
    )
}
        )
    }

    public func uniqueId()  -> UInt64 {
        return try!  FfiConverterUInt64.lift(
            try! 
    rustCall() {
    
    uniffi_matrix_sdk_ffi_fn_method_timelineitem_unique_id(self.pointer, $0
    )
}
        )
    }
}

public struct FfiConverterTypeTimelineItem: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = TimelineItem

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TimelineItem {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: TimelineItem, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> TimelineItem {
        return TimelineItem(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: TimelineItem) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}


public func FfiConverterTypeTimelineItem_lift(_ pointer: UnsafeMutableRawPointer) throws -> TimelineItem {
    return try FfiConverterTypeTimelineItem.lift(pointer)
}

public func FfiConverterTypeTimelineItem_lower(_ value: TimelineItem) -> UnsafeMutableRawPointer {
    return FfiConverterTypeTimelineItem.lower(value)
}


public protocol TimelineItemContentProtocol {
    func asMessage()   -> Message?
    func kind()   -> TimelineItemContentKind
    
}

public class TimelineItemContent: TimelineItemContentProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { uniffi_matrix_sdk_ffi_fn_free_timelineitemcontent(pointer, $0) }
    }

    

    
    

    public func asMessage()  -> Message? {
        return try!  FfiConverterOptionTypeMessage.lift(
            try! 
    rustCall() {
    
    uniffi_matrix_sdk_ffi_fn_method_timelineitemcontent_as_message(self.pointer, $0
    )
}
        )
    }

    public func kind()  -> TimelineItemContentKind {
        return try!  FfiConverterTypeTimelineItemContentKind.lift(
            try! 
    rustCall() {
    
    uniffi_matrix_sdk_ffi_fn_method_timelineitemcontent_kind(self.pointer, $0
    )
}
        )
    }
}

public struct FfiConverterTypeTimelineItemContent: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = TimelineItemContent

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TimelineItemContent {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: TimelineItemContent, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> TimelineItemContent {
        return TimelineItemContent(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: TimelineItemContent) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}


public func FfiConverterTypeTimelineItemContent_lift(_ pointer: UnsafeMutableRawPointer) throws -> TimelineItemContent {
    return try FfiConverterTypeTimelineItemContent.lift(pointer)
}

public func FfiConverterTypeTimelineItemContent_lower(_ value: TimelineItemContent) -> UnsafeMutableRawPointer {
    return FfiConverterTypeTimelineItemContent.lower(value)
}


public protocol UnreadNotificationsCountProtocol {
    func hasNotifications()   -> Bool
    func highlightCount()   -> UInt32
    func notificationCount()   -> UInt32
    
}

public class UnreadNotificationsCount: UnreadNotificationsCountProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { uniffi_matrix_sdk_ffi_fn_free_unreadnotificationscount(pointer, $0) }
    }

    

    
    

    public func hasNotifications()  -> Bool {
        return try!  FfiConverterBool.lift(
            try! 
    rustCall() {
    
    uniffi_matrix_sdk_ffi_fn_method_unreadnotificationscount_has_notifications(self.pointer, $0
    )
}
        )
    }

    public func highlightCount()  -> UInt32 {
        return try!  FfiConverterUInt32.lift(
            try! 
    rustCall() {
    
    uniffi_matrix_sdk_ffi_fn_method_unreadnotificationscount_highlight_count(self.pointer, $0
    )
}
        )
    }

    public func notificationCount()  -> UInt32 {
        return try!  FfiConverterUInt32.lift(
            try! 
    rustCall() {
    
    uniffi_matrix_sdk_ffi_fn_method_unreadnotificationscount_notification_count(self.pointer, $0
    )
}
        )
    }
}

public struct FfiConverterTypeUnreadNotificationsCount: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = UnreadNotificationsCount

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UnreadNotificationsCount {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: UnreadNotificationsCount, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> UnreadNotificationsCount {
        return UnreadNotificationsCount(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: UnreadNotificationsCount) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}


public func FfiConverterTypeUnreadNotificationsCount_lift(_ pointer: UnsafeMutableRawPointer) throws -> UnreadNotificationsCount {
    return try FfiConverterTypeUnreadNotificationsCount.lift(pointer)
}

public func FfiConverterTypeUnreadNotificationsCount_lower(_ value: UnreadNotificationsCount) -> UnsafeMutableRawPointer {
    return FfiConverterTypeUnreadNotificationsCount.lower(value)
}


public protocol WidgetCommProtocol {
    
}

public class WidgetComm: WidgetCommProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { uniffi_matrix_sdk_ffi_fn_free_widgetcomm(pointer, $0) }
    }

    

    
    
}

public struct FfiConverterTypeWidgetComm: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = WidgetComm

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> WidgetComm {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: WidgetComm, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> WidgetComm {
        return WidgetComm(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: WidgetComm) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}


public func FfiConverterTypeWidgetComm_lift(_ pointer: UnsafeMutableRawPointer) throws -> WidgetComm {
    return try FfiConverterTypeWidgetComm.lift(pointer)
}

public func FfiConverterTypeWidgetComm_lower(_ value: WidgetComm) -> UnsafeMutableRawPointer {
    return FfiConverterTypeWidgetComm.lower(value)
}

private let UNIFFI_RUST_TASK_CALLBACK_SUCCESS: Int8 = 0
private let UNIFFI_RUST_TASK_CALLBACK_CANCELLED: Int8 = 1
private let UNIFFI_FOREIGN_EXECUTOR_CALLBACK_SUCCESS: Int8 = 0
private let UNIFFI_FOREIGN_EXECUTOR_CALLBACK_CANCELED: Int8 = 1
private let UNIFFI_FOREIGN_EXECUTOR_CALLBACK_ERROR: Int8 = 2

// Encapsulates an executor that can run Rust tasks
//
// On Swift, `Task.detached` can handle this we just need to know what priority to send it.
public struct UniFfiForeignExecutor {
    var priority: TaskPriority

    public init(priority: TaskPriority) {
        self.priority = priority
    }

    public init() {
        self.priority = Task.currentPriority
    }
}

fileprivate struct FfiConverterForeignExecutor: FfiConverter {
    typealias SwiftType = UniFfiForeignExecutor
    // Rust uses a pointer to represent the FfiConverterForeignExecutor, but we only need a u8. 
    // let's use `Int`, which is equivalent to `size_t`
    typealias FfiType = Int

    public static func lift(_ value: FfiType) throws -> SwiftType {
        UniFfiForeignExecutor(priority: TaskPriority(rawValue: numericCast(value)))
    }
    public static func lower(_ value: SwiftType) -> FfiType {
        numericCast(value.priority.rawValue)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        fatalError("FfiConverterForeignExecutor.read not implemented yet")
    }
    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        fatalError("FfiConverterForeignExecutor.read not implemented yet")
    }
}


fileprivate func uniffiForeignExecutorCallback(executorHandle: Int, delayMs: UInt32, rustTask: UniFfiRustTaskCallback?, taskData: UnsafeRawPointer?) -> Int8 {
    if let rustTask = rustTask {
        let executor = try! FfiConverterForeignExecutor.lift(executorHandle)
        Task.detached(priority: executor.priority) {
            if delayMs != 0 {
                let nanoseconds: UInt64 = numericCast(delayMs * 1000000)
                try! await Task.sleep(nanoseconds: nanoseconds)
            }
            rustTask(taskData, UNIFFI_RUST_TASK_CALLBACK_SUCCESS)
        }
        return UNIFFI_FOREIGN_EXECUTOR_CALLBACK_SUCCESS
    } else {
        // When rustTask is null, we should drop the foreign executor.
        // However, since its just a value type, we don't need to do anything here.
        return UNIFFI_FOREIGN_EXECUTOR_CALLBACK_SUCCESS
    }
}

fileprivate func uniffiInitForeignExecutor() {
    uniffi_foreign_executor_callback_set(uniffiForeignExecutorCallback)
}


public struct AudioInfo {
    public var duration: TimeInterval?
    public var size: UInt64?
    public var mimetype: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(duration: TimeInterval?, size: UInt64?, mimetype: String?) {
        self.duration = duration
        self.size = size
        self.mimetype = mimetype
    }
}


extension AudioInfo: Equatable, Hashable {
    public static func ==(lhs: AudioInfo, rhs: AudioInfo) -> Bool {
        if lhs.duration != rhs.duration {
            return false
        }
        if lhs.size != rhs.size {
            return false
        }
        if lhs.mimetype != rhs.mimetype {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(duration)
        hasher.combine(size)
        hasher.combine(mimetype)
    }
}


public struct FfiConverterTypeAudioInfo: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AudioInfo {
        return try AudioInfo(
            duration: FfiConverterOptionDuration.read(from: &buf), 
            size: FfiConverterOptionUInt64.read(from: &buf), 
            mimetype: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: AudioInfo, into buf: inout [UInt8]) {
        FfiConverterOptionDuration.write(value.duration, into: &buf)
        FfiConverterOptionUInt64.write(value.size, into: &buf)
        FfiConverterOptionString.write(value.mimetype, into: &buf)
    }
}


public func FfiConverterTypeAudioInfo_lift(_ buf: RustBuffer) throws -> AudioInfo {
    return try FfiConverterTypeAudioInfo.lift(buf)
}

public func FfiConverterTypeAudioInfo_lower(_ value: AudioInfo) -> RustBuffer {
    return FfiConverterTypeAudioInfo.lower(value)
}


public struct AudioMessageContent {
    public var body: String
    public var source: MediaSource
    public var info: AudioInfo?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(body: String, source: MediaSource, info: AudioInfo?) {
        self.body = body
        self.source = source
        self.info = info
    }
}



public struct FfiConverterTypeAudioMessageContent: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AudioMessageContent {
        return try AudioMessageContent(
            body: FfiConverterString.read(from: &buf), 
            source: FfiConverterTypeMediaSource.read(from: &buf), 
            info: FfiConverterOptionTypeAudioInfo.read(from: &buf)
        )
    }

    public static func write(_ value: AudioMessageContent, into buf: inout [UInt8]) {
        FfiConverterString.write(value.body, into: &buf)
        FfiConverterTypeMediaSource.write(value.source, into: &buf)
        FfiConverterOptionTypeAudioInfo.write(value.info, into: &buf)
    }
}


public func FfiConverterTypeAudioMessageContent_lift(_ buf: RustBuffer) throws -> AudioMessageContent {
    return try FfiConverterTypeAudioMessageContent.lift(buf)
}

public func FfiConverterTypeAudioMessageContent_lower(_ value: AudioMessageContent) -> RustBuffer {
    return FfiConverterTypeAudioMessageContent.lower(value)
}


public struct CreateRoomParameters {
    public var name: String?
    public var topic: String?
    public var isEncrypted: Bool
    public var isDirect: Bool
    public var visibility: RoomVisibility
    public var preset: RoomPreset
    public var invite: [String]?
    public var avatar: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(name: String?, topic: String? = nil, isEncrypted: Bool, isDirect: Bool = false, visibility: RoomVisibility, preset: RoomPreset, invite: [String]? = nil, avatar: String? = nil) {
        self.name = name
        self.topic = topic
        self.isEncrypted = isEncrypted
        self.isDirect = isDirect
        self.visibility = visibility
        self.preset = preset
        self.invite = invite
        self.avatar = avatar
    }
}


extension CreateRoomParameters: Equatable, Hashable {
    public static func ==(lhs: CreateRoomParameters, rhs: CreateRoomParameters) -> Bool {
        if lhs.name != rhs.name {
            return false
        }
        if lhs.topic != rhs.topic {
            return false
        }
        if lhs.isEncrypted != rhs.isEncrypted {
            return false
        }
        if lhs.isDirect != rhs.isDirect {
            return false
        }
        if lhs.visibility != rhs.visibility {
            return false
        }
        if lhs.preset != rhs.preset {
            return false
        }
        if lhs.invite != rhs.invite {
            return false
        }
        if lhs.avatar != rhs.avatar {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(name)
        hasher.combine(topic)
        hasher.combine(isEncrypted)
        hasher.combine(isDirect)
        hasher.combine(visibility)
        hasher.combine(preset)
        hasher.combine(invite)
        hasher.combine(avatar)
    }
}


public struct FfiConverterTypeCreateRoomParameters: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> CreateRoomParameters {
        return try CreateRoomParameters(
            name: FfiConverterOptionString.read(from: &buf), 
            topic: FfiConverterOptionString.read(from: &buf), 
            isEncrypted: FfiConverterBool.read(from: &buf), 
            isDirect: FfiConverterBool.read(from: &buf), 
            visibility: FfiConverterTypeRoomVisibility.read(from: &buf), 
            preset: FfiConverterTypeRoomPreset.read(from: &buf), 
            invite: FfiConverterOptionSequenceString.read(from: &buf), 
            avatar: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: CreateRoomParameters, into buf: inout [UInt8]) {
        FfiConverterOptionString.write(value.name, into: &buf)
        FfiConverterOptionString.write(value.topic, into: &buf)
        FfiConverterBool.write(value.isEncrypted, into: &buf)
        FfiConverterBool.write(value.isDirect, into: &buf)
        FfiConverterTypeRoomVisibility.write(value.visibility, into: &buf)
        FfiConverterTypeRoomPreset.write(value.preset, into: &buf)
        FfiConverterOptionSequenceString.write(value.invite, into: &buf)
        FfiConverterOptionString.write(value.avatar, into: &buf)
    }
}


public func FfiConverterTypeCreateRoomParameters_lift(_ buf: RustBuffer) throws -> CreateRoomParameters {
    return try FfiConverterTypeCreateRoomParameters.lift(buf)
}

public func FfiConverterTypeCreateRoomParameters_lower(_ value: CreateRoomParameters) -> RustBuffer {
    return FfiConverterTypeCreateRoomParameters.lower(value)
}


public struct EmoteMessageContent {
    public var body: String
    public var formatted: FormattedBody?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(body: String, formatted: FormattedBody?) {
        self.body = body
        self.formatted = formatted
    }
}


extension EmoteMessageContent: Equatable, Hashable {
    public static func ==(lhs: EmoteMessageContent, rhs: EmoteMessageContent) -> Bool {
        if lhs.body != rhs.body {
            return false
        }
        if lhs.formatted != rhs.formatted {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(body)
        hasher.combine(formatted)
    }
}


public struct FfiConverterTypeEmoteMessageContent: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> EmoteMessageContent {
        return try EmoteMessageContent(
            body: FfiConverterString.read(from: &buf), 
            formatted: FfiConverterOptionTypeFormattedBody.read(from: &buf)
        )
    }

    public static func write(_ value: EmoteMessageContent, into buf: inout [UInt8]) {
        FfiConverterString.write(value.body, into: &buf)
        FfiConverterOptionTypeFormattedBody.write(value.formatted, into: &buf)
    }
}


public func FfiConverterTypeEmoteMessageContent_lift(_ buf: RustBuffer) throws -> EmoteMessageContent {
    return try FfiConverterTypeEmoteMessageContent.lift(buf)
}

public func FfiConverterTypeEmoteMessageContent_lower(_ value: EmoteMessageContent) -> RustBuffer {
    return FfiConverterTypeEmoteMessageContent.lower(value)
}


public struct EventTimelineItemDebugInfo {
    public var model: String
    public var originalJson: String?
    public var latestEditJson: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(model: String, originalJson: String?, latestEditJson: String?) {
        self.model = model
        self.originalJson = originalJson
        self.latestEditJson = latestEditJson
    }
}


extension EventTimelineItemDebugInfo: Equatable, Hashable {
    public static func ==(lhs: EventTimelineItemDebugInfo, rhs: EventTimelineItemDebugInfo) -> Bool {
        if lhs.model != rhs.model {
            return false
        }
        if lhs.originalJson != rhs.originalJson {
            return false
        }
        if lhs.latestEditJson != rhs.latestEditJson {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(model)
        hasher.combine(originalJson)
        hasher.combine(latestEditJson)
    }
}


public struct FfiConverterTypeEventTimelineItemDebugInfo: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> EventTimelineItemDebugInfo {
        return try EventTimelineItemDebugInfo(
            model: FfiConverterString.read(from: &buf), 
            originalJson: FfiConverterOptionString.read(from: &buf), 
            latestEditJson: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: EventTimelineItemDebugInfo, into buf: inout [UInt8]) {
        FfiConverterString.write(value.model, into: &buf)
        FfiConverterOptionString.write(value.originalJson, into: &buf)
        FfiConverterOptionString.write(value.latestEditJson, into: &buf)
    }
}


public func FfiConverterTypeEventTimelineItemDebugInfo_lift(_ buf: RustBuffer) throws -> EventTimelineItemDebugInfo {
    return try FfiConverterTypeEventTimelineItemDebugInfo.lift(buf)
}

public func FfiConverterTypeEventTimelineItemDebugInfo_lower(_ value: EventTimelineItemDebugInfo) -> RustBuffer {
    return FfiConverterTypeEventTimelineItemDebugInfo.lower(value)
}


public struct FileInfo {
    public var mimetype: String?
    public var size: UInt64?
    public var thumbnailInfo: ThumbnailInfo?
    public var thumbnailSource: MediaSource?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(mimetype: String?, size: UInt64?, thumbnailInfo: ThumbnailInfo?, thumbnailSource: MediaSource?) {
        self.mimetype = mimetype
        self.size = size
        self.thumbnailInfo = thumbnailInfo
        self.thumbnailSource = thumbnailSource
    }
}



public struct FfiConverterTypeFileInfo: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FileInfo {
        return try FileInfo(
            mimetype: FfiConverterOptionString.read(from: &buf), 
            size: FfiConverterOptionUInt64.read(from: &buf), 
            thumbnailInfo: FfiConverterOptionTypeThumbnailInfo.read(from: &buf), 
            thumbnailSource: FfiConverterOptionTypeMediaSource.read(from: &buf)
        )
    }

    public static func write(_ value: FileInfo, into buf: inout [UInt8]) {
        FfiConverterOptionString.write(value.mimetype, into: &buf)
        FfiConverterOptionUInt64.write(value.size, into: &buf)
        FfiConverterOptionTypeThumbnailInfo.write(value.thumbnailInfo, into: &buf)
        FfiConverterOptionTypeMediaSource.write(value.thumbnailSource, into: &buf)
    }
}


public func FfiConverterTypeFileInfo_lift(_ buf: RustBuffer) throws -> FileInfo {
    return try FfiConverterTypeFileInfo.lift(buf)
}

public func FfiConverterTypeFileInfo_lower(_ value: FileInfo) -> RustBuffer {
    return FfiConverterTypeFileInfo.lower(value)
}


public struct FileMessageContent {
    public var body: String
    public var filename: String?
    public var source: MediaSource
    public var info: FileInfo?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(body: String, filename: String?, source: MediaSource, info: FileInfo?) {
        self.body = body
        self.filename = filename
        self.source = source
        self.info = info
    }
}



public struct FfiConverterTypeFileMessageContent: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FileMessageContent {
        return try FileMessageContent(
            body: FfiConverterString.read(from: &buf), 
            filename: FfiConverterOptionString.read(from: &buf), 
            source: FfiConverterTypeMediaSource.read(from: &buf), 
            info: FfiConverterOptionTypeFileInfo.read(from: &buf)
        )
    }

    public static func write(_ value: FileMessageContent, into buf: inout [UInt8]) {
        FfiConverterString.write(value.body, into: &buf)
        FfiConverterOptionString.write(value.filename, into: &buf)
        FfiConverterTypeMediaSource.write(value.source, into: &buf)
        FfiConverterOptionTypeFileInfo.write(value.info, into: &buf)
    }
}


public func FfiConverterTypeFileMessageContent_lift(_ buf: RustBuffer) throws -> FileMessageContent {
    return try FfiConverterTypeFileMessageContent.lift(buf)
}

public func FfiConverterTypeFileMessageContent_lower(_ value: FileMessageContent) -> RustBuffer {
    return FfiConverterTypeFileMessageContent.lower(value)
}


public struct FormattedBody {
    public var format: MessageFormat
    public var body: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(format: MessageFormat, body: String) {
        self.format = format
        self.body = body
    }
}


extension FormattedBody: Equatable, Hashable {
    public static func ==(lhs: FormattedBody, rhs: FormattedBody) -> Bool {
        if lhs.format != rhs.format {
            return false
        }
        if lhs.body != rhs.body {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(format)
        hasher.combine(body)
    }
}


public struct FfiConverterTypeFormattedBody: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FormattedBody {
        return try FormattedBody(
            format: FfiConverterTypeMessageFormat.read(from: &buf), 
            body: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: FormattedBody, into buf: inout [UInt8]) {
        FfiConverterTypeMessageFormat.write(value.format, into: &buf)
        FfiConverterString.write(value.body, into: &buf)
    }
}


public func FfiConverterTypeFormattedBody_lift(_ buf: RustBuffer) throws -> FormattedBody {
    return try FfiConverterTypeFormattedBody.lift(buf)
}

public func FfiConverterTypeFormattedBody_lower(_ value: FormattedBody) -> RustBuffer {
    return FfiConverterTypeFormattedBody.lower(value)
}


public struct HttpPusherData {
    public var url: String
    public var format: PushFormat?
    public var defaultPayload: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(url: String, format: PushFormat?, defaultPayload: String?) {
        self.url = url
        self.format = format
        self.defaultPayload = defaultPayload
    }
}


extension HttpPusherData: Equatable, Hashable {
    public static func ==(lhs: HttpPusherData, rhs: HttpPusherData) -> Bool {
        if lhs.url != rhs.url {
            return false
        }
        if lhs.format != rhs.format {
            return false
        }
        if lhs.defaultPayload != rhs.defaultPayload {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(url)
        hasher.combine(format)
        hasher.combine(defaultPayload)
    }
}


public struct FfiConverterTypeHttpPusherData: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> HttpPusherData {
        return try HttpPusherData(
            url: FfiConverterString.read(from: &buf), 
            format: FfiConverterOptionTypePushFormat.read(from: &buf), 
            defaultPayload: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: HttpPusherData, into buf: inout [UInt8]) {
        FfiConverterString.write(value.url, into: &buf)
        FfiConverterOptionTypePushFormat.write(value.format, into: &buf)
        FfiConverterOptionString.write(value.defaultPayload, into: &buf)
    }
}


public func FfiConverterTypeHttpPusherData_lift(_ buf: RustBuffer) throws -> HttpPusherData {
    return try FfiConverterTypeHttpPusherData.lift(buf)
}

public func FfiConverterTypeHttpPusherData_lower(_ value: HttpPusherData) -> RustBuffer {
    return FfiConverterTypeHttpPusherData.lower(value)
}


public struct ImageInfo {
    public var height: UInt64?
    public var width: UInt64?
    public var mimetype: String?
    public var size: UInt64?
    public var thumbnailInfo: ThumbnailInfo?
    public var thumbnailSource: MediaSource?
    public var blurhash: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(height: UInt64?, width: UInt64?, mimetype: String?, size: UInt64?, thumbnailInfo: ThumbnailInfo?, thumbnailSource: MediaSource?, blurhash: String?) {
        self.height = height
        self.width = width
        self.mimetype = mimetype
        self.size = size
        self.thumbnailInfo = thumbnailInfo
        self.thumbnailSource = thumbnailSource
        self.blurhash = blurhash
    }
}



public struct FfiConverterTypeImageInfo: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ImageInfo {
        return try ImageInfo(
            height: FfiConverterOptionUInt64.read(from: &buf), 
            width: FfiConverterOptionUInt64.read(from: &buf), 
            mimetype: FfiConverterOptionString.read(from: &buf), 
            size: FfiConverterOptionUInt64.read(from: &buf), 
            thumbnailInfo: FfiConverterOptionTypeThumbnailInfo.read(from: &buf), 
            thumbnailSource: FfiConverterOptionTypeMediaSource.read(from: &buf), 
            blurhash: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: ImageInfo, into buf: inout [UInt8]) {
        FfiConverterOptionUInt64.write(value.height, into: &buf)
        FfiConverterOptionUInt64.write(value.width, into: &buf)
        FfiConverterOptionString.write(value.mimetype, into: &buf)
        FfiConverterOptionUInt64.write(value.size, into: &buf)
        FfiConverterOptionTypeThumbnailInfo.write(value.thumbnailInfo, into: &buf)
        FfiConverterOptionTypeMediaSource.write(value.thumbnailSource, into: &buf)
        FfiConverterOptionString.write(value.blurhash, into: &buf)
    }
}


public func FfiConverterTypeImageInfo_lift(_ buf: RustBuffer) throws -> ImageInfo {
    return try FfiConverterTypeImageInfo.lift(buf)
}

public func FfiConverterTypeImageInfo_lower(_ value: ImageInfo) -> RustBuffer {
    return FfiConverterTypeImageInfo.lower(value)
}


public struct ImageMessageContent {
    public var body: String
    public var source: MediaSource
    public var info: ImageInfo?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(body: String, source: MediaSource, info: ImageInfo?) {
        self.body = body
        self.source = source
        self.info = info
    }
}



public struct FfiConverterTypeImageMessageContent: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ImageMessageContent {
        return try ImageMessageContent(
            body: FfiConverterString.read(from: &buf), 
            source: FfiConverterTypeMediaSource.read(from: &buf), 
            info: FfiConverterOptionTypeImageInfo.read(from: &buf)
        )
    }

    public static func write(_ value: ImageMessageContent, into buf: inout [UInt8]) {
        FfiConverterString.write(value.body, into: &buf)
        FfiConverterTypeMediaSource.write(value.source, into: &buf)
        FfiConverterOptionTypeImageInfo.write(value.info, into: &buf)
    }
}


public func FfiConverterTypeImageMessageContent_lift(_ buf: RustBuffer) throws -> ImageMessageContent {
    return try FfiConverterTypeImageMessageContent.lift(buf)
}

public func FfiConverterTypeImageMessageContent_lower(_ value: ImageMessageContent) -> RustBuffer {
    return FfiConverterTypeImageMessageContent.lower(value)
}


public struct InReplyToDetails {
    public var eventId: String
    public var event: RepliedToEventDetails

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(eventId: String, event: RepliedToEventDetails) {
        self.eventId = eventId
        self.event = event
    }
}



public struct FfiConverterTypeInReplyToDetails: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> InReplyToDetails {
        return try InReplyToDetails(
            eventId: FfiConverterString.read(from: &buf), 
            event: FfiConverterTypeRepliedToEventDetails.read(from: &buf)
        )
    }

    public static func write(_ value: InReplyToDetails, into buf: inout [UInt8]) {
        FfiConverterString.write(value.eventId, into: &buf)
        FfiConverterTypeRepliedToEventDetails.write(value.event, into: &buf)
    }
}


public func FfiConverterTypeInReplyToDetails_lift(_ buf: RustBuffer) throws -> InReplyToDetails {
    return try FfiConverterTypeInReplyToDetails.lift(buf)
}

public func FfiConverterTypeInReplyToDetails_lower(_ value: InReplyToDetails) -> RustBuffer {
    return FfiConverterTypeInReplyToDetails.lower(value)
}


public struct InsertData {
    public var index: UInt32
    public var item: TimelineItem

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(index: UInt32, item: TimelineItem) {
        self.index = index
        self.item = item
    }
}



public struct FfiConverterTypeInsertData: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> InsertData {
        return try InsertData(
            index: FfiConverterUInt32.read(from: &buf), 
            item: FfiConverterTypeTimelineItem.read(from: &buf)
        )
    }

    public static func write(_ value: InsertData, into buf: inout [UInt8]) {
        FfiConverterUInt32.write(value.index, into: &buf)
        FfiConverterTypeTimelineItem.write(value.item, into: &buf)
    }
}


public func FfiConverterTypeInsertData_lift(_ buf: RustBuffer) throws -> InsertData {
    return try FfiConverterTypeInsertData.lift(buf)
}

public func FfiConverterTypeInsertData_lower(_ value: InsertData) -> RustBuffer {
    return FfiConverterTypeInsertData.lower(value)
}


public struct LocationContent {
    public var body: String
    public var geoUri: String
    public var description: String?
    public var zoomLevel: UInt8?
    public var asset: AssetType?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(body: String, geoUri: String, description: String?, zoomLevel: UInt8?, asset: AssetType?) {
        self.body = body
        self.geoUri = geoUri
        self.description = description
        self.zoomLevel = zoomLevel
        self.asset = asset
    }
}


extension LocationContent: Equatable, Hashable {
    public static func ==(lhs: LocationContent, rhs: LocationContent) -> Bool {
        if lhs.body != rhs.body {
            return false
        }
        if lhs.geoUri != rhs.geoUri {
            return false
        }
        if lhs.description != rhs.description {
            return false
        }
        if lhs.zoomLevel != rhs.zoomLevel {
            return false
        }
        if lhs.asset != rhs.asset {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(body)
        hasher.combine(geoUri)
        hasher.combine(description)
        hasher.combine(zoomLevel)
        hasher.combine(asset)
    }
}


public struct FfiConverterTypeLocationContent: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LocationContent {
        return try LocationContent(
            body: FfiConverterString.read(from: &buf), 
            geoUri: FfiConverterString.read(from: &buf), 
            description: FfiConverterOptionString.read(from: &buf), 
            zoomLevel: FfiConverterOptionUInt8.read(from: &buf), 
            asset: FfiConverterOptionTypeAssetType.read(from: &buf)
        )
    }

    public static func write(_ value: LocationContent, into buf: inout [UInt8]) {
        FfiConverterString.write(value.body, into: &buf)
        FfiConverterString.write(value.geoUri, into: &buf)
        FfiConverterOptionString.write(value.description, into: &buf)
        FfiConverterOptionUInt8.write(value.zoomLevel, into: &buf)
        FfiConverterOptionTypeAssetType.write(value.asset, into: &buf)
    }
}


public func FfiConverterTypeLocationContent_lift(_ buf: RustBuffer) throws -> LocationContent {
    return try FfiConverterTypeLocationContent.lift(buf)
}

public func FfiConverterTypeLocationContent_lower(_ value: LocationContent) -> RustBuffer {
    return FfiConverterTypeLocationContent.lower(value)
}


public struct NoticeMessageContent {
    public var body: String
    public var formatted: FormattedBody?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(body: String, formatted: FormattedBody?) {
        self.body = body
        self.formatted = formatted
    }
}


extension NoticeMessageContent: Equatable, Hashable {
    public static func ==(lhs: NoticeMessageContent, rhs: NoticeMessageContent) -> Bool {
        if lhs.body != rhs.body {
            return false
        }
        if lhs.formatted != rhs.formatted {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(body)
        hasher.combine(formatted)
    }
}


public struct FfiConverterTypeNoticeMessageContent: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NoticeMessageContent {
        return try NoticeMessageContent(
            body: FfiConverterString.read(from: &buf), 
            formatted: FfiConverterOptionTypeFormattedBody.read(from: &buf)
        )
    }

    public static func write(_ value: NoticeMessageContent, into buf: inout [UInt8]) {
        FfiConverterString.write(value.body, into: &buf)
        FfiConverterOptionTypeFormattedBody.write(value.formatted, into: &buf)
    }
}


public func FfiConverterTypeNoticeMessageContent_lift(_ buf: RustBuffer) throws -> NoticeMessageContent {
    return try FfiConverterTypeNoticeMessageContent.lift(buf)
}

public func FfiConverterTypeNoticeMessageContent_lower(_ value: NoticeMessageContent) -> RustBuffer {
    return FfiConverterTypeNoticeMessageContent.lower(value)
}


public struct NotificationItem {
    public var event: NotificationEvent
    public var senderInfo: NotificationSenderInfo
    public var roomInfo: NotificationRoomInfo
    public var isNoisy: Bool?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(event: NotificationEvent, senderInfo: NotificationSenderInfo, roomInfo: NotificationRoomInfo, isNoisy: Bool?) {
        self.event = event
        self.senderInfo = senderInfo
        self.roomInfo = roomInfo
        self.isNoisy = isNoisy
    }
}



public struct FfiConverterTypeNotificationItem: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NotificationItem {
        return try NotificationItem(
            event: FfiConverterTypeNotificationEvent.read(from: &buf), 
            senderInfo: FfiConverterTypeNotificationSenderInfo.read(from: &buf), 
            roomInfo: FfiConverterTypeNotificationRoomInfo.read(from: &buf), 
            isNoisy: FfiConverterOptionBool.read(from: &buf)
        )
    }

    public static func write(_ value: NotificationItem, into buf: inout [UInt8]) {
        FfiConverterTypeNotificationEvent.write(value.event, into: &buf)
        FfiConverterTypeNotificationSenderInfo.write(value.senderInfo, into: &buf)
        FfiConverterTypeNotificationRoomInfo.write(value.roomInfo, into: &buf)
        FfiConverterOptionBool.write(value.isNoisy, into: &buf)
    }
}


public func FfiConverterTypeNotificationItem_lift(_ buf: RustBuffer) throws -> NotificationItem {
    return try FfiConverterTypeNotificationItem.lift(buf)
}

public func FfiConverterTypeNotificationItem_lower(_ value: NotificationItem) -> RustBuffer {
    return FfiConverterTypeNotificationItem.lower(value)
}


public struct NotificationRoomInfo {
    public var displayName: String
    public var avatarUrl: String?
    public var canonicalAlias: String?
    public var joinedMembersCount: UInt64
    public var isEncrypted: Bool?
    public var isDirect: Bool

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(displayName: String, avatarUrl: String?, canonicalAlias: String?, joinedMembersCount: UInt64, isEncrypted: Bool?, isDirect: Bool) {
        self.displayName = displayName
        self.avatarUrl = avatarUrl
        self.canonicalAlias = canonicalAlias
        self.joinedMembersCount = joinedMembersCount
        self.isEncrypted = isEncrypted
        self.isDirect = isDirect
    }
}


extension NotificationRoomInfo: Equatable, Hashable {
    public static func ==(lhs: NotificationRoomInfo, rhs: NotificationRoomInfo) -> Bool {
        if lhs.displayName != rhs.displayName {
            return false
        }
        if lhs.avatarUrl != rhs.avatarUrl {
            return false
        }
        if lhs.canonicalAlias != rhs.canonicalAlias {
            return false
        }
        if lhs.joinedMembersCount != rhs.joinedMembersCount {
            return false
        }
        if lhs.isEncrypted != rhs.isEncrypted {
            return false
        }
        if lhs.isDirect != rhs.isDirect {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(displayName)
        hasher.combine(avatarUrl)
        hasher.combine(canonicalAlias)
        hasher.combine(joinedMembersCount)
        hasher.combine(isEncrypted)
        hasher.combine(isDirect)
    }
}


public struct FfiConverterTypeNotificationRoomInfo: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NotificationRoomInfo {
        return try NotificationRoomInfo(
            displayName: FfiConverterString.read(from: &buf), 
            avatarUrl: FfiConverterOptionString.read(from: &buf), 
            canonicalAlias: FfiConverterOptionString.read(from: &buf), 
            joinedMembersCount: FfiConverterUInt64.read(from: &buf), 
            isEncrypted: FfiConverterOptionBool.read(from: &buf), 
            isDirect: FfiConverterBool.read(from: &buf)
        )
    }

    public static func write(_ value: NotificationRoomInfo, into buf: inout [UInt8]) {
        FfiConverterString.write(value.displayName, into: &buf)
        FfiConverterOptionString.write(value.avatarUrl, into: &buf)
        FfiConverterOptionString.write(value.canonicalAlias, into: &buf)
        FfiConverterUInt64.write(value.joinedMembersCount, into: &buf)
        FfiConverterOptionBool.write(value.isEncrypted, into: &buf)
        FfiConverterBool.write(value.isDirect, into: &buf)
    }
}


public func FfiConverterTypeNotificationRoomInfo_lift(_ buf: RustBuffer) throws -> NotificationRoomInfo {
    return try FfiConverterTypeNotificationRoomInfo.lift(buf)
}

public func FfiConverterTypeNotificationRoomInfo_lower(_ value: NotificationRoomInfo) -> RustBuffer {
    return FfiConverterTypeNotificationRoomInfo.lower(value)
}


public struct NotificationSenderInfo {
    public var displayName: String?
    public var avatarUrl: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(displayName: String?, avatarUrl: String?) {
        self.displayName = displayName
        self.avatarUrl = avatarUrl
    }
}


extension NotificationSenderInfo: Equatable, Hashable {
    public static func ==(lhs: NotificationSenderInfo, rhs: NotificationSenderInfo) -> Bool {
        if lhs.displayName != rhs.displayName {
            return false
        }
        if lhs.avatarUrl != rhs.avatarUrl {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(displayName)
        hasher.combine(avatarUrl)
    }
}


public struct FfiConverterTypeNotificationSenderInfo: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NotificationSenderInfo {
        return try NotificationSenderInfo(
            displayName: FfiConverterOptionString.read(from: &buf), 
            avatarUrl: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: NotificationSenderInfo, into buf: inout [UInt8]) {
        FfiConverterOptionString.write(value.displayName, into: &buf)
        FfiConverterOptionString.write(value.avatarUrl, into: &buf)
    }
}


public func FfiConverterTypeNotificationSenderInfo_lift(_ buf: RustBuffer) throws -> NotificationSenderInfo {
    return try FfiConverterTypeNotificationSenderInfo.lift(buf)
}

public func FfiConverterTypeNotificationSenderInfo_lower(_ value: NotificationSenderInfo) -> RustBuffer {
    return FfiConverterTypeNotificationSenderInfo.lower(value)
}


public struct OidcConfiguration {
    public var clientName: String?
    public var redirectUri: String
    public var clientUri: String?
    public var logoUri: String?
    public var tosUri: String?
    public var policyUri: String?
    public var staticRegistrations: [String: String]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(clientName: String?, redirectUri: String, clientUri: String?, logoUri: String?, tosUri: String?, policyUri: String?, staticRegistrations: [String: String]) {
        self.clientName = clientName
        self.redirectUri = redirectUri
        self.clientUri = clientUri
        self.logoUri = logoUri
        self.tosUri = tosUri
        self.policyUri = policyUri
        self.staticRegistrations = staticRegistrations
    }
}


extension OidcConfiguration: Equatable, Hashable {
    public static func ==(lhs: OidcConfiguration, rhs: OidcConfiguration) -> Bool {
        if lhs.clientName != rhs.clientName {
            return false
        }
        if lhs.redirectUri != rhs.redirectUri {
            return false
        }
        if lhs.clientUri != rhs.clientUri {
            return false
        }
        if lhs.logoUri != rhs.logoUri {
            return false
        }
        if lhs.tosUri != rhs.tosUri {
            return false
        }
        if lhs.policyUri != rhs.policyUri {
            return false
        }
        if lhs.staticRegistrations != rhs.staticRegistrations {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(clientName)
        hasher.combine(redirectUri)
        hasher.combine(clientUri)
        hasher.combine(logoUri)
        hasher.combine(tosUri)
        hasher.combine(policyUri)
        hasher.combine(staticRegistrations)
    }
}


public struct FfiConverterTypeOidcConfiguration: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> OidcConfiguration {
        return try OidcConfiguration(
            clientName: FfiConverterOptionString.read(from: &buf), 
            redirectUri: FfiConverterString.read(from: &buf), 
            clientUri: FfiConverterOptionString.read(from: &buf), 
            logoUri: FfiConverterOptionString.read(from: &buf), 
            tosUri: FfiConverterOptionString.read(from: &buf), 
            policyUri: FfiConverterOptionString.read(from: &buf), 
            staticRegistrations: FfiConverterDictionaryStringString.read(from: &buf)
        )
    }

    public static func write(_ value: OidcConfiguration, into buf: inout [UInt8]) {
        FfiConverterOptionString.write(value.clientName, into: &buf)
        FfiConverterString.write(value.redirectUri, into: &buf)
        FfiConverterOptionString.write(value.clientUri, into: &buf)
        FfiConverterOptionString.write(value.logoUri, into: &buf)
        FfiConverterOptionString.write(value.tosUri, into: &buf)
        FfiConverterOptionString.write(value.policyUri, into: &buf)
        FfiConverterDictionaryStringString.write(value.staticRegistrations, into: &buf)
    }
}


public func FfiConverterTypeOidcConfiguration_lift(_ buf: RustBuffer) throws -> OidcConfiguration {
    return try FfiConverterTypeOidcConfiguration.lift(buf)
}

public func FfiConverterTypeOidcConfiguration_lower(_ value: OidcConfiguration) -> RustBuffer {
    return FfiConverterTypeOidcConfiguration.lower(value)
}


public struct OtlpTracingConfiguration {
    public var clientName: String
    public var user: String
    public var password: String
    public var otlpEndpoint: String
    public var filter: String
    public var writeToStdoutOrSystem: Bool
    public var writeToFiles: TracingFileConfiguration?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(clientName: String, user: String, password: String, otlpEndpoint: String, filter: String, writeToStdoutOrSystem: Bool, writeToFiles: TracingFileConfiguration?) {
        self.clientName = clientName
        self.user = user
        self.password = password
        self.otlpEndpoint = otlpEndpoint
        self.filter = filter
        self.writeToStdoutOrSystem = writeToStdoutOrSystem
        self.writeToFiles = writeToFiles
    }
}


extension OtlpTracingConfiguration: Equatable, Hashable {
    public static func ==(lhs: OtlpTracingConfiguration, rhs: OtlpTracingConfiguration) -> Bool {
        if lhs.clientName != rhs.clientName {
            return false
        }
        if lhs.user != rhs.user {
            return false
        }
        if lhs.password != rhs.password {
            return false
        }
        if lhs.otlpEndpoint != rhs.otlpEndpoint {
            return false
        }
        if lhs.filter != rhs.filter {
            return false
        }
        if lhs.writeToStdoutOrSystem != rhs.writeToStdoutOrSystem {
            return false
        }
        if lhs.writeToFiles != rhs.writeToFiles {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(clientName)
        hasher.combine(user)
        hasher.combine(password)
        hasher.combine(otlpEndpoint)
        hasher.combine(filter)
        hasher.combine(writeToStdoutOrSystem)
        hasher.combine(writeToFiles)
    }
}


public struct FfiConverterTypeOtlpTracingConfiguration: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> OtlpTracingConfiguration {
        return try OtlpTracingConfiguration(
            clientName: FfiConverterString.read(from: &buf), 
            user: FfiConverterString.read(from: &buf), 
            password: FfiConverterString.read(from: &buf), 
            otlpEndpoint: FfiConverterString.read(from: &buf), 
            filter: FfiConverterString.read(from: &buf), 
            writeToStdoutOrSystem: FfiConverterBool.read(from: &buf), 
            writeToFiles: FfiConverterOptionTypeTracingFileConfiguration.read(from: &buf)
        )
    }

    public static func write(_ value: OtlpTracingConfiguration, into buf: inout [UInt8]) {
        FfiConverterString.write(value.clientName, into: &buf)
        FfiConverterString.write(value.user, into: &buf)
        FfiConverterString.write(value.password, into: &buf)
        FfiConverterString.write(value.otlpEndpoint, into: &buf)
        FfiConverterString.write(value.filter, into: &buf)
        FfiConverterBool.write(value.writeToStdoutOrSystem, into: &buf)
        FfiConverterOptionTypeTracingFileConfiguration.write(value.writeToFiles, into: &buf)
    }
}


public func FfiConverterTypeOtlpTracingConfiguration_lift(_ buf: RustBuffer) throws -> OtlpTracingConfiguration {
    return try FfiConverterTypeOtlpTracingConfiguration.lift(buf)
}

public func FfiConverterTypeOtlpTracingConfiguration_lower(_ value: OtlpTracingConfiguration) -> RustBuffer {
    return FfiConverterTypeOtlpTracingConfiguration.lower(value)
}


public struct PollAnswer {
    public var id: String
    public var text: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(id: String, text: String) {
        self.id = id
        self.text = text
    }
}


extension PollAnswer: Equatable, Hashable {
    public static func ==(lhs: PollAnswer, rhs: PollAnswer) -> Bool {
        if lhs.id != rhs.id {
            return false
        }
        if lhs.text != rhs.text {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(id)
        hasher.combine(text)
    }
}


public struct FfiConverterTypePollAnswer: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PollAnswer {
        return try PollAnswer(
            id: FfiConverterString.read(from: &buf), 
            text: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: PollAnswer, into buf: inout [UInt8]) {
        FfiConverterString.write(value.id, into: &buf)
        FfiConverterString.write(value.text, into: &buf)
    }
}


public func FfiConverterTypePollAnswer_lift(_ buf: RustBuffer) throws -> PollAnswer {
    return try FfiConverterTypePollAnswer.lift(buf)
}

public func FfiConverterTypePollAnswer_lower(_ value: PollAnswer) -> RustBuffer {
    return FfiConverterTypePollAnswer.lower(value)
}


public struct PusherIdentifiers {
    public var pushkey: String
    public var appId: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(pushkey: String, appId: String) {
        self.pushkey = pushkey
        self.appId = appId
    }
}


extension PusherIdentifiers: Equatable, Hashable {
    public static func ==(lhs: PusherIdentifiers, rhs: PusherIdentifiers) -> Bool {
        if lhs.pushkey != rhs.pushkey {
            return false
        }
        if lhs.appId != rhs.appId {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(pushkey)
        hasher.combine(appId)
    }
}


public struct FfiConverterTypePusherIdentifiers: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PusherIdentifiers {
        return try PusherIdentifiers(
            pushkey: FfiConverterString.read(from: &buf), 
            appId: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: PusherIdentifiers, into buf: inout [UInt8]) {
        FfiConverterString.write(value.pushkey, into: &buf)
        FfiConverterString.write(value.appId, into: &buf)
    }
}


public func FfiConverterTypePusherIdentifiers_lift(_ buf: RustBuffer) throws -> PusherIdentifiers {
    return try FfiConverterTypePusherIdentifiers.lift(buf)
}

public func FfiConverterTypePusherIdentifiers_lower(_ value: PusherIdentifiers) -> RustBuffer {
    return FfiConverterTypePusherIdentifiers.lower(value)
}


public struct Reaction {
    public var key: String
    public var count: UInt64
    public var senders: [ReactionSenderData]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(key: String, count: UInt64, senders: [ReactionSenderData]) {
        self.key = key
        self.count = count
        self.senders = senders
    }
}


extension Reaction: Equatable, Hashable {
    public static func ==(lhs: Reaction, rhs: Reaction) -> Bool {
        if lhs.key != rhs.key {
            return false
        }
        if lhs.count != rhs.count {
            return false
        }
        if lhs.senders != rhs.senders {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(key)
        hasher.combine(count)
        hasher.combine(senders)
    }
}


public struct FfiConverterTypeReaction: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Reaction {
        return try Reaction(
            key: FfiConverterString.read(from: &buf), 
            count: FfiConverterUInt64.read(from: &buf), 
            senders: FfiConverterSequenceTypeReactionSenderData.read(from: &buf)
        )
    }

    public static func write(_ value: Reaction, into buf: inout [UInt8]) {
        FfiConverterString.write(value.key, into: &buf)
        FfiConverterUInt64.write(value.count, into: &buf)
        FfiConverterSequenceTypeReactionSenderData.write(value.senders, into: &buf)
    }
}


public func FfiConverterTypeReaction_lift(_ buf: RustBuffer) throws -> Reaction {
    return try FfiConverterTypeReaction.lift(buf)
}

public func FfiConverterTypeReaction_lower(_ value: Reaction) -> RustBuffer {
    return FfiConverterTypeReaction.lower(value)
}


public struct ReactionSenderData {
    public var senderId: String
    public var timestamp: UInt64

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(senderId: String, timestamp: UInt64) {
        self.senderId = senderId
        self.timestamp = timestamp
    }
}


extension ReactionSenderData: Equatable, Hashable {
    public static func ==(lhs: ReactionSenderData, rhs: ReactionSenderData) -> Bool {
        if lhs.senderId != rhs.senderId {
            return false
        }
        if lhs.timestamp != rhs.timestamp {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(senderId)
        hasher.combine(timestamp)
    }
}


public struct FfiConverterTypeReactionSenderData: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ReactionSenderData {
        return try ReactionSenderData(
            senderId: FfiConverterString.read(from: &buf), 
            timestamp: FfiConverterUInt64.read(from: &buf)
        )
    }

    public static func write(_ value: ReactionSenderData, into buf: inout [UInt8]) {
        FfiConverterString.write(value.senderId, into: &buf)
        FfiConverterUInt64.write(value.timestamp, into: &buf)
    }
}


public func FfiConverterTypeReactionSenderData_lift(_ buf: RustBuffer) throws -> ReactionSenderData {
    return try FfiConverterTypeReactionSenderData.lift(buf)
}

public func FfiConverterTypeReactionSenderData_lower(_ value: ReactionSenderData) -> RustBuffer {
    return FfiConverterTypeReactionSenderData.lower(value)
}


public struct Receipt {
    public var timestamp: UInt64?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(timestamp: UInt64?) {
        self.timestamp = timestamp
    }
}


extension Receipt: Equatable, Hashable {
    public static func ==(lhs: Receipt, rhs: Receipt) -> Bool {
        if lhs.timestamp != rhs.timestamp {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(timestamp)
    }
}


public struct FfiConverterTypeReceipt: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Receipt {
        return try Receipt(
            timestamp: FfiConverterOptionUInt64.read(from: &buf)
        )
    }

    public static func write(_ value: Receipt, into buf: inout [UInt8]) {
        FfiConverterOptionUInt64.write(value.timestamp, into: &buf)
    }
}


public func FfiConverterTypeReceipt_lift(_ buf: RustBuffer) throws -> Receipt {
    return try FfiConverterTypeReceipt.lift(buf)
}

public func FfiConverterTypeReceipt_lower(_ value: Receipt) -> RustBuffer {
    return FfiConverterTypeReceipt.lower(value)
}


public struct RequiredState {
    public var key: String
    public var value: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(key: String, value: String) {
        self.key = key
        self.value = value
    }
}


extension RequiredState: Equatable, Hashable {
    public static func ==(lhs: RequiredState, rhs: RequiredState) -> Bool {
        if lhs.key != rhs.key {
            return false
        }
        if lhs.value != rhs.value {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(key)
        hasher.combine(value)
    }
}


public struct FfiConverterTypeRequiredState: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RequiredState {
        return try RequiredState(
            key: FfiConverterString.read(from: &buf), 
            value: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: RequiredState, into buf: inout [UInt8]) {
        FfiConverterString.write(value.key, into: &buf)
        FfiConverterString.write(value.value, into: &buf)
    }
}


public func FfiConverterTypeRequiredState_lift(_ buf: RustBuffer) throws -> RequiredState {
    return try FfiConverterTypeRequiredState.lift(buf)
}

public func FfiConverterTypeRequiredState_lower(_ value: RequiredState) -> RustBuffer {
    return FfiConverterTypeRequiredState.lower(value)
}


public struct RoomInfo {
    public var id: String
    public var name: String?
    public var topic: String?
    public var avatarUrl: String?
    public var isDirect: Bool
    public var isPublic: Bool
    public var isSpace: Bool
    public var isTombstoned: Bool
    public var canonicalAlias: String?
    public var alternativeAliases: [String]
    public var membership: Membership
    public var latestEvent: EventTimelineItem?
    public var inviter: RoomMember?
    public var activeMembersCount: UInt64
    public var invitedMembersCount: UInt64
    public var joinedMembersCount: UInt64
    public var highlightCount: UInt64
    public var notificationCount: UInt64
    public var notificationMode: RoomNotificationMode?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(id: String, name: String?, topic: String?, avatarUrl: String?, isDirect: Bool, isPublic: Bool, isSpace: Bool, isTombstoned: Bool, canonicalAlias: String?, alternativeAliases: [String], membership: Membership, latestEvent: EventTimelineItem?, inviter: RoomMember?, activeMembersCount: UInt64, invitedMembersCount: UInt64, joinedMembersCount: UInt64, highlightCount: UInt64, notificationCount: UInt64, notificationMode: RoomNotificationMode?) {
        self.id = id
        self.name = name
        self.topic = topic
        self.avatarUrl = avatarUrl
        self.isDirect = isDirect
        self.isPublic = isPublic
        self.isSpace = isSpace
        self.isTombstoned = isTombstoned
        self.canonicalAlias = canonicalAlias
        self.alternativeAliases = alternativeAliases
        self.membership = membership
        self.latestEvent = latestEvent
        self.inviter = inviter
        self.activeMembersCount = activeMembersCount
        self.invitedMembersCount = invitedMembersCount
        self.joinedMembersCount = joinedMembersCount
        self.highlightCount = highlightCount
        self.notificationCount = notificationCount
        self.notificationMode = notificationMode
    }
}



public struct FfiConverterTypeRoomInfo: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RoomInfo {
        return try RoomInfo(
            id: FfiConverterString.read(from: &buf), 
            name: FfiConverterOptionString.read(from: &buf), 
            topic: FfiConverterOptionString.read(from: &buf), 
            avatarUrl: FfiConverterOptionString.read(from: &buf), 
            isDirect: FfiConverterBool.read(from: &buf), 
            isPublic: FfiConverterBool.read(from: &buf), 
            isSpace: FfiConverterBool.read(from: &buf), 
            isTombstoned: FfiConverterBool.read(from: &buf), 
            canonicalAlias: FfiConverterOptionString.read(from: &buf), 
            alternativeAliases: FfiConverterSequenceString.read(from: &buf), 
            membership: FfiConverterTypeMembership.read(from: &buf), 
            latestEvent: FfiConverterOptionTypeEventTimelineItem.read(from: &buf), 
            inviter: FfiConverterOptionTypeRoomMember.read(from: &buf), 
            activeMembersCount: FfiConverterUInt64.read(from: &buf), 
            invitedMembersCount: FfiConverterUInt64.read(from: &buf), 
            joinedMembersCount: FfiConverterUInt64.read(from: &buf), 
            highlightCount: FfiConverterUInt64.read(from: &buf), 
            notificationCount: FfiConverterUInt64.read(from: &buf), 
            notificationMode: FfiConverterOptionTypeRoomNotificationMode.read(from: &buf)
        )
    }

    public static func write(_ value: RoomInfo, into buf: inout [UInt8]) {
        FfiConverterString.write(value.id, into: &buf)
        FfiConverterOptionString.write(value.name, into: &buf)
        FfiConverterOptionString.write(value.topic, into: &buf)
        FfiConverterOptionString.write(value.avatarUrl, into: &buf)
        FfiConverterBool.write(value.isDirect, into: &buf)
        FfiConverterBool.write(value.isPublic, into: &buf)
        FfiConverterBool.write(value.isSpace, into: &buf)
        FfiConverterBool.write(value.isTombstoned, into: &buf)
        FfiConverterOptionString.write(value.canonicalAlias, into: &buf)
        FfiConverterSequenceString.write(value.alternativeAliases, into: &buf)
        FfiConverterTypeMembership.write(value.membership, into: &buf)
        FfiConverterOptionTypeEventTimelineItem.write(value.latestEvent, into: &buf)
        FfiConverterOptionTypeRoomMember.write(value.inviter, into: &buf)
        FfiConverterUInt64.write(value.activeMembersCount, into: &buf)
        FfiConverterUInt64.write(value.invitedMembersCount, into: &buf)
        FfiConverterUInt64.write(value.joinedMembersCount, into: &buf)
        FfiConverterUInt64.write(value.highlightCount, into: &buf)
        FfiConverterUInt64.write(value.notificationCount, into: &buf)
        FfiConverterOptionTypeRoomNotificationMode.write(value.notificationMode, into: &buf)
    }
}


public func FfiConverterTypeRoomInfo_lift(_ buf: RustBuffer) throws -> RoomInfo {
    return try FfiConverterTypeRoomInfo.lift(buf)
}

public func FfiConverterTypeRoomInfo_lower(_ value: RoomInfo) -> RustBuffer {
    return FfiConverterTypeRoomInfo.lower(value)
}


public struct RoomListEntriesResult {
    public var entries: [RoomListEntry]
    public var entriesStream: TaskHandle

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(entries: [RoomListEntry], entriesStream: TaskHandle) {
        self.entries = entries
        self.entriesStream = entriesStream
    }
}



public struct FfiConverterTypeRoomListEntriesResult: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RoomListEntriesResult {
        return try RoomListEntriesResult(
            entries: FfiConverterSequenceTypeRoomListEntry.read(from: &buf), 
            entriesStream: FfiConverterTypeTaskHandle.read(from: &buf)
        )
    }

    public static func write(_ value: RoomListEntriesResult, into buf: inout [UInt8]) {
        FfiConverterSequenceTypeRoomListEntry.write(value.entries, into: &buf)
        FfiConverterTypeTaskHandle.write(value.entriesStream, into: &buf)
    }
}


public func FfiConverterTypeRoomListEntriesResult_lift(_ buf: RustBuffer) throws -> RoomListEntriesResult {
    return try FfiConverterTypeRoomListEntriesResult.lift(buf)
}

public func FfiConverterTypeRoomListEntriesResult_lower(_ value: RoomListEntriesResult) -> RustBuffer {
    return FfiConverterTypeRoomListEntriesResult.lower(value)
}


public struct RoomListEntriesWithDynamicFilterResult {
    public var dynamicFilter: RoomListEntriesDynamicFilter
    public var entriesStream: TaskHandle

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(dynamicFilter: RoomListEntriesDynamicFilter, entriesStream: TaskHandle) {
        self.dynamicFilter = dynamicFilter
        self.entriesStream = entriesStream
    }
}



public struct FfiConverterTypeRoomListEntriesWithDynamicFilterResult: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RoomListEntriesWithDynamicFilterResult {
        return try RoomListEntriesWithDynamicFilterResult(
            dynamicFilter: FfiConverterTypeRoomListEntriesDynamicFilter.read(from: &buf), 
            entriesStream: FfiConverterTypeTaskHandle.read(from: &buf)
        )
    }

    public static func write(_ value: RoomListEntriesWithDynamicFilterResult, into buf: inout [UInt8]) {
        FfiConverterTypeRoomListEntriesDynamicFilter.write(value.dynamicFilter, into: &buf)
        FfiConverterTypeTaskHandle.write(value.entriesStream, into: &buf)
    }
}


public func FfiConverterTypeRoomListEntriesWithDynamicFilterResult_lift(_ buf: RustBuffer) throws -> RoomListEntriesWithDynamicFilterResult {
    return try FfiConverterTypeRoomListEntriesWithDynamicFilterResult.lift(buf)
}

public func FfiConverterTypeRoomListEntriesWithDynamicFilterResult_lower(_ value: RoomListEntriesWithDynamicFilterResult) -> RustBuffer {
    return FfiConverterTypeRoomListEntriesWithDynamicFilterResult.lower(value)
}


public struct RoomListLoadingStateResult {
    public var state: RoomListLoadingState
    public var stateStream: TaskHandle

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(state: RoomListLoadingState, stateStream: TaskHandle) {
        self.state = state
        self.stateStream = stateStream
    }
}



public struct FfiConverterTypeRoomListLoadingStateResult: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RoomListLoadingStateResult {
        return try RoomListLoadingStateResult(
            state: FfiConverterTypeRoomListLoadingState.read(from: &buf), 
            stateStream: FfiConverterTypeTaskHandle.read(from: &buf)
        )
    }

    public static func write(_ value: RoomListLoadingStateResult, into buf: inout [UInt8]) {
        FfiConverterTypeRoomListLoadingState.write(value.state, into: &buf)
        FfiConverterTypeTaskHandle.write(value.stateStream, into: &buf)
    }
}


public func FfiConverterTypeRoomListLoadingStateResult_lift(_ buf: RustBuffer) throws -> RoomListLoadingStateResult {
    return try FfiConverterTypeRoomListLoadingStateResult.lift(buf)
}

public func FfiConverterTypeRoomListLoadingStateResult_lower(_ value: RoomListLoadingStateResult) -> RustBuffer {
    return FfiConverterTypeRoomListLoadingStateResult.lower(value)
}


public struct RoomListRange {
    public var start: UInt32
    public var endInclusive: UInt32

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(start: UInt32, endInclusive: UInt32) {
        self.start = start
        self.endInclusive = endInclusive
    }
}


extension RoomListRange: Equatable, Hashable {
    public static func ==(lhs: RoomListRange, rhs: RoomListRange) -> Bool {
        if lhs.start != rhs.start {
            return false
        }
        if lhs.endInclusive != rhs.endInclusive {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(start)
        hasher.combine(endInclusive)
    }
}


public struct FfiConverterTypeRoomListRange: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RoomListRange {
        return try RoomListRange(
            start: FfiConverterUInt32.read(from: &buf), 
            endInclusive: FfiConverterUInt32.read(from: &buf)
        )
    }

    public static func write(_ value: RoomListRange, into buf: inout [UInt8]) {
        FfiConverterUInt32.write(value.start, into: &buf)
        FfiConverterUInt32.write(value.endInclusive, into: &buf)
    }
}


public func FfiConverterTypeRoomListRange_lift(_ buf: RustBuffer) throws -> RoomListRange {
    return try FfiConverterTypeRoomListRange.lift(buf)
}

public func FfiConverterTypeRoomListRange_lower(_ value: RoomListRange) -> RustBuffer {
    return FfiConverterTypeRoomListRange.lower(value)
}


public struct RoomNotificationSettings {
    public var mode: RoomNotificationMode
    public var isDefault: Bool

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(mode: RoomNotificationMode, isDefault: Bool) {
        self.mode = mode
        self.isDefault = isDefault
    }
}


extension RoomNotificationSettings: Equatable, Hashable {
    public static func ==(lhs: RoomNotificationSettings, rhs: RoomNotificationSettings) -> Bool {
        if lhs.mode != rhs.mode {
            return false
        }
        if lhs.isDefault != rhs.isDefault {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(mode)
        hasher.combine(isDefault)
    }
}


public struct FfiConverterTypeRoomNotificationSettings: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RoomNotificationSettings {
        return try RoomNotificationSettings(
            mode: FfiConverterTypeRoomNotificationMode.read(from: &buf), 
            isDefault: FfiConverterBool.read(from: &buf)
        )
    }

    public static func write(_ value: RoomNotificationSettings, into buf: inout [UInt8]) {
        FfiConverterTypeRoomNotificationMode.write(value.mode, into: &buf)
        FfiConverterBool.write(value.isDefault, into: &buf)
    }
}


public func FfiConverterTypeRoomNotificationSettings_lift(_ buf: RustBuffer) throws -> RoomNotificationSettings {
    return try FfiConverterTypeRoomNotificationSettings.lift(buf)
}

public func FfiConverterTypeRoomNotificationSettings_lower(_ value: RoomNotificationSettings) -> RustBuffer {
    return FfiConverterTypeRoomNotificationSettings.lower(value)
}


public struct RoomSubscription {
    public var requiredState: [RequiredState]?
    public var timelineLimit: UInt32?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(requiredState: [RequiredState]?, timelineLimit: UInt32?) {
        self.requiredState = requiredState
        self.timelineLimit = timelineLimit
    }
}


extension RoomSubscription: Equatable, Hashable {
    public static func ==(lhs: RoomSubscription, rhs: RoomSubscription) -> Bool {
        if lhs.requiredState != rhs.requiredState {
            return false
        }
        if lhs.timelineLimit != rhs.timelineLimit {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(requiredState)
        hasher.combine(timelineLimit)
    }
}


public struct FfiConverterTypeRoomSubscription: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RoomSubscription {
        return try RoomSubscription(
            requiredState: FfiConverterOptionSequenceTypeRequiredState.read(from: &buf), 
            timelineLimit: FfiConverterOptionUInt32.read(from: &buf)
        )
    }

    public static func write(_ value: RoomSubscription, into buf: inout [UInt8]) {
        FfiConverterOptionSequenceTypeRequiredState.write(value.requiredState, into: &buf)
        FfiConverterOptionUInt32.write(value.timelineLimit, into: &buf)
    }
}


public func FfiConverterTypeRoomSubscription_lift(_ buf: RustBuffer) throws -> RoomSubscription {
    return try FfiConverterTypeRoomSubscription.lift(buf)
}

public func FfiConverterTypeRoomSubscription_lower(_ value: RoomSubscription) -> RustBuffer {
    return FfiConverterTypeRoomSubscription.lower(value)
}


public struct RoomTimelineListenerResult {
    public var items: [TimelineItem]
    public var itemsStream: TaskHandle

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(items: [TimelineItem], itemsStream: TaskHandle) {
        self.items = items
        self.itemsStream = itemsStream
    }
}



public struct FfiConverterTypeRoomTimelineListenerResult: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RoomTimelineListenerResult {
        return try RoomTimelineListenerResult(
            items: FfiConverterSequenceTypeTimelineItem.read(from: &buf), 
            itemsStream: FfiConverterTypeTaskHandle.read(from: &buf)
        )
    }

    public static func write(_ value: RoomTimelineListenerResult, into buf: inout [UInt8]) {
        FfiConverterSequenceTypeTimelineItem.write(value.items, into: &buf)
        FfiConverterTypeTaskHandle.write(value.itemsStream, into: &buf)
    }
}


public func FfiConverterTypeRoomTimelineListenerResult_lift(_ buf: RustBuffer) throws -> RoomTimelineListenerResult {
    return try FfiConverterTypeRoomTimelineListenerResult.lift(buf)
}

public func FfiConverterTypeRoomTimelineListenerResult_lower(_ value: RoomTimelineListenerResult) -> RustBuffer {
    return FfiConverterTypeRoomTimelineListenerResult.lower(value)
}


public struct SearchUsersResults {
    public var results: [UserProfile]
    public var limited: Bool

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(results: [UserProfile], limited: Bool) {
        self.results = results
        self.limited = limited
    }
}


extension SearchUsersResults: Equatable, Hashable {
    public static func ==(lhs: SearchUsersResults, rhs: SearchUsersResults) -> Bool {
        if lhs.results != rhs.results {
            return false
        }
        if lhs.limited != rhs.limited {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(results)
        hasher.combine(limited)
    }
}


public struct FfiConverterTypeSearchUsersResults: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SearchUsersResults {
        return try SearchUsersResults(
            results: FfiConverterSequenceTypeUserProfile.read(from: &buf), 
            limited: FfiConverterBool.read(from: &buf)
        )
    }

    public static func write(_ value: SearchUsersResults, into buf: inout [UInt8]) {
        FfiConverterSequenceTypeUserProfile.write(value.results, into: &buf)
        FfiConverterBool.write(value.limited, into: &buf)
    }
}


public func FfiConverterTypeSearchUsersResults_lift(_ buf: RustBuffer) throws -> SearchUsersResults {
    return try FfiConverterTypeSearchUsersResults.lift(buf)
}

public func FfiConverterTypeSearchUsersResults_lower(_ value: SearchUsersResults) -> RustBuffer {
    return FfiConverterTypeSearchUsersResults.lower(value)
}


public struct Session {
    public var accessToken: String
    public var refreshToken: String?
    public var userId: String
    public var deviceId: String
    public var homeserverUrl: String
    public var oidcData: String?
    public var slidingSyncProxy: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(accessToken: String, refreshToken: String?, userId: String, deviceId: String, homeserverUrl: String, oidcData: String?, slidingSyncProxy: String?) {
        self.accessToken = accessToken
        self.refreshToken = refreshToken
        self.userId = userId
        self.deviceId = deviceId
        self.homeserverUrl = homeserverUrl
        self.oidcData = oidcData
        self.slidingSyncProxy = slidingSyncProxy
    }
}


extension Session: Equatable, Hashable {
    public static func ==(lhs: Session, rhs: Session) -> Bool {
        if lhs.accessToken != rhs.accessToken {
            return false
        }
        if lhs.refreshToken != rhs.refreshToken {
            return false
        }
        if lhs.userId != rhs.userId {
            return false
        }
        if lhs.deviceId != rhs.deviceId {
            return false
        }
        if lhs.homeserverUrl != rhs.homeserverUrl {
            return false
        }
        if lhs.oidcData != rhs.oidcData {
            return false
        }
        if lhs.slidingSyncProxy != rhs.slidingSyncProxy {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(accessToken)
        hasher.combine(refreshToken)
        hasher.combine(userId)
        hasher.combine(deviceId)
        hasher.combine(homeserverUrl)
        hasher.combine(oidcData)
        hasher.combine(slidingSyncProxy)
    }
}


public struct FfiConverterTypeSession: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Session {
        return try Session(
            accessToken: FfiConverterString.read(from: &buf), 
            refreshToken: FfiConverterOptionString.read(from: &buf), 
            userId: FfiConverterString.read(from: &buf), 
            deviceId: FfiConverterString.read(from: &buf), 
            homeserverUrl: FfiConverterString.read(from: &buf), 
            oidcData: FfiConverterOptionString.read(from: &buf), 
            slidingSyncProxy: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: Session, into buf: inout [UInt8]) {
        FfiConverterString.write(value.accessToken, into: &buf)
        FfiConverterOptionString.write(value.refreshToken, into: &buf)
        FfiConverterString.write(value.userId, into: &buf)
        FfiConverterString.write(value.deviceId, into: &buf)
        FfiConverterString.write(value.homeserverUrl, into: &buf)
        FfiConverterOptionString.write(value.oidcData, into: &buf)
        FfiConverterOptionString.write(value.slidingSyncProxy, into: &buf)
    }
}


public func FfiConverterTypeSession_lift(_ buf: RustBuffer) throws -> Session {
    return try FfiConverterTypeSession.lift(buf)
}

public func FfiConverterTypeSession_lower(_ value: Session) -> RustBuffer {
    return FfiConverterTypeSession.lower(value)
}


public struct SetData {
    public var index: UInt32
    public var item: TimelineItem

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(index: UInt32, item: TimelineItem) {
        self.index = index
        self.item = item
    }
}



public struct FfiConverterTypeSetData: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SetData {
        return try SetData(
            index: FfiConverterUInt32.read(from: &buf), 
            item: FfiConverterTypeTimelineItem.read(from: &buf)
        )
    }

    public static func write(_ value: SetData, into buf: inout [UInt8]) {
        FfiConverterUInt32.write(value.index, into: &buf)
        FfiConverterTypeTimelineItem.write(value.item, into: &buf)
    }
}


public func FfiConverterTypeSetData_lift(_ buf: RustBuffer) throws -> SetData {
    return try FfiConverterTypeSetData.lift(buf)
}

public func FfiConverterTypeSetData_lower(_ value: SetData) -> RustBuffer {
    return FfiConverterTypeSetData.lower(value)
}


public struct TextMessageContent {
    public var body: String
    public var formatted: FormattedBody?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(body: String, formatted: FormattedBody?) {
        self.body = body
        self.formatted = formatted
    }
}


extension TextMessageContent: Equatable, Hashable {
    public static func ==(lhs: TextMessageContent, rhs: TextMessageContent) -> Bool {
        if lhs.body != rhs.body {
            return false
        }
        if lhs.formatted != rhs.formatted {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(body)
        hasher.combine(formatted)
    }
}


public struct FfiConverterTypeTextMessageContent: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TextMessageContent {
        return try TextMessageContent(
            body: FfiConverterString.read(from: &buf), 
            formatted: FfiConverterOptionTypeFormattedBody.read(from: &buf)
        )
    }

    public static func write(_ value: TextMessageContent, into buf: inout [UInt8]) {
        FfiConverterString.write(value.body, into: &buf)
        FfiConverterOptionTypeFormattedBody.write(value.formatted, into: &buf)
    }
}


public func FfiConverterTypeTextMessageContent_lift(_ buf: RustBuffer) throws -> TextMessageContent {
    return try FfiConverterTypeTextMessageContent.lift(buf)
}

public func FfiConverterTypeTextMessageContent_lower(_ value: TextMessageContent) -> RustBuffer {
    return FfiConverterTypeTextMessageContent.lower(value)
}


public struct ThumbnailInfo {
    public var height: UInt64?
    public var width: UInt64?
    public var mimetype: String?
    public var size: UInt64?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(height: UInt64?, width: UInt64?, mimetype: String?, size: UInt64?) {
        self.height = height
        self.width = width
        self.mimetype = mimetype
        self.size = size
    }
}


extension ThumbnailInfo: Equatable, Hashable {
    public static func ==(lhs: ThumbnailInfo, rhs: ThumbnailInfo) -> Bool {
        if lhs.height != rhs.height {
            return false
        }
        if lhs.width != rhs.width {
            return false
        }
        if lhs.mimetype != rhs.mimetype {
            return false
        }
        if lhs.size != rhs.size {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(height)
        hasher.combine(width)
        hasher.combine(mimetype)
        hasher.combine(size)
    }
}


public struct FfiConverterTypeThumbnailInfo: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ThumbnailInfo {
        return try ThumbnailInfo(
            height: FfiConverterOptionUInt64.read(from: &buf), 
            width: FfiConverterOptionUInt64.read(from: &buf), 
            mimetype: FfiConverterOptionString.read(from: &buf), 
            size: FfiConverterOptionUInt64.read(from: &buf)
        )
    }

    public static func write(_ value: ThumbnailInfo, into buf: inout [UInt8]) {
        FfiConverterOptionUInt64.write(value.height, into: &buf)
        FfiConverterOptionUInt64.write(value.width, into: &buf)
        FfiConverterOptionString.write(value.mimetype, into: &buf)
        FfiConverterOptionUInt64.write(value.size, into: &buf)
    }
}


public func FfiConverterTypeThumbnailInfo_lift(_ buf: RustBuffer) throws -> ThumbnailInfo {
    return try FfiConverterTypeThumbnailInfo.lift(buf)
}

public func FfiConverterTypeThumbnailInfo_lower(_ value: ThumbnailInfo) -> RustBuffer {
    return FfiConverterTypeThumbnailInfo.lower(value)
}


public struct TracingConfiguration {
    public var filter: String
    public var writeToStdoutOrSystem: Bool
    public var writeToFiles: TracingFileConfiguration?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(filter: String, writeToStdoutOrSystem: Bool, writeToFiles: TracingFileConfiguration?) {
        self.filter = filter
        self.writeToStdoutOrSystem = writeToStdoutOrSystem
        self.writeToFiles = writeToFiles
    }
}


extension TracingConfiguration: Equatable, Hashable {
    public static func ==(lhs: TracingConfiguration, rhs: TracingConfiguration) -> Bool {
        if lhs.filter != rhs.filter {
            return false
        }
        if lhs.writeToStdoutOrSystem != rhs.writeToStdoutOrSystem {
            return false
        }
        if lhs.writeToFiles != rhs.writeToFiles {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(filter)
        hasher.combine(writeToStdoutOrSystem)
        hasher.combine(writeToFiles)
    }
}


public struct FfiConverterTypeTracingConfiguration: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TracingConfiguration {
        return try TracingConfiguration(
            filter: FfiConverterString.read(from: &buf), 
            writeToStdoutOrSystem: FfiConverterBool.read(from: &buf), 
            writeToFiles: FfiConverterOptionTypeTracingFileConfiguration.read(from: &buf)
        )
    }

    public static func write(_ value: TracingConfiguration, into buf: inout [UInt8]) {
        FfiConverterString.write(value.filter, into: &buf)
        FfiConverterBool.write(value.writeToStdoutOrSystem, into: &buf)
        FfiConverterOptionTypeTracingFileConfiguration.write(value.writeToFiles, into: &buf)
    }
}


public func FfiConverterTypeTracingConfiguration_lift(_ buf: RustBuffer) throws -> TracingConfiguration {
    return try FfiConverterTypeTracingConfiguration.lift(buf)
}

public func FfiConverterTypeTracingConfiguration_lower(_ value: TracingConfiguration) -> RustBuffer {
    return FfiConverterTypeTracingConfiguration.lower(value)
}


public struct TracingFileConfiguration {
    public var path: String
    public var filePrefix: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(path: String, filePrefix: String) {
        self.path = path
        self.filePrefix = filePrefix
    }
}


extension TracingFileConfiguration: Equatable, Hashable {
    public static func ==(lhs: TracingFileConfiguration, rhs: TracingFileConfiguration) -> Bool {
        if lhs.path != rhs.path {
            return false
        }
        if lhs.filePrefix != rhs.filePrefix {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(path)
        hasher.combine(filePrefix)
    }
}


public struct FfiConverterTypeTracingFileConfiguration: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TracingFileConfiguration {
        return try TracingFileConfiguration(
            path: FfiConverterString.read(from: &buf), 
            filePrefix: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: TracingFileConfiguration, into buf: inout [UInt8]) {
        FfiConverterString.write(value.path, into: &buf)
        FfiConverterString.write(value.filePrefix, into: &buf)
    }
}


public func FfiConverterTypeTracingFileConfiguration_lift(_ buf: RustBuffer) throws -> TracingFileConfiguration {
    return try FfiConverterTypeTracingFileConfiguration.lift(buf)
}

public func FfiConverterTypeTracingFileConfiguration_lower(_ value: TracingFileConfiguration) -> RustBuffer {
    return FfiConverterTypeTracingFileConfiguration.lower(value)
}


public struct TransmissionProgress {
    public var current: UInt64
    public var total: UInt64

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(current: UInt64, total: UInt64) {
        self.current = current
        self.total = total
    }
}


extension TransmissionProgress: Equatable, Hashable {
    public static func ==(lhs: TransmissionProgress, rhs: TransmissionProgress) -> Bool {
        if lhs.current != rhs.current {
            return false
        }
        if lhs.total != rhs.total {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(current)
        hasher.combine(total)
    }
}


public struct FfiConverterTypeTransmissionProgress: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TransmissionProgress {
        return try TransmissionProgress(
            current: FfiConverterUInt64.read(from: &buf), 
            total: FfiConverterUInt64.read(from: &buf)
        )
    }

    public static func write(_ value: TransmissionProgress, into buf: inout [UInt8]) {
        FfiConverterUInt64.write(value.current, into: &buf)
        FfiConverterUInt64.write(value.total, into: &buf)
    }
}


public func FfiConverterTypeTransmissionProgress_lift(_ buf: RustBuffer) throws -> TransmissionProgress {
    return try FfiConverterTypeTransmissionProgress.lift(buf)
}

public func FfiConverterTypeTransmissionProgress_lower(_ value: TransmissionProgress) -> RustBuffer {
    return FfiConverterTypeTransmissionProgress.lower(value)
}


public struct UserProfile {
    public var userId: String
    public var displayName: String?
    public var avatarUrl: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(userId: String, displayName: String?, avatarUrl: String?) {
        self.userId = userId
        self.displayName = displayName
        self.avatarUrl = avatarUrl
    }
}


extension UserProfile: Equatable, Hashable {
    public static func ==(lhs: UserProfile, rhs: UserProfile) -> Bool {
        if lhs.userId != rhs.userId {
            return false
        }
        if lhs.displayName != rhs.displayName {
            return false
        }
        if lhs.avatarUrl != rhs.avatarUrl {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(userId)
        hasher.combine(displayName)
        hasher.combine(avatarUrl)
    }
}


public struct FfiConverterTypeUserProfile: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UserProfile {
        return try UserProfile(
            userId: FfiConverterString.read(from: &buf), 
            displayName: FfiConverterOptionString.read(from: &buf), 
            avatarUrl: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: UserProfile, into buf: inout [UInt8]) {
        FfiConverterString.write(value.userId, into: &buf)
        FfiConverterOptionString.write(value.displayName, into: &buf)
        FfiConverterOptionString.write(value.avatarUrl, into: &buf)
    }
}


public func FfiConverterTypeUserProfile_lift(_ buf: RustBuffer) throws -> UserProfile {
    return try FfiConverterTypeUserProfile.lift(buf)
}

public func FfiConverterTypeUserProfile_lower(_ value: UserProfile) -> RustBuffer {
    return FfiConverterTypeUserProfile.lower(value)
}


public struct VideoInfo {
    public var duration: TimeInterval?
    public var height: UInt64?
    public var width: UInt64?
    public var mimetype: String?
    public var size: UInt64?
    public var thumbnailInfo: ThumbnailInfo?
    public var thumbnailSource: MediaSource?
    public var blurhash: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(duration: TimeInterval?, height: UInt64?, width: UInt64?, mimetype: String?, size: UInt64?, thumbnailInfo: ThumbnailInfo?, thumbnailSource: MediaSource?, blurhash: String?) {
        self.duration = duration
        self.height = height
        self.width = width
        self.mimetype = mimetype
        self.size = size
        self.thumbnailInfo = thumbnailInfo
        self.thumbnailSource = thumbnailSource
        self.blurhash = blurhash
    }
}



public struct FfiConverterTypeVideoInfo: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> VideoInfo {
        return try VideoInfo(
            duration: FfiConverterOptionDuration.read(from: &buf), 
            height: FfiConverterOptionUInt64.read(from: &buf), 
            width: FfiConverterOptionUInt64.read(from: &buf), 
            mimetype: FfiConverterOptionString.read(from: &buf), 
            size: FfiConverterOptionUInt64.read(from: &buf), 
            thumbnailInfo: FfiConverterOptionTypeThumbnailInfo.read(from: &buf), 
            thumbnailSource: FfiConverterOptionTypeMediaSource.read(from: &buf), 
            blurhash: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: VideoInfo, into buf: inout [UInt8]) {
        FfiConverterOptionDuration.write(value.duration, into: &buf)
        FfiConverterOptionUInt64.write(value.height, into: &buf)
        FfiConverterOptionUInt64.write(value.width, into: &buf)
        FfiConverterOptionString.write(value.mimetype, into: &buf)
        FfiConverterOptionUInt64.write(value.size, into: &buf)
        FfiConverterOptionTypeThumbnailInfo.write(value.thumbnailInfo, into: &buf)
        FfiConverterOptionTypeMediaSource.write(value.thumbnailSource, into: &buf)
        FfiConverterOptionString.write(value.blurhash, into: &buf)
    }
}


public func FfiConverterTypeVideoInfo_lift(_ buf: RustBuffer) throws -> VideoInfo {
    return try FfiConverterTypeVideoInfo.lift(buf)
}

public func FfiConverterTypeVideoInfo_lower(_ value: VideoInfo) -> RustBuffer {
    return FfiConverterTypeVideoInfo.lower(value)
}


public struct VideoMessageContent {
    public var body: String
    public var source: MediaSource
    public var info: VideoInfo?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(body: String, source: MediaSource, info: VideoInfo?) {
        self.body = body
        self.source = source
        self.info = info
    }
}



public struct FfiConverterTypeVideoMessageContent: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> VideoMessageContent {
        return try VideoMessageContent(
            body: FfiConverterString.read(from: &buf), 
            source: FfiConverterTypeMediaSource.read(from: &buf), 
            info: FfiConverterOptionTypeVideoInfo.read(from: &buf)
        )
    }

    public static func write(_ value: VideoMessageContent, into buf: inout [UInt8]) {
        FfiConverterString.write(value.body, into: &buf)
        FfiConverterTypeMediaSource.write(value.source, into: &buf)
        FfiConverterOptionTypeVideoInfo.write(value.info, into: &buf)
    }
}


public func FfiConverterTypeVideoMessageContent_lift(_ buf: RustBuffer) throws -> VideoMessageContent {
    return try FfiConverterTypeVideoMessageContent.lift(buf)
}

public func FfiConverterTypeVideoMessageContent_lower(_ value: VideoMessageContent) -> RustBuffer {
    return FfiConverterTypeVideoMessageContent.lower(value)
}


public struct Widget {
    public var info: WidgetInfo
    public var comm: WidgetComm

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(info: WidgetInfo, comm: WidgetComm) {
        self.info = info
        self.comm = comm
    }
}



public struct FfiConverterTypeWidget: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Widget {
        return try Widget(
            info: FfiConverterTypeWidgetInfo.read(from: &buf), 
            comm: FfiConverterTypeWidgetComm.read(from: &buf)
        )
    }

    public static func write(_ value: Widget, into buf: inout [UInt8]) {
        FfiConverterTypeWidgetInfo.write(value.info, into: &buf)
        FfiConverterTypeWidgetComm.write(value.comm, into: &buf)
    }
}


public func FfiConverterTypeWidget_lift(_ buf: RustBuffer) throws -> Widget {
    return try FfiConverterTypeWidget.lift(buf)
}

public func FfiConverterTypeWidget_lower(_ value: Widget) -> RustBuffer {
    return FfiConverterTypeWidget.lower(value)
}


public struct WidgetInfo {
    public var id: String
    public var initOnLoad: Bool

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(id: String, initOnLoad: Bool) {
        self.id = id
        self.initOnLoad = initOnLoad
    }
}


extension WidgetInfo: Equatable, Hashable {
    public static func ==(lhs: WidgetInfo, rhs: WidgetInfo) -> Bool {
        if lhs.id != rhs.id {
            return false
        }
        if lhs.initOnLoad != rhs.initOnLoad {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(id)
        hasher.combine(initOnLoad)
    }
}


public struct FfiConverterTypeWidgetInfo: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> WidgetInfo {
        return try WidgetInfo(
            id: FfiConverterString.read(from: &buf), 
            initOnLoad: FfiConverterBool.read(from: &buf)
        )
    }

    public static func write(_ value: WidgetInfo, into buf: inout [UInt8]) {
        FfiConverterString.write(value.id, into: &buf)
        FfiConverterBool.write(value.initOnLoad, into: &buf)
    }
}


public func FfiConverterTypeWidgetInfo_lift(_ buf: RustBuffer) throws -> WidgetInfo {
    return try FfiConverterTypeWidgetInfo.lift(buf)
}

public func FfiConverterTypeWidgetInfo_lower(_ value: WidgetInfo) -> RustBuffer {
    return FfiConverterTypeWidgetInfo.lower(value)
}


public struct WidgetPermissions {
    public var read: [WidgetEventFilter]
    public var send: [WidgetEventFilter]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(read: [WidgetEventFilter], send: [WidgetEventFilter]) {
        self.read = read
        self.send = send
    }
}


extension WidgetPermissions: Equatable, Hashable {
    public static func ==(lhs: WidgetPermissions, rhs: WidgetPermissions) -> Bool {
        if lhs.read != rhs.read {
            return false
        }
        if lhs.send != rhs.send {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(read)
        hasher.combine(send)
    }
}


public struct FfiConverterTypeWidgetPermissions: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> WidgetPermissions {
        return try WidgetPermissions(
            read: FfiConverterSequenceTypeWidgetEventFilter.read(from: &buf), 
            send: FfiConverterSequenceTypeWidgetEventFilter.read(from: &buf)
        )
    }

    public static func write(_ value: WidgetPermissions, into buf: inout [UInt8]) {
        FfiConverterSequenceTypeWidgetEventFilter.write(value.read, into: &buf)
        FfiConverterSequenceTypeWidgetEventFilter.write(value.send, into: &buf)
    }
}


public func FfiConverterTypeWidgetPermissions_lift(_ buf: RustBuffer) throws -> WidgetPermissions {
    return try FfiConverterTypeWidgetPermissions.lift(buf)
}

public func FfiConverterTypeWidgetPermissions_lower(_ value: WidgetPermissions) -> RustBuffer {
    return FfiConverterTypeWidgetPermissions.lower(value)
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum AssetType {
    
    case sender
    case pin
}

public struct FfiConverterTypeAssetType: FfiConverterRustBuffer {
    typealias SwiftType = AssetType

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AssetType {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .sender
        
        case 2: return .pin
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: AssetType, into buf: inout [UInt8]) {
        switch value {
        
        
        case .sender:
            writeInt(&buf, Int32(1))
        
        
        case .pin:
            writeInt(&buf, Int32(2))
        
        }
    }
}


public func FfiConverterTypeAssetType_lift(_ buf: RustBuffer) throws -> AssetType {
    return try FfiConverterTypeAssetType.lift(buf)
}

public func FfiConverterTypeAssetType_lower(_ value: AssetType) -> RustBuffer {
    return FfiConverterTypeAssetType.lower(value)
}


extension AssetType: Equatable, Hashable {}



public enum AuthenticationError {

    
    
    // Simple error enums only carry a message
    case ClientMissing(message: String)
    
    // Simple error enums only carry a message
    case InvalidServerName(message: String)
    
    // Simple error enums only carry a message
    case SlidingSyncNotAvailable(message: String)
    
    // Simple error enums only carry a message
    case SessionMissing(message: String)
    
    // Simple error enums only carry a message
    case InvalidBasePath(message: String)
    
    // Simple error enums only carry a message
    case OidcNotSupported(message: String)
    
    // Simple error enums only carry a message
    case OidcMetadataMissing(message: String)
    
    // Simple error enums only carry a message
    case OidcMetadataInvalid(message: String)
    
    // Simple error enums only carry a message
    case OidcCallbackUrlInvalid(message: String)
    
    // Simple error enums only carry a message
    case OidcCancelled(message: String)
    
    // Simple error enums only carry a message
    case OidcError(message: String)
    
    // Simple error enums only carry a message
    case Generic(message: String)
    

    fileprivate static func uniffiErrorHandler(_ error: RustBuffer) throws -> Error {
        return try FfiConverterTypeAuthenticationError.lift(error)
    }
}


public struct FfiConverterTypeAuthenticationError: FfiConverterRustBuffer {
    typealias SwiftType = AuthenticationError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AuthenticationError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .ClientMissing(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 2: return .InvalidServerName(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 3: return .SlidingSyncNotAvailable(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 4: return .SessionMissing(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 5: return .InvalidBasePath(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 6: return .OidcNotSupported(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 7: return .OidcMetadataMissing(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 8: return .OidcMetadataInvalid(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 9: return .OidcCallbackUrlInvalid(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 10: return .OidcCancelled(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 11: return .OidcError(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 12: return .Generic(
            message: try FfiConverterString.read(from: &buf)
        )
        

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: AuthenticationError, into buf: inout [UInt8]) {
        switch value {

        

        
        case .ClientMissing(_ /* message is ignored*/):
            writeInt(&buf, Int32(1))
        case .InvalidServerName(_ /* message is ignored*/):
            writeInt(&buf, Int32(2))
        case .SlidingSyncNotAvailable(_ /* message is ignored*/):
            writeInt(&buf, Int32(3))
        case .SessionMissing(_ /* message is ignored*/):
            writeInt(&buf, Int32(4))
        case .InvalidBasePath(_ /* message is ignored*/):
            writeInt(&buf, Int32(5))
        case .OidcNotSupported(_ /* message is ignored*/):
            writeInt(&buf, Int32(6))
        case .OidcMetadataMissing(_ /* message is ignored*/):
            writeInt(&buf, Int32(7))
        case .OidcMetadataInvalid(_ /* message is ignored*/):
            writeInt(&buf, Int32(8))
        case .OidcCallbackUrlInvalid(_ /* message is ignored*/):
            writeInt(&buf, Int32(9))
        case .OidcCancelled(_ /* message is ignored*/):
            writeInt(&buf, Int32(10))
        case .OidcError(_ /* message is ignored*/):
            writeInt(&buf, Int32(11))
        case .Generic(_ /* message is ignored*/):
            writeInt(&buf, Int32(12))

        
        }
    }
}


extension AuthenticationError: Equatable, Hashable {}

extension AuthenticationError: Error { }

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum BackPaginationStatus {
    
    case idle
    case paginating
    case timelineStartReached
}

public struct FfiConverterTypeBackPaginationStatus: FfiConverterRustBuffer {
    typealias SwiftType = BackPaginationStatus

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> BackPaginationStatus {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .idle
        
        case 2: return .paginating
        
        case 3: return .timelineStartReached
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: BackPaginationStatus, into buf: inout [UInt8]) {
        switch value {
        
        
        case .idle:
            writeInt(&buf, Int32(1))
        
        
        case .paginating:
            writeInt(&buf, Int32(2))
        
        
        case .timelineStartReached:
            writeInt(&buf, Int32(3))
        
        }
    }
}


public func FfiConverterTypeBackPaginationStatus_lift(_ buf: RustBuffer) throws -> BackPaginationStatus {
    return try FfiConverterTypeBackPaginationStatus.lift(buf)
}

public func FfiConverterTypeBackPaginationStatus_lower(_ value: BackPaginationStatus) -> RustBuffer {
    return FfiConverterTypeBackPaginationStatus.lower(value)
}


extension BackPaginationStatus: Equatable, Hashable {}



public enum ClientError {

    
    
    case Generic(msg: String)

    fileprivate static func uniffiErrorHandler(_ error: RustBuffer) throws -> Error {
        return try FfiConverterTypeClientError.lift(error)
    }
}


public struct FfiConverterTypeClientError: FfiConverterRustBuffer {
    typealias SwiftType = ClientError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ClientError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .Generic(
            msg: try FfiConverterString.read(from: &buf)
            )

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ClientError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case let .Generic(msg):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(msg, into: &buf)
            
        }
    }
}


extension ClientError: Equatable, Hashable {}

extension ClientError: Error { }

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum EncryptedMessage {
    
    case olmV1Curve25519AesSha2(senderKey: String)
    case megolmV1AesSha2(sessionId: String)
    case unknown
}

public struct FfiConverterTypeEncryptedMessage: FfiConverterRustBuffer {
    typealias SwiftType = EncryptedMessage

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> EncryptedMessage {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .olmV1Curve25519AesSha2(
            senderKey: try FfiConverterString.read(from: &buf)
        )
        
        case 2: return .megolmV1AesSha2(
            sessionId: try FfiConverterString.read(from: &buf)
        )
        
        case 3: return .unknown
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: EncryptedMessage, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .olmV1Curve25519AesSha2(senderKey):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(senderKey, into: &buf)
            
        
        case let .megolmV1AesSha2(sessionId):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(sessionId, into: &buf)
            
        
        case .unknown:
            writeInt(&buf, Int32(3))
        
        }
    }
}


public func FfiConverterTypeEncryptedMessage_lift(_ buf: RustBuffer) throws -> EncryptedMessage {
    return try FfiConverterTypeEncryptedMessage.lift(buf)
}

public func FfiConverterTypeEncryptedMessage_lower(_ value: EncryptedMessage) -> RustBuffer {
    return FfiConverterTypeEncryptedMessage.lower(value)
}


extension EncryptedMessage: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum EventItemOrigin {
    
    case local
    case sync
    case pagination
}

public struct FfiConverterTypeEventItemOrigin: FfiConverterRustBuffer {
    typealias SwiftType = EventItemOrigin

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> EventItemOrigin {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .local
        
        case 2: return .sync
        
        case 3: return .pagination
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: EventItemOrigin, into buf: inout [UInt8]) {
        switch value {
        
        
        case .local:
            writeInt(&buf, Int32(1))
        
        
        case .sync:
            writeInt(&buf, Int32(2))
        
        
        case .pagination:
            writeInt(&buf, Int32(3))
        
        }
    }
}


public func FfiConverterTypeEventItemOrigin_lift(_ buf: RustBuffer) throws -> EventItemOrigin {
    return try FfiConverterTypeEventItemOrigin.lift(buf)
}

public func FfiConverterTypeEventItemOrigin_lower(_ value: EventItemOrigin) -> RustBuffer {
    return FfiConverterTypeEventItemOrigin.lower(value)
}


extension EventItemOrigin: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum EventSendState {
    
    case notSentYet
    case sendingFailed(error: String)
    case cancelled
    case sent(eventId: String)
}

public struct FfiConverterTypeEventSendState: FfiConverterRustBuffer {
    typealias SwiftType = EventSendState

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> EventSendState {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .notSentYet
        
        case 2: return .sendingFailed(
            error: try FfiConverterString.read(from: &buf)
        )
        
        case 3: return .cancelled
        
        case 4: return .sent(
            eventId: try FfiConverterString.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: EventSendState, into buf: inout [UInt8]) {
        switch value {
        
        
        case .notSentYet:
            writeInt(&buf, Int32(1))
        
        
        case let .sendingFailed(error):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(error, into: &buf)
            
        
        case .cancelled:
            writeInt(&buf, Int32(3))
        
        
        case let .sent(eventId):
            writeInt(&buf, Int32(4))
            FfiConverterString.write(eventId, into: &buf)
            
        }
    }
}


public func FfiConverterTypeEventSendState_lift(_ buf: RustBuffer) throws -> EventSendState {
    return try FfiConverterTypeEventSendState.lift(buf)
}

public func FfiConverterTypeEventSendState_lower(_ value: EventSendState) -> RustBuffer {
    return FfiConverterTypeEventSendState.lower(value)
}


extension EventSendState: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum LogLevel {
    
    case error
    case warn
    case info
    case debug
    case trace
}

public struct FfiConverterTypeLogLevel: FfiConverterRustBuffer {
    typealias SwiftType = LogLevel

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LogLevel {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .error
        
        case 2: return .warn
        
        case 3: return .info
        
        case 4: return .debug
        
        case 5: return .trace
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: LogLevel, into buf: inout [UInt8]) {
        switch value {
        
        
        case .error:
            writeInt(&buf, Int32(1))
        
        
        case .warn:
            writeInt(&buf, Int32(2))
        
        
        case .info:
            writeInt(&buf, Int32(3))
        
        
        case .debug:
            writeInt(&buf, Int32(4))
        
        
        case .trace:
            writeInt(&buf, Int32(5))
        
        }
    }
}


public func FfiConverterTypeLogLevel_lift(_ buf: RustBuffer) throws -> LogLevel {
    return try FfiConverterTypeLogLevel.lift(buf)
}

public func FfiConverterTypeLogLevel_lower(_ value: LogLevel) -> RustBuffer {
    return FfiConverterTypeLogLevel.lower(value)
}


extension LogLevel: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum Membership {
    
    case invited
    case joined
    case left
}

public struct FfiConverterTypeMembership: FfiConverterRustBuffer {
    typealias SwiftType = Membership

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Membership {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .invited
        
        case 2: return .joined
        
        case 3: return .left
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: Membership, into buf: inout [UInt8]) {
        switch value {
        
        
        case .invited:
            writeInt(&buf, Int32(1))
        
        
        case .joined:
            writeInt(&buf, Int32(2))
        
        
        case .left:
            writeInt(&buf, Int32(3))
        
        }
    }
}


public func FfiConverterTypeMembership_lift(_ buf: RustBuffer) throws -> Membership {
    return try FfiConverterTypeMembership.lift(buf)
}

public func FfiConverterTypeMembership_lower(_ value: Membership) -> RustBuffer {
    return FfiConverterTypeMembership.lower(value)
}


extension Membership: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum MembershipChange {
    
    case none
    case error
    case joined
    case left
    case banned
    case unbanned
    case kicked
    case invited
    case kickedAndBanned
    case invitationAccepted
    case invitationRejected
    case invitationRevoked
    case knocked
    case knockAccepted
    case knockRetracted
    case knockDenied
    case notImplemented
}

public struct FfiConverterTypeMembershipChange: FfiConverterRustBuffer {
    typealias SwiftType = MembershipChange

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MembershipChange {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .none
        
        case 2: return .error
        
        case 3: return .joined
        
        case 4: return .left
        
        case 5: return .banned
        
        case 6: return .unbanned
        
        case 7: return .kicked
        
        case 8: return .invited
        
        case 9: return .kickedAndBanned
        
        case 10: return .invitationAccepted
        
        case 11: return .invitationRejected
        
        case 12: return .invitationRevoked
        
        case 13: return .knocked
        
        case 14: return .knockAccepted
        
        case 15: return .knockRetracted
        
        case 16: return .knockDenied
        
        case 17: return .notImplemented
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: MembershipChange, into buf: inout [UInt8]) {
        switch value {
        
        
        case .none:
            writeInt(&buf, Int32(1))
        
        
        case .error:
            writeInt(&buf, Int32(2))
        
        
        case .joined:
            writeInt(&buf, Int32(3))
        
        
        case .left:
            writeInt(&buf, Int32(4))
        
        
        case .banned:
            writeInt(&buf, Int32(5))
        
        
        case .unbanned:
            writeInt(&buf, Int32(6))
        
        
        case .kicked:
            writeInt(&buf, Int32(7))
        
        
        case .invited:
            writeInt(&buf, Int32(8))
        
        
        case .kickedAndBanned:
            writeInt(&buf, Int32(9))
        
        
        case .invitationAccepted:
            writeInt(&buf, Int32(10))
        
        
        case .invitationRejected:
            writeInt(&buf, Int32(11))
        
        
        case .invitationRevoked:
            writeInt(&buf, Int32(12))
        
        
        case .knocked:
            writeInt(&buf, Int32(13))
        
        
        case .knockAccepted:
            writeInt(&buf, Int32(14))
        
        
        case .knockRetracted:
            writeInt(&buf, Int32(15))
        
        
        case .knockDenied:
            writeInt(&buf, Int32(16))
        
        
        case .notImplemented:
            writeInt(&buf, Int32(17))
        
        }
    }
}


public func FfiConverterTypeMembershipChange_lift(_ buf: RustBuffer) throws -> MembershipChange {
    return try FfiConverterTypeMembershipChange.lift(buf)
}

public func FfiConverterTypeMembershipChange_lower(_ value: MembershipChange) -> RustBuffer {
    return FfiConverterTypeMembershipChange.lower(value)
}


extension MembershipChange: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum MembershipState {
    
    case ban
    case invite
    case join
    case knock
    case leave
}

public struct FfiConverterTypeMembershipState: FfiConverterRustBuffer {
    typealias SwiftType = MembershipState

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MembershipState {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .ban
        
        case 2: return .invite
        
        case 3: return .join
        
        case 4: return .knock
        
        case 5: return .leave
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: MembershipState, into buf: inout [UInt8]) {
        switch value {
        
        
        case .ban:
            writeInt(&buf, Int32(1))
        
        
        case .invite:
            writeInt(&buf, Int32(2))
        
        
        case .join:
            writeInt(&buf, Int32(3))
        
        
        case .knock:
            writeInt(&buf, Int32(4))
        
        
        case .leave:
            writeInt(&buf, Int32(5))
        
        }
    }
}


public func FfiConverterTypeMembershipState_lift(_ buf: RustBuffer) throws -> MembershipState {
    return try FfiConverterTypeMembershipState.lift(buf)
}

public func FfiConverterTypeMembershipState_lower(_ value: MembershipState) -> RustBuffer {
    return FfiConverterTypeMembershipState.lower(value)
}


extension MembershipState: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum MessageFormat {
    
    case html
    case unknown(format: String)
}

public struct FfiConverterTypeMessageFormat: FfiConverterRustBuffer {
    typealias SwiftType = MessageFormat

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MessageFormat {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .html
        
        case 2: return .unknown(
            format: try FfiConverterString.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: MessageFormat, into buf: inout [UInt8]) {
        switch value {
        
        
        case .html:
            writeInt(&buf, Int32(1))
        
        
        case let .unknown(format):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(format, into: &buf)
            
        }
    }
}


public func FfiConverterTypeMessageFormat_lift(_ buf: RustBuffer) throws -> MessageFormat {
    return try FfiConverterTypeMessageFormat.lift(buf)
}

public func FfiConverterTypeMessageFormat_lower(_ value: MessageFormat) -> RustBuffer {
    return FfiConverterTypeMessageFormat.lower(value)
}


extension MessageFormat: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum MessageLikeEventContent {
    
    case callAnswer
    case callInvite
    case callHangup
    case callCandidates
    case keyVerificationReady
    case keyVerificationStart
    case keyVerificationCancel
    case keyVerificationAccept
    case keyVerificationKey
    case keyVerificationMac
    case keyVerificationDone
    case reactionContent(relatedEventId: String)
    case roomEncrypted
    case roomMessage(messageType: MessageType)
    case roomRedaction
    case sticker
}

public struct FfiConverterTypeMessageLikeEventContent: FfiConverterRustBuffer {
    typealias SwiftType = MessageLikeEventContent

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MessageLikeEventContent {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .callAnswer
        
        case 2: return .callInvite
        
        case 3: return .callHangup
        
        case 4: return .callCandidates
        
        case 5: return .keyVerificationReady
        
        case 6: return .keyVerificationStart
        
        case 7: return .keyVerificationCancel
        
        case 8: return .keyVerificationAccept
        
        case 9: return .keyVerificationKey
        
        case 10: return .keyVerificationMac
        
        case 11: return .keyVerificationDone
        
        case 12: return .reactionContent(
            relatedEventId: try FfiConverterString.read(from: &buf)
        )
        
        case 13: return .roomEncrypted
        
        case 14: return .roomMessage(
            messageType: try FfiConverterTypeMessageType.read(from: &buf)
        )
        
        case 15: return .roomRedaction
        
        case 16: return .sticker
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: MessageLikeEventContent, into buf: inout [UInt8]) {
        switch value {
        
        
        case .callAnswer:
            writeInt(&buf, Int32(1))
        
        
        case .callInvite:
            writeInt(&buf, Int32(2))
        
        
        case .callHangup:
            writeInt(&buf, Int32(3))
        
        
        case .callCandidates:
            writeInt(&buf, Int32(4))
        
        
        case .keyVerificationReady:
            writeInt(&buf, Int32(5))
        
        
        case .keyVerificationStart:
            writeInt(&buf, Int32(6))
        
        
        case .keyVerificationCancel:
            writeInt(&buf, Int32(7))
        
        
        case .keyVerificationAccept:
            writeInt(&buf, Int32(8))
        
        
        case .keyVerificationKey:
            writeInt(&buf, Int32(9))
        
        
        case .keyVerificationMac:
            writeInt(&buf, Int32(10))
        
        
        case .keyVerificationDone:
            writeInt(&buf, Int32(11))
        
        
        case let .reactionContent(relatedEventId):
            writeInt(&buf, Int32(12))
            FfiConverterString.write(relatedEventId, into: &buf)
            
        
        case .roomEncrypted:
            writeInt(&buf, Int32(13))
        
        
        case let .roomMessage(messageType):
            writeInt(&buf, Int32(14))
            FfiConverterTypeMessageType.write(messageType, into: &buf)
            
        
        case .roomRedaction:
            writeInt(&buf, Int32(15))
        
        
        case .sticker:
            writeInt(&buf, Int32(16))
        
        }
    }
}


public func FfiConverterTypeMessageLikeEventContent_lift(_ buf: RustBuffer) throws -> MessageLikeEventContent {
    return try FfiConverterTypeMessageLikeEventContent.lift(buf)
}

public func FfiConverterTypeMessageLikeEventContent_lower(_ value: MessageLikeEventContent) -> RustBuffer {
    return FfiConverterTypeMessageLikeEventContent.lower(value)
}




// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum MessageLikeEventType {
    
    case callAnswer
    case callInvite
    case callHangup
    case callCandidates
    case keyVerificationReady
    case keyVerificationStart
    case keyVerificationCancel
    case keyVerificationAccept
    case keyVerificationKey
    case keyVerificationMac
    case keyVerificationDone
    case reactionSent
    case roomEncrypted
    case roomMessage
    case roomRedaction
    case sticker
}

public struct FfiConverterTypeMessageLikeEventType: FfiConverterRustBuffer {
    typealias SwiftType = MessageLikeEventType

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MessageLikeEventType {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .callAnswer
        
        case 2: return .callInvite
        
        case 3: return .callHangup
        
        case 4: return .callCandidates
        
        case 5: return .keyVerificationReady
        
        case 6: return .keyVerificationStart
        
        case 7: return .keyVerificationCancel
        
        case 8: return .keyVerificationAccept
        
        case 9: return .keyVerificationKey
        
        case 10: return .keyVerificationMac
        
        case 11: return .keyVerificationDone
        
        case 12: return .reactionSent
        
        case 13: return .roomEncrypted
        
        case 14: return .roomMessage
        
        case 15: return .roomRedaction
        
        case 16: return .sticker
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: MessageLikeEventType, into buf: inout [UInt8]) {
        switch value {
        
        
        case .callAnswer:
            writeInt(&buf, Int32(1))
        
        
        case .callInvite:
            writeInt(&buf, Int32(2))
        
        
        case .callHangup:
            writeInt(&buf, Int32(3))
        
        
        case .callCandidates:
            writeInt(&buf, Int32(4))
        
        
        case .keyVerificationReady:
            writeInt(&buf, Int32(5))
        
        
        case .keyVerificationStart:
            writeInt(&buf, Int32(6))
        
        
        case .keyVerificationCancel:
            writeInt(&buf, Int32(7))
        
        
        case .keyVerificationAccept:
            writeInt(&buf, Int32(8))
        
        
        case .keyVerificationKey:
            writeInt(&buf, Int32(9))
        
        
        case .keyVerificationMac:
            writeInt(&buf, Int32(10))
        
        
        case .keyVerificationDone:
            writeInt(&buf, Int32(11))
        
        
        case .reactionSent:
            writeInt(&buf, Int32(12))
        
        
        case .roomEncrypted:
            writeInt(&buf, Int32(13))
        
        
        case .roomMessage:
            writeInt(&buf, Int32(14))
        
        
        case .roomRedaction:
            writeInt(&buf, Int32(15))
        
        
        case .sticker:
            writeInt(&buf, Int32(16))
        
        }
    }
}


public func FfiConverterTypeMessageLikeEventType_lift(_ buf: RustBuffer) throws -> MessageLikeEventType {
    return try FfiConverterTypeMessageLikeEventType.lift(buf)
}

public func FfiConverterTypeMessageLikeEventType_lower(_ value: MessageLikeEventType) -> RustBuffer {
    return FfiConverterTypeMessageLikeEventType.lower(value)
}


extension MessageLikeEventType: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum MessageType {
    
    case emote(content: EmoteMessageContent)
    case image(content: ImageMessageContent)
    case audio(content: AudioMessageContent)
    case video(content: VideoMessageContent)
    case file(content: FileMessageContent)
    case notice(content: NoticeMessageContent)
    case text(content: TextMessageContent)
    case location(content: LocationContent)
}

public struct FfiConverterTypeMessageType: FfiConverterRustBuffer {
    typealias SwiftType = MessageType

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MessageType {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .emote(
            content: try FfiConverterTypeEmoteMessageContent.read(from: &buf)
        )
        
        case 2: return .image(
            content: try FfiConverterTypeImageMessageContent.read(from: &buf)
        )
        
        case 3: return .audio(
            content: try FfiConverterTypeAudioMessageContent.read(from: &buf)
        )
        
        case 4: return .video(
            content: try FfiConverterTypeVideoMessageContent.read(from: &buf)
        )
        
        case 5: return .file(
            content: try FfiConverterTypeFileMessageContent.read(from: &buf)
        )
        
        case 6: return .notice(
            content: try FfiConverterTypeNoticeMessageContent.read(from: &buf)
        )
        
        case 7: return .text(
            content: try FfiConverterTypeTextMessageContent.read(from: &buf)
        )
        
        case 8: return .location(
            content: try FfiConverterTypeLocationContent.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: MessageType, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .emote(content):
            writeInt(&buf, Int32(1))
            FfiConverterTypeEmoteMessageContent.write(content, into: &buf)
            
        
        case let .image(content):
            writeInt(&buf, Int32(2))
            FfiConverterTypeImageMessageContent.write(content, into: &buf)
            
        
        case let .audio(content):
            writeInt(&buf, Int32(3))
            FfiConverterTypeAudioMessageContent.write(content, into: &buf)
            
        
        case let .video(content):
            writeInt(&buf, Int32(4))
            FfiConverterTypeVideoMessageContent.write(content, into: &buf)
            
        
        case let .file(content):
            writeInt(&buf, Int32(5))
            FfiConverterTypeFileMessageContent.write(content, into: &buf)
            
        
        case let .notice(content):
            writeInt(&buf, Int32(6))
            FfiConverterTypeNoticeMessageContent.write(content, into: &buf)
            
        
        case let .text(content):
            writeInt(&buf, Int32(7))
            FfiConverterTypeTextMessageContent.write(content, into: &buf)
            
        
        case let .location(content):
            writeInt(&buf, Int32(8))
            FfiConverterTypeLocationContent.write(content, into: &buf)
            
        }
    }
}


public func FfiConverterTypeMessageType_lift(_ buf: RustBuffer) throws -> MessageType {
    return try FfiConverterTypeMessageType.lift(buf)
}

public func FfiConverterTypeMessageType_lower(_ value: MessageType) -> RustBuffer {
    return FfiConverterTypeMessageType.lower(value)
}




// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum NotificationEvent {
    
    case timeline(event: TimelineEvent)
    case invite(sender: String)
}

public struct FfiConverterTypeNotificationEvent: FfiConverterRustBuffer {
    typealias SwiftType = NotificationEvent

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NotificationEvent {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .timeline(
            event: try FfiConverterTypeTimelineEvent.read(from: &buf)
        )
        
        case 2: return .invite(
            sender: try FfiConverterString.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: NotificationEvent, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .timeline(event):
            writeInt(&buf, Int32(1))
            FfiConverterTypeTimelineEvent.write(event, into: &buf)
            
        
        case let .invite(sender):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(sender, into: &buf)
            
        }
    }
}


public func FfiConverterTypeNotificationEvent_lift(_ buf: RustBuffer) throws -> NotificationEvent {
    return try FfiConverterTypeNotificationEvent.lift(buf)
}

public func FfiConverterTypeNotificationEvent_lower(_ value: NotificationEvent) -> RustBuffer {
    return FfiConverterTypeNotificationEvent.lower(value)
}




public enum NotificationSettingsError {

    
    
    // Simple error enums only carry a message
    case Generic(message: String)
    
    // Simple error enums only carry a message
    case InvalidParameter(message: String)
    
    // Simple error enums only carry a message
    case InvalidRoomId(message: String)
    
    // Simple error enums only carry a message
    case RuleNotFound(message: String)
    
    // Simple error enums only carry a message
    case UnableToAddPushRule(message: String)
    
    // Simple error enums only carry a message
    case UnableToRemovePushRule(message: String)
    
    // Simple error enums only carry a message
    case UnableToSavePushRules(message: String)
    
    // Simple error enums only carry a message
    case UnableToUpdatePushRule(message: String)
    

    fileprivate static func uniffiErrorHandler(_ error: RustBuffer) throws -> Error {
        return try FfiConverterTypeNotificationSettingsError.lift(error)
    }
}


public struct FfiConverterTypeNotificationSettingsError: FfiConverterRustBuffer {
    typealias SwiftType = NotificationSettingsError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NotificationSettingsError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .Generic(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 2: return .InvalidParameter(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 3: return .InvalidRoomId(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 4: return .RuleNotFound(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 5: return .UnableToAddPushRule(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 6: return .UnableToRemovePushRule(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 7: return .UnableToSavePushRules(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 8: return .UnableToUpdatePushRule(
            message: try FfiConverterString.read(from: &buf)
        )
        

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: NotificationSettingsError, into buf: inout [UInt8]) {
        switch value {

        

        
        case .Generic(_ /* message is ignored*/):
            writeInt(&buf, Int32(1))
        case .InvalidParameter(_ /* message is ignored*/):
            writeInt(&buf, Int32(2))
        case .InvalidRoomId(_ /* message is ignored*/):
            writeInt(&buf, Int32(3))
        case .RuleNotFound(_ /* message is ignored*/):
            writeInt(&buf, Int32(4))
        case .UnableToAddPushRule(_ /* message is ignored*/):
            writeInt(&buf, Int32(5))
        case .UnableToRemovePushRule(_ /* message is ignored*/):
            writeInt(&buf, Int32(6))
        case .UnableToSavePushRules(_ /* message is ignored*/):
            writeInt(&buf, Int32(7))
        case .UnableToUpdatePushRule(_ /* message is ignored*/):
            writeInt(&buf, Int32(8))

        
        }
    }
}


extension NotificationSettingsError: Equatable, Hashable {}

extension NotificationSettingsError: Error { }

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum OtherState {
    
    case policyRuleRoom
    case policyRuleServer
    case policyRuleUser
    case roomAliases
    case roomAvatar(url: String?)
    case roomCanonicalAlias
    case roomCreate
    case roomEncryption
    case roomGuestAccess
    case roomHistoryVisibility
    case roomJoinRules
    case roomName(name: String?)
    case roomPinnedEvents
    case roomPowerLevels
    case roomServerAcl
    case roomThirdPartyInvite(displayName: String?)
    case roomTombstone
    case roomTopic(topic: String?)
    case spaceChild
    case spaceParent
    case custom(eventType: String)
}

public struct FfiConverterTypeOtherState: FfiConverterRustBuffer {
    typealias SwiftType = OtherState

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> OtherState {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .policyRuleRoom
        
        case 2: return .policyRuleServer
        
        case 3: return .policyRuleUser
        
        case 4: return .roomAliases
        
        case 5: return .roomAvatar(
            url: try FfiConverterOptionString.read(from: &buf)
        )
        
        case 6: return .roomCanonicalAlias
        
        case 7: return .roomCreate
        
        case 8: return .roomEncryption
        
        case 9: return .roomGuestAccess
        
        case 10: return .roomHistoryVisibility
        
        case 11: return .roomJoinRules
        
        case 12: return .roomName(
            name: try FfiConverterOptionString.read(from: &buf)
        )
        
        case 13: return .roomPinnedEvents
        
        case 14: return .roomPowerLevels
        
        case 15: return .roomServerAcl
        
        case 16: return .roomThirdPartyInvite(
            displayName: try FfiConverterOptionString.read(from: &buf)
        )
        
        case 17: return .roomTombstone
        
        case 18: return .roomTopic(
            topic: try FfiConverterOptionString.read(from: &buf)
        )
        
        case 19: return .spaceChild
        
        case 20: return .spaceParent
        
        case 21: return .custom(
            eventType: try FfiConverterString.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: OtherState, into buf: inout [UInt8]) {
        switch value {
        
        
        case .policyRuleRoom:
            writeInt(&buf, Int32(1))
        
        
        case .policyRuleServer:
            writeInt(&buf, Int32(2))
        
        
        case .policyRuleUser:
            writeInt(&buf, Int32(3))
        
        
        case .roomAliases:
            writeInt(&buf, Int32(4))
        
        
        case let .roomAvatar(url):
            writeInt(&buf, Int32(5))
            FfiConverterOptionString.write(url, into: &buf)
            
        
        case .roomCanonicalAlias:
            writeInt(&buf, Int32(6))
        
        
        case .roomCreate:
            writeInt(&buf, Int32(7))
        
        
        case .roomEncryption:
            writeInt(&buf, Int32(8))
        
        
        case .roomGuestAccess:
            writeInt(&buf, Int32(9))
        
        
        case .roomHistoryVisibility:
            writeInt(&buf, Int32(10))
        
        
        case .roomJoinRules:
            writeInt(&buf, Int32(11))
        
        
        case let .roomName(name):
            writeInt(&buf, Int32(12))
            FfiConverterOptionString.write(name, into: &buf)
            
        
        case .roomPinnedEvents:
            writeInt(&buf, Int32(13))
        
        
        case .roomPowerLevels:
            writeInt(&buf, Int32(14))
        
        
        case .roomServerAcl:
            writeInt(&buf, Int32(15))
        
        
        case let .roomThirdPartyInvite(displayName):
            writeInt(&buf, Int32(16))
            FfiConverterOptionString.write(displayName, into: &buf)
            
        
        case .roomTombstone:
            writeInt(&buf, Int32(17))
        
        
        case let .roomTopic(topic):
            writeInt(&buf, Int32(18))
            FfiConverterOptionString.write(topic, into: &buf)
            
        
        case .spaceChild:
            writeInt(&buf, Int32(19))
        
        
        case .spaceParent:
            writeInt(&buf, Int32(20))
        
        
        case let .custom(eventType):
            writeInt(&buf, Int32(21))
            FfiConverterString.write(eventType, into: &buf)
            
        }
    }
}


public func FfiConverterTypeOtherState_lift(_ buf: RustBuffer) throws -> OtherState {
    return try FfiConverterTypeOtherState.lift(buf)
}

public func FfiConverterTypeOtherState_lower(_ value: OtherState) -> RustBuffer {
    return FfiConverterTypeOtherState.lower(value)
}


extension OtherState: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum PaginationOptions {
    
    case singleRequest(eventLimit: UInt16, waitForToken: Bool)
    case untilNumItems(eventLimit: UInt16, items: UInt16, waitForToken: Bool)
}

public struct FfiConverterTypePaginationOptions: FfiConverterRustBuffer {
    typealias SwiftType = PaginationOptions

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PaginationOptions {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .singleRequest(
            eventLimit: try FfiConverterUInt16.read(from: &buf), 
            waitForToken: try FfiConverterBool.read(from: &buf)
        )
        
        case 2: return .untilNumItems(
            eventLimit: try FfiConverterUInt16.read(from: &buf), 
            items: try FfiConverterUInt16.read(from: &buf), 
            waitForToken: try FfiConverterBool.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: PaginationOptions, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .singleRequest(eventLimit,waitForToken):
            writeInt(&buf, Int32(1))
            FfiConverterUInt16.write(eventLimit, into: &buf)
            FfiConverterBool.write(waitForToken, into: &buf)
            
        
        case let .untilNumItems(eventLimit,items,waitForToken):
            writeInt(&buf, Int32(2))
            FfiConverterUInt16.write(eventLimit, into: &buf)
            FfiConverterUInt16.write(items, into: &buf)
            FfiConverterBool.write(waitForToken, into: &buf)
            
        }
    }
}


public func FfiConverterTypePaginationOptions_lift(_ buf: RustBuffer) throws -> PaginationOptions {
    return try FfiConverterTypePaginationOptions.lift(buf)
}

public func FfiConverterTypePaginationOptions_lower(_ value: PaginationOptions) -> RustBuffer {
    return FfiConverterTypePaginationOptions.lower(value)
}


extension PaginationOptions: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum PollKind {
    
    case disclosed
    case undisclosed
}

public struct FfiConverterTypePollKind: FfiConverterRustBuffer {
    typealias SwiftType = PollKind

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PollKind {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .disclosed
        
        case 2: return .undisclosed
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: PollKind, into buf: inout [UInt8]) {
        switch value {
        
        
        case .disclosed:
            writeInt(&buf, Int32(1))
        
        
        case .undisclosed:
            writeInt(&buf, Int32(2))
        
        }
    }
}


public func FfiConverterTypePollKind_lift(_ buf: RustBuffer) throws -> PollKind {
    return try FfiConverterTypePollKind.lift(buf)
}

public func FfiConverterTypePollKind_lower(_ value: PollKind) -> RustBuffer {
    return FfiConverterTypePollKind.lower(value)
}


extension PollKind: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum ProfileDetails {
    
    case unavailable
    case pending
    case ready(displayName: String?, displayNameAmbiguous: Bool, avatarUrl: String?)
    case error(message: String)
}

public struct FfiConverterTypeProfileDetails: FfiConverterRustBuffer {
    typealias SwiftType = ProfileDetails

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ProfileDetails {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .unavailable
        
        case 2: return .pending
        
        case 3: return .ready(
            displayName: try FfiConverterOptionString.read(from: &buf), 
            displayNameAmbiguous: try FfiConverterBool.read(from: &buf), 
            avatarUrl: try FfiConverterOptionString.read(from: &buf)
        )
        
        case 4: return .error(
            message: try FfiConverterString.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ProfileDetails, into buf: inout [UInt8]) {
        switch value {
        
        
        case .unavailable:
            writeInt(&buf, Int32(1))
        
        
        case .pending:
            writeInt(&buf, Int32(2))
        
        
        case let .ready(displayName,displayNameAmbiguous,avatarUrl):
            writeInt(&buf, Int32(3))
            FfiConverterOptionString.write(displayName, into: &buf)
            FfiConverterBool.write(displayNameAmbiguous, into: &buf)
            FfiConverterOptionString.write(avatarUrl, into: &buf)
            
        
        case let .error(message):
            writeInt(&buf, Int32(4))
            FfiConverterString.write(message, into: &buf)
            
        }
    }
}


public func FfiConverterTypeProfileDetails_lift(_ buf: RustBuffer) throws -> ProfileDetails {
    return try FfiConverterTypeProfileDetails.lift(buf)
}

public func FfiConverterTypeProfileDetails_lower(_ value: ProfileDetails) -> RustBuffer {
    return FfiConverterTypeProfileDetails.lower(value)
}


extension ProfileDetails: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum PushFormat {
    
    case eventIdOnly
}

public struct FfiConverterTypePushFormat: FfiConverterRustBuffer {
    typealias SwiftType = PushFormat

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PushFormat {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .eventIdOnly
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: PushFormat, into buf: inout [UInt8]) {
        switch value {
        
        
        case .eventIdOnly:
            writeInt(&buf, Int32(1))
        
        }
    }
}


public func FfiConverterTypePushFormat_lift(_ buf: RustBuffer) throws -> PushFormat {
    return try FfiConverterTypePushFormat.lift(buf)
}

public func FfiConverterTypePushFormat_lower(_ value: PushFormat) -> RustBuffer {
    return FfiConverterTypePushFormat.lower(value)
}


extension PushFormat: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum PusherKind {
    
    case http(data: HttpPusherData)
    case email
}

public struct FfiConverterTypePusherKind: FfiConverterRustBuffer {
    typealias SwiftType = PusherKind

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PusherKind {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .http(
            data: try FfiConverterTypeHttpPusherData.read(from: &buf)
        )
        
        case 2: return .email
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: PusherKind, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .http(data):
            writeInt(&buf, Int32(1))
            FfiConverterTypeHttpPusherData.write(data, into: &buf)
            
        
        case .email:
            writeInt(&buf, Int32(2))
        
        }
    }
}


public func FfiConverterTypePusherKind_lift(_ buf: RustBuffer) throws -> PusherKind {
    return try FfiConverterTypePusherKind.lift(buf)
}

public func FfiConverterTypePusherKind_lower(_ value: PusherKind) -> RustBuffer {
    return FfiConverterTypePusherKind.lower(value)
}


extension PusherKind: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum RepliedToEventDetails {
    
    case unavailable
    case pending
    case ready(content: TimelineItemContent, sender: String, senderProfile: ProfileDetails)
    case error(message: String)
}

public struct FfiConverterTypeRepliedToEventDetails: FfiConverterRustBuffer {
    typealias SwiftType = RepliedToEventDetails

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RepliedToEventDetails {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .unavailable
        
        case 2: return .pending
        
        case 3: return .ready(
            content: try FfiConverterTypeTimelineItemContent.read(from: &buf), 
            sender: try FfiConverterString.read(from: &buf), 
            senderProfile: try FfiConverterTypeProfileDetails.read(from: &buf)
        )
        
        case 4: return .error(
            message: try FfiConverterString.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: RepliedToEventDetails, into buf: inout [UInt8]) {
        switch value {
        
        
        case .unavailable:
            writeInt(&buf, Int32(1))
        
        
        case .pending:
            writeInt(&buf, Int32(2))
        
        
        case let .ready(content,sender,senderProfile):
            writeInt(&buf, Int32(3))
            FfiConverterTypeTimelineItemContent.write(content, into: &buf)
            FfiConverterString.write(sender, into: &buf)
            FfiConverterTypeProfileDetails.write(senderProfile, into: &buf)
            
        
        case let .error(message):
            writeInt(&buf, Int32(4))
            FfiConverterString.write(message, into: &buf)
            
        }
    }
}


public func FfiConverterTypeRepliedToEventDetails_lift(_ buf: RustBuffer) throws -> RepliedToEventDetails {
    return try FfiConverterTypeRepliedToEventDetails.lift(buf)
}

public func FfiConverterTypeRepliedToEventDetails_lower(_ value: RepliedToEventDetails) -> RustBuffer {
    return FfiConverterTypeRepliedToEventDetails.lower(value)
}




public enum RoomError {

    
    
    // Simple error enums only carry a message
    case InvalidAttachmentData(message: String)
    
    // Simple error enums only carry a message
    case InvalidAttachmentMimeType(message: String)
    
    // Simple error enums only carry a message
    case TimelineUnavailable(message: String)
    
    // Simple error enums only carry a message
    case InvalidThumbnailData(message: String)
    
    // Simple error enums only carry a message
    case FailedSendingAttachment(message: String)
    

    fileprivate static func uniffiErrorHandler(_ error: RustBuffer) throws -> Error {
        return try FfiConverterTypeRoomError.lift(error)
    }
}


public struct FfiConverterTypeRoomError: FfiConverterRustBuffer {
    typealias SwiftType = RoomError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RoomError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .InvalidAttachmentData(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 2: return .InvalidAttachmentMimeType(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 3: return .TimelineUnavailable(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 4: return .InvalidThumbnailData(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 5: return .FailedSendingAttachment(
            message: try FfiConverterString.read(from: &buf)
        )
        

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: RoomError, into buf: inout [UInt8]) {
        switch value {

        

        
        case .InvalidAttachmentData(_ /* message is ignored*/):
            writeInt(&buf, Int32(1))
        case .InvalidAttachmentMimeType(_ /* message is ignored*/):
            writeInt(&buf, Int32(2))
        case .TimelineUnavailable(_ /* message is ignored*/):
            writeInt(&buf, Int32(3))
        case .InvalidThumbnailData(_ /* message is ignored*/):
            writeInt(&buf, Int32(4))
        case .FailedSendingAttachment(_ /* message is ignored*/):
            writeInt(&buf, Int32(5))

        
        }
    }
}


extension RoomError: Equatable, Hashable {}

extension RoomError: Error { }

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum RoomListEntriesDynamicFilterKind {
    
    case all
    case normalizedMatchRoomName(pattern: String)
    case fuzzyMatchRoomName(pattern: String)
}

public struct FfiConverterTypeRoomListEntriesDynamicFilterKind: FfiConverterRustBuffer {
    typealias SwiftType = RoomListEntriesDynamicFilterKind

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RoomListEntriesDynamicFilterKind {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .all
        
        case 2: return .normalizedMatchRoomName(
            pattern: try FfiConverterString.read(from: &buf)
        )
        
        case 3: return .fuzzyMatchRoomName(
            pattern: try FfiConverterString.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: RoomListEntriesDynamicFilterKind, into buf: inout [UInt8]) {
        switch value {
        
        
        case .all:
            writeInt(&buf, Int32(1))
        
        
        case let .normalizedMatchRoomName(pattern):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(pattern, into: &buf)
            
        
        case let .fuzzyMatchRoomName(pattern):
            writeInt(&buf, Int32(3))
            FfiConverterString.write(pattern, into: &buf)
            
        }
    }
}


public func FfiConverterTypeRoomListEntriesDynamicFilterKind_lift(_ buf: RustBuffer) throws -> RoomListEntriesDynamicFilterKind {
    return try FfiConverterTypeRoomListEntriesDynamicFilterKind.lift(buf)
}

public func FfiConverterTypeRoomListEntriesDynamicFilterKind_lower(_ value: RoomListEntriesDynamicFilterKind) -> RustBuffer {
    return FfiConverterTypeRoomListEntriesDynamicFilterKind.lower(value)
}


extension RoomListEntriesDynamicFilterKind: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum RoomListEntriesUpdate {
    
    case append(values: [RoomListEntry])
    case clear
    case pushFront(value: RoomListEntry)
    case pushBack(value: RoomListEntry)
    case popFront
    case popBack
    case insert(index: UInt32, value: RoomListEntry)
    case set(index: UInt32, value: RoomListEntry)
    case remove(index: UInt32)
    case reset(values: [RoomListEntry])
}

public struct FfiConverterTypeRoomListEntriesUpdate: FfiConverterRustBuffer {
    typealias SwiftType = RoomListEntriesUpdate

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RoomListEntriesUpdate {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .append(
            values: try FfiConverterSequenceTypeRoomListEntry.read(from: &buf)
        )
        
        case 2: return .clear
        
        case 3: return .pushFront(
            value: try FfiConverterTypeRoomListEntry.read(from: &buf)
        )
        
        case 4: return .pushBack(
            value: try FfiConverterTypeRoomListEntry.read(from: &buf)
        )
        
        case 5: return .popFront
        
        case 6: return .popBack
        
        case 7: return .insert(
            index: try FfiConverterUInt32.read(from: &buf), 
            value: try FfiConverterTypeRoomListEntry.read(from: &buf)
        )
        
        case 8: return .set(
            index: try FfiConverterUInt32.read(from: &buf), 
            value: try FfiConverterTypeRoomListEntry.read(from: &buf)
        )
        
        case 9: return .remove(
            index: try FfiConverterUInt32.read(from: &buf)
        )
        
        case 10: return .reset(
            values: try FfiConverterSequenceTypeRoomListEntry.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: RoomListEntriesUpdate, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .append(values):
            writeInt(&buf, Int32(1))
            FfiConverterSequenceTypeRoomListEntry.write(values, into: &buf)
            
        
        case .clear:
            writeInt(&buf, Int32(2))
        
        
        case let .pushFront(value):
            writeInt(&buf, Int32(3))
            FfiConverterTypeRoomListEntry.write(value, into: &buf)
            
        
        case let .pushBack(value):
            writeInt(&buf, Int32(4))
            FfiConverterTypeRoomListEntry.write(value, into: &buf)
            
        
        case .popFront:
            writeInt(&buf, Int32(5))
        
        
        case .popBack:
            writeInt(&buf, Int32(6))
        
        
        case let .insert(index,value):
            writeInt(&buf, Int32(7))
            FfiConverterUInt32.write(index, into: &buf)
            FfiConverterTypeRoomListEntry.write(value, into: &buf)
            
        
        case let .set(index,value):
            writeInt(&buf, Int32(8))
            FfiConverterUInt32.write(index, into: &buf)
            FfiConverterTypeRoomListEntry.write(value, into: &buf)
            
        
        case let .remove(index):
            writeInt(&buf, Int32(9))
            FfiConverterUInt32.write(index, into: &buf)
            
        
        case let .reset(values):
            writeInt(&buf, Int32(10))
            FfiConverterSequenceTypeRoomListEntry.write(values, into: &buf)
            
        }
    }
}


public func FfiConverterTypeRoomListEntriesUpdate_lift(_ buf: RustBuffer) throws -> RoomListEntriesUpdate {
    return try FfiConverterTypeRoomListEntriesUpdate.lift(buf)
}

public func FfiConverterTypeRoomListEntriesUpdate_lower(_ value: RoomListEntriesUpdate) -> RustBuffer {
    return FfiConverterTypeRoomListEntriesUpdate.lower(value)
}


extension RoomListEntriesUpdate: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum RoomListEntry {
    
    case empty
    case invalidated(roomId: String)
    case filled(roomId: String)
}

public struct FfiConverterTypeRoomListEntry: FfiConverterRustBuffer {
    typealias SwiftType = RoomListEntry

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RoomListEntry {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .empty
        
        case 2: return .invalidated(
            roomId: try FfiConverterString.read(from: &buf)
        )
        
        case 3: return .filled(
            roomId: try FfiConverterString.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: RoomListEntry, into buf: inout [UInt8]) {
        switch value {
        
        
        case .empty:
            writeInt(&buf, Int32(1))
        
        
        case let .invalidated(roomId):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(roomId, into: &buf)
            
        
        case let .filled(roomId):
            writeInt(&buf, Int32(3))
            FfiConverterString.write(roomId, into: &buf)
            
        }
    }
}


public func FfiConverterTypeRoomListEntry_lift(_ buf: RustBuffer) throws -> RoomListEntry {
    return try FfiConverterTypeRoomListEntry.lift(buf)
}

public func FfiConverterTypeRoomListEntry_lower(_ value: RoomListEntry) -> RustBuffer {
    return FfiConverterTypeRoomListEntry.lower(value)
}


extension RoomListEntry: Equatable, Hashable {}



public enum RoomListError {

    
    
    case SlidingSync(error: String)
    case UnknownList(listName: String)
    case InputCannotBeApplied
    case RoomNotFound(roomName: String)
    case InvalidRoomId(error: String)

    fileprivate static func uniffiErrorHandler(_ error: RustBuffer) throws -> Error {
        return try FfiConverterTypeRoomListError.lift(error)
    }
}


public struct FfiConverterTypeRoomListError: FfiConverterRustBuffer {
    typealias SwiftType = RoomListError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RoomListError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .SlidingSync(
            error: try FfiConverterString.read(from: &buf)
            )
        case 2: return .UnknownList(
            listName: try FfiConverterString.read(from: &buf)
            )
        case 3: return .InputCannotBeApplied
        case 4: return .RoomNotFound(
            roomName: try FfiConverterString.read(from: &buf)
            )
        case 5: return .InvalidRoomId(
            error: try FfiConverterString.read(from: &buf)
            )

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: RoomListError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case let .SlidingSync(error):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(error, into: &buf)
            
        
        case let .UnknownList(listName):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(listName, into: &buf)
            
        
        case .InputCannotBeApplied:
            writeInt(&buf, Int32(3))
        
        
        case let .RoomNotFound(roomName):
            writeInt(&buf, Int32(4))
            FfiConverterString.write(roomName, into: &buf)
            
        
        case let .InvalidRoomId(error):
            writeInt(&buf, Int32(5))
            FfiConverterString.write(error, into: &buf)
            
        }
    }
}


extension RoomListError: Equatable, Hashable {}

extension RoomListError: Error { }

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum RoomListInput {
    
    case viewport(ranges: [RoomListRange])
}

public struct FfiConverterTypeRoomListInput: FfiConverterRustBuffer {
    typealias SwiftType = RoomListInput

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RoomListInput {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .viewport(
            ranges: try FfiConverterSequenceTypeRoomListRange.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: RoomListInput, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .viewport(ranges):
            writeInt(&buf, Int32(1))
            FfiConverterSequenceTypeRoomListRange.write(ranges, into: &buf)
            
        }
    }
}


public func FfiConverterTypeRoomListInput_lift(_ buf: RustBuffer) throws -> RoomListInput {
    return try FfiConverterTypeRoomListInput.lift(buf)
}

public func FfiConverterTypeRoomListInput_lower(_ value: RoomListInput) -> RustBuffer {
    return FfiConverterTypeRoomListInput.lower(value)
}


extension RoomListInput: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum RoomListLoadingState {
    
    case notLoaded
    case loaded(maximumNumberOfRooms: UInt32?)
}

public struct FfiConverterTypeRoomListLoadingState: FfiConverterRustBuffer {
    typealias SwiftType = RoomListLoadingState

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RoomListLoadingState {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .notLoaded
        
        case 2: return .loaded(
            maximumNumberOfRooms: try FfiConverterOptionUInt32.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: RoomListLoadingState, into buf: inout [UInt8]) {
        switch value {
        
        
        case .notLoaded:
            writeInt(&buf, Int32(1))
        
        
        case let .loaded(maximumNumberOfRooms):
            writeInt(&buf, Int32(2))
            FfiConverterOptionUInt32.write(maximumNumberOfRooms, into: &buf)
            
        }
    }
}


public func FfiConverterTypeRoomListLoadingState_lift(_ buf: RustBuffer) throws -> RoomListLoadingState {
    return try FfiConverterTypeRoomListLoadingState.lift(buf)
}

public func FfiConverterTypeRoomListLoadingState_lower(_ value: RoomListLoadingState) -> RustBuffer {
    return FfiConverterTypeRoomListLoadingState.lower(value)
}


extension RoomListLoadingState: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum RoomListServiceState {
    
    case initial
    case settingUp
    case running
    case error
    case terminated
}

public struct FfiConverterTypeRoomListServiceState: FfiConverterRustBuffer {
    typealias SwiftType = RoomListServiceState

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RoomListServiceState {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .initial
        
        case 2: return .settingUp
        
        case 3: return .running
        
        case 4: return .error
        
        case 5: return .terminated
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: RoomListServiceState, into buf: inout [UInt8]) {
        switch value {
        
        
        case .initial:
            writeInt(&buf, Int32(1))
        
        
        case .settingUp:
            writeInt(&buf, Int32(2))
        
        
        case .running:
            writeInt(&buf, Int32(3))
        
        
        case .error:
            writeInt(&buf, Int32(4))
        
        
        case .terminated:
            writeInt(&buf, Int32(5))
        
        }
    }
}


public func FfiConverterTypeRoomListServiceState_lift(_ buf: RustBuffer) throws -> RoomListServiceState {
    return try FfiConverterTypeRoomListServiceState.lift(buf)
}

public func FfiConverterTypeRoomListServiceState_lower(_ value: RoomListServiceState) -> RustBuffer {
    return FfiConverterTypeRoomListServiceState.lower(value)
}


extension RoomListServiceState: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum RoomNotificationMode {
    
    case allMessages
    case mentionsAndKeywordsOnly
    case mute
}

public struct FfiConverterTypeRoomNotificationMode: FfiConverterRustBuffer {
    typealias SwiftType = RoomNotificationMode

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RoomNotificationMode {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .allMessages
        
        case 2: return .mentionsAndKeywordsOnly
        
        case 3: return .mute
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: RoomNotificationMode, into buf: inout [UInt8]) {
        switch value {
        
        
        case .allMessages:
            writeInt(&buf, Int32(1))
        
        
        case .mentionsAndKeywordsOnly:
            writeInt(&buf, Int32(2))
        
        
        case .mute:
            writeInt(&buf, Int32(3))
        
        }
    }
}


public func FfiConverterTypeRoomNotificationMode_lift(_ buf: RustBuffer) throws -> RoomNotificationMode {
    return try FfiConverterTypeRoomNotificationMode.lift(buf)
}

public func FfiConverterTypeRoomNotificationMode_lower(_ value: RoomNotificationMode) -> RustBuffer {
    return FfiConverterTypeRoomNotificationMode.lower(value)
}


extension RoomNotificationMode: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum RoomPreset {
    
    case privateChat
    case publicChat
    case trustedPrivateChat
}

public struct FfiConverterTypeRoomPreset: FfiConverterRustBuffer {
    typealias SwiftType = RoomPreset

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RoomPreset {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .privateChat
        
        case 2: return .publicChat
        
        case 3: return .trustedPrivateChat
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: RoomPreset, into buf: inout [UInt8]) {
        switch value {
        
        
        case .privateChat:
            writeInt(&buf, Int32(1))
        
        
        case .publicChat:
            writeInt(&buf, Int32(2))
        
        
        case .trustedPrivateChat:
            writeInt(&buf, Int32(3))
        
        }
    }
}


public func FfiConverterTypeRoomPreset_lift(_ buf: RustBuffer) throws -> RoomPreset {
    return try FfiConverterTypeRoomPreset.lift(buf)
}

public func FfiConverterTypeRoomPreset_lower(_ value: RoomPreset) -> RustBuffer {
    return FfiConverterTypeRoomPreset.lower(value)
}


extension RoomPreset: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum RoomVisibility {
    
    case `public`
    case `private`
}

public struct FfiConverterTypeRoomVisibility: FfiConverterRustBuffer {
    typealias SwiftType = RoomVisibility

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RoomVisibility {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .public
        
        case 2: return .private
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: RoomVisibility, into buf: inout [UInt8]) {
        switch value {
        
        
        case .public:
            writeInt(&buf, Int32(1))
        
        
        case .private:
            writeInt(&buf, Int32(2))
        
        }
    }
}


public func FfiConverterTypeRoomVisibility_lift(_ buf: RustBuffer) throws -> RoomVisibility {
    return try FfiConverterTypeRoomVisibility.lift(buf)
}

public func FfiConverterTypeRoomVisibility_lower(_ value: RoomVisibility) -> RustBuffer {
    return FfiConverterTypeRoomVisibility.lower(value)
}


extension RoomVisibility: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum StateEventContent {
    
    case policyRuleRoom
    case policyRuleServer
    case policyRuleUser
    case roomAliases
    case roomAvatar
    case roomCanonicalAlias
    case roomCreate
    case roomEncryption
    case roomGuestAccess
    case roomHistoryVisibility
    case roomJoinRules
    case roomMemberContent(userId: String, membershipState: MembershipState)
    case roomName
    case roomPinnedEvents
    case roomPowerLevels
    case roomServerAcl
    case roomThirdPartyInvite
    case roomTombstone
    case roomTopic
    case spaceChild
    case spaceParent
}

public struct FfiConverterTypeStateEventContent: FfiConverterRustBuffer {
    typealias SwiftType = StateEventContent

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> StateEventContent {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .policyRuleRoom
        
        case 2: return .policyRuleServer
        
        case 3: return .policyRuleUser
        
        case 4: return .roomAliases
        
        case 5: return .roomAvatar
        
        case 6: return .roomCanonicalAlias
        
        case 7: return .roomCreate
        
        case 8: return .roomEncryption
        
        case 9: return .roomGuestAccess
        
        case 10: return .roomHistoryVisibility
        
        case 11: return .roomJoinRules
        
        case 12: return .roomMemberContent(
            userId: try FfiConverterString.read(from: &buf), 
            membershipState: try FfiConverterTypeMembershipState.read(from: &buf)
        )
        
        case 13: return .roomName
        
        case 14: return .roomPinnedEvents
        
        case 15: return .roomPowerLevels
        
        case 16: return .roomServerAcl
        
        case 17: return .roomThirdPartyInvite
        
        case 18: return .roomTombstone
        
        case 19: return .roomTopic
        
        case 20: return .spaceChild
        
        case 21: return .spaceParent
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: StateEventContent, into buf: inout [UInt8]) {
        switch value {
        
        
        case .policyRuleRoom:
            writeInt(&buf, Int32(1))
        
        
        case .policyRuleServer:
            writeInt(&buf, Int32(2))
        
        
        case .policyRuleUser:
            writeInt(&buf, Int32(3))
        
        
        case .roomAliases:
            writeInt(&buf, Int32(4))
        
        
        case .roomAvatar:
            writeInt(&buf, Int32(5))
        
        
        case .roomCanonicalAlias:
            writeInt(&buf, Int32(6))
        
        
        case .roomCreate:
            writeInt(&buf, Int32(7))
        
        
        case .roomEncryption:
            writeInt(&buf, Int32(8))
        
        
        case .roomGuestAccess:
            writeInt(&buf, Int32(9))
        
        
        case .roomHistoryVisibility:
            writeInt(&buf, Int32(10))
        
        
        case .roomJoinRules:
            writeInt(&buf, Int32(11))
        
        
        case let .roomMemberContent(userId,membershipState):
            writeInt(&buf, Int32(12))
            FfiConverterString.write(userId, into: &buf)
            FfiConverterTypeMembershipState.write(membershipState, into: &buf)
            
        
        case .roomName:
            writeInt(&buf, Int32(13))
        
        
        case .roomPinnedEvents:
            writeInt(&buf, Int32(14))
        
        
        case .roomPowerLevels:
            writeInt(&buf, Int32(15))
        
        
        case .roomServerAcl:
            writeInt(&buf, Int32(16))
        
        
        case .roomThirdPartyInvite:
            writeInt(&buf, Int32(17))
        
        
        case .roomTombstone:
            writeInt(&buf, Int32(18))
        
        
        case .roomTopic:
            writeInt(&buf, Int32(19))
        
        
        case .spaceChild:
            writeInt(&buf, Int32(20))
        
        
        case .spaceParent:
            writeInt(&buf, Int32(21))
        
        }
    }
}


public func FfiConverterTypeStateEventContent_lift(_ buf: RustBuffer) throws -> StateEventContent {
    return try FfiConverterTypeStateEventContent.lift(buf)
}

public func FfiConverterTypeStateEventContent_lower(_ value: StateEventContent) -> RustBuffer {
    return FfiConverterTypeStateEventContent.lower(value)
}


extension StateEventContent: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum StateEventType {
    
    case policyRuleRoom
    case policyRuleServer
    case policyRuleUser
    case roomAliases
    case roomAvatar
    case roomCanonicalAlias
    case roomCreate
    case roomEncryption
    case roomGuestAccess
    case roomHistoryVisibility
    case roomJoinRules
    case roomMemberEvent
    case roomName
    case roomPinnedEvents
    case roomPowerLevels
    case roomServerAcl
    case roomThirdPartyInvite
    case roomTombstone
    case roomTopic
    case spaceChild
    case spaceParent
}

public struct FfiConverterTypeStateEventType: FfiConverterRustBuffer {
    typealias SwiftType = StateEventType

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> StateEventType {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .policyRuleRoom
        
        case 2: return .policyRuleServer
        
        case 3: return .policyRuleUser
        
        case 4: return .roomAliases
        
        case 5: return .roomAvatar
        
        case 6: return .roomCanonicalAlias
        
        case 7: return .roomCreate
        
        case 8: return .roomEncryption
        
        case 9: return .roomGuestAccess
        
        case 10: return .roomHistoryVisibility
        
        case 11: return .roomJoinRules
        
        case 12: return .roomMemberEvent
        
        case 13: return .roomName
        
        case 14: return .roomPinnedEvents
        
        case 15: return .roomPowerLevels
        
        case 16: return .roomServerAcl
        
        case 17: return .roomThirdPartyInvite
        
        case 18: return .roomTombstone
        
        case 19: return .roomTopic
        
        case 20: return .spaceChild
        
        case 21: return .spaceParent
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: StateEventType, into buf: inout [UInt8]) {
        switch value {
        
        
        case .policyRuleRoom:
            writeInt(&buf, Int32(1))
        
        
        case .policyRuleServer:
            writeInt(&buf, Int32(2))
        
        
        case .policyRuleUser:
            writeInt(&buf, Int32(3))
        
        
        case .roomAliases:
            writeInt(&buf, Int32(4))
        
        
        case .roomAvatar:
            writeInt(&buf, Int32(5))
        
        
        case .roomCanonicalAlias:
            writeInt(&buf, Int32(6))
        
        
        case .roomCreate:
            writeInt(&buf, Int32(7))
        
        
        case .roomEncryption:
            writeInt(&buf, Int32(8))
        
        
        case .roomGuestAccess:
            writeInt(&buf, Int32(9))
        
        
        case .roomHistoryVisibility:
            writeInt(&buf, Int32(10))
        
        
        case .roomJoinRules:
            writeInt(&buf, Int32(11))
        
        
        case .roomMemberEvent:
            writeInt(&buf, Int32(12))
        
        
        case .roomName:
            writeInt(&buf, Int32(13))
        
        
        case .roomPinnedEvents:
            writeInt(&buf, Int32(14))
        
        
        case .roomPowerLevels:
            writeInt(&buf, Int32(15))
        
        
        case .roomServerAcl:
            writeInt(&buf, Int32(16))
        
        
        case .roomThirdPartyInvite:
            writeInt(&buf, Int32(17))
        
        
        case .roomTombstone:
            writeInt(&buf, Int32(18))
        
        
        case .roomTopic:
            writeInt(&buf, Int32(19))
        
        
        case .spaceChild:
            writeInt(&buf, Int32(20))
        
        
        case .spaceParent:
            writeInt(&buf, Int32(21))
        
        }
    }
}


public func FfiConverterTypeStateEventType_lift(_ buf: RustBuffer) throws -> StateEventType {
    return try FfiConverterTypeStateEventType.lift(buf)
}

public func FfiConverterTypeStateEventType_lower(_ value: StateEventType) -> RustBuffer {
    return FfiConverterTypeStateEventType.lower(value)
}


extension StateEventType: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum SyncServiceState {
    
    case idle
    case running
    case terminated
    case error
}

public struct FfiConverterTypeSyncServiceState: FfiConverterRustBuffer {
    typealias SwiftType = SyncServiceState

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SyncServiceState {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .idle
        
        case 2: return .running
        
        case 3: return .terminated
        
        case 4: return .error
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: SyncServiceState, into buf: inout [UInt8]) {
        switch value {
        
        
        case .idle:
            writeInt(&buf, Int32(1))
        
        
        case .running:
            writeInt(&buf, Int32(2))
        
        
        case .terminated:
            writeInt(&buf, Int32(3))
        
        
        case .error:
            writeInt(&buf, Int32(4))
        
        }
    }
}


public func FfiConverterTypeSyncServiceState_lift(_ buf: RustBuffer) throws -> SyncServiceState {
    return try FfiConverterTypeSyncServiceState.lift(buf)
}

public func FfiConverterTypeSyncServiceState_lower(_ value: SyncServiceState) -> RustBuffer {
    return FfiConverterTypeSyncServiceState.lower(value)
}


extension SyncServiceState: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum TimelineChange {
    
    case append
    case clear
    case insert
    case set
    case remove
    case pushBack
    case pushFront
    case popBack
    case popFront
    case reset
}

public struct FfiConverterTypeTimelineChange: FfiConverterRustBuffer {
    typealias SwiftType = TimelineChange

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TimelineChange {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .append
        
        case 2: return .clear
        
        case 3: return .insert
        
        case 4: return .set
        
        case 5: return .remove
        
        case 6: return .pushBack
        
        case 7: return .pushFront
        
        case 8: return .popBack
        
        case 9: return .popFront
        
        case 10: return .reset
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: TimelineChange, into buf: inout [UInt8]) {
        switch value {
        
        
        case .append:
            writeInt(&buf, Int32(1))
        
        
        case .clear:
            writeInt(&buf, Int32(2))
        
        
        case .insert:
            writeInt(&buf, Int32(3))
        
        
        case .set:
            writeInt(&buf, Int32(4))
        
        
        case .remove:
            writeInt(&buf, Int32(5))
        
        
        case .pushBack:
            writeInt(&buf, Int32(6))
        
        
        case .pushFront:
            writeInt(&buf, Int32(7))
        
        
        case .popBack:
            writeInt(&buf, Int32(8))
        
        
        case .popFront:
            writeInt(&buf, Int32(9))
        
        
        case .reset:
            writeInt(&buf, Int32(10))
        
        }
    }
}


public func FfiConverterTypeTimelineChange_lift(_ buf: RustBuffer) throws -> TimelineChange {
    return try FfiConverterTypeTimelineChange.lift(buf)
}

public func FfiConverterTypeTimelineChange_lower(_ value: TimelineChange) -> RustBuffer {
    return FfiConverterTypeTimelineChange.lower(value)
}


extension TimelineChange: Equatable, Hashable {}



public enum TimelineError {

    
    
    // Simple error enums only carry a message
    case MissingMediaInfoField(message: String)
    
    // Simple error enums only carry a message
    case InvalidMediaInfoField(message: String)
    

    fileprivate static func uniffiErrorHandler(_ error: RustBuffer) throws -> Error {
        return try FfiConverterTypeTimelineError.lift(error)
    }
}


public struct FfiConverterTypeTimelineError: FfiConverterRustBuffer {
    typealias SwiftType = TimelineError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TimelineError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .MissingMediaInfoField(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 2: return .InvalidMediaInfoField(
            message: try FfiConverterString.read(from: &buf)
        )
        

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: TimelineError, into buf: inout [UInt8]) {
        switch value {

        

        
        case .MissingMediaInfoField(_ /* message is ignored*/):
            writeInt(&buf, Int32(1))
        case .InvalidMediaInfoField(_ /* message is ignored*/):
            writeInt(&buf, Int32(2))

        
        }
    }
}


extension TimelineError: Equatable, Hashable {}

extension TimelineError: Error { }

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum TimelineEventType {
    
    case messageLike(content: MessageLikeEventContent)
    case state(content: StateEventContent)
}

public struct FfiConverterTypeTimelineEventType: FfiConverterRustBuffer {
    typealias SwiftType = TimelineEventType

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TimelineEventType {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .messageLike(
            content: try FfiConverterTypeMessageLikeEventContent.read(from: &buf)
        )
        
        case 2: return .state(
            content: try FfiConverterTypeStateEventContent.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: TimelineEventType, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .messageLike(content):
            writeInt(&buf, Int32(1))
            FfiConverterTypeMessageLikeEventContent.write(content, into: &buf)
            
        
        case let .state(content):
            writeInt(&buf, Int32(2))
            FfiConverterTypeStateEventContent.write(content, into: &buf)
            
        }
    }
}


public func FfiConverterTypeTimelineEventType_lift(_ buf: RustBuffer) throws -> TimelineEventType {
    return try FfiConverterTypeTimelineEventType.lift(buf)
}

public func FfiConverterTypeTimelineEventType_lower(_ value: TimelineEventType) -> RustBuffer {
    return FfiConverterTypeTimelineEventType.lower(value)
}




// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum TimelineItemContentKind {
    
    case message
    case redactedMessage
    case sticker(body: String, info: ImageInfo, url: String)
    case poll(question: String, kind: PollKind, maxSelections: UInt64, answers: [PollAnswer], votes: [String: [String]], endTime: UInt64?)
    case unableToDecrypt(msg: EncryptedMessage)
    case roomMembership(userId: String, change: MembershipChange?)
    case profileChange(displayName: String?, prevDisplayName: String?, avatarUrl: String?, prevAvatarUrl: String?)
    case state(stateKey: String, content: OtherState)
    case failedToParseMessageLike(eventType: String, error: String)
    case failedToParseState(eventType: String, stateKey: String, error: String)
}

public struct FfiConverterTypeTimelineItemContentKind: FfiConverterRustBuffer {
    typealias SwiftType = TimelineItemContentKind

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TimelineItemContentKind {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .message
        
        case 2: return .redactedMessage
        
        case 3: return .sticker(
            body: try FfiConverterString.read(from: &buf), 
            info: try FfiConverterTypeImageInfo.read(from: &buf), 
            url: try FfiConverterString.read(from: &buf)
        )
        
        case 4: return .poll(
            question: try FfiConverterString.read(from: &buf), 
            kind: try FfiConverterTypePollKind.read(from: &buf), 
            maxSelections: try FfiConverterUInt64.read(from: &buf), 
            answers: try FfiConverterSequenceTypePollAnswer.read(from: &buf), 
            votes: try FfiConverterDictionaryStringSequenceString.read(from: &buf), 
            endTime: try FfiConverterOptionUInt64.read(from: &buf)
        )
        
        case 5: return .unableToDecrypt(
            msg: try FfiConverterTypeEncryptedMessage.read(from: &buf)
        )
        
        case 6: return .roomMembership(
            userId: try FfiConverterString.read(from: &buf), 
            change: try FfiConverterOptionTypeMembershipChange.read(from: &buf)
        )
        
        case 7: return .profileChange(
            displayName: try FfiConverterOptionString.read(from: &buf), 
            prevDisplayName: try FfiConverterOptionString.read(from: &buf), 
            avatarUrl: try FfiConverterOptionString.read(from: &buf), 
            prevAvatarUrl: try FfiConverterOptionString.read(from: &buf)
        )
        
        case 8: return .state(
            stateKey: try FfiConverterString.read(from: &buf), 
            content: try FfiConverterTypeOtherState.read(from: &buf)
        )
        
        case 9: return .failedToParseMessageLike(
            eventType: try FfiConverterString.read(from: &buf), 
            error: try FfiConverterString.read(from: &buf)
        )
        
        case 10: return .failedToParseState(
            eventType: try FfiConverterString.read(from: &buf), 
            stateKey: try FfiConverterString.read(from: &buf), 
            error: try FfiConverterString.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: TimelineItemContentKind, into buf: inout [UInt8]) {
        switch value {
        
        
        case .message:
            writeInt(&buf, Int32(1))
        
        
        case .redactedMessage:
            writeInt(&buf, Int32(2))
        
        
        case let .sticker(body,info,url):
            writeInt(&buf, Int32(3))
            FfiConverterString.write(body, into: &buf)
            FfiConverterTypeImageInfo.write(info, into: &buf)
            FfiConverterString.write(url, into: &buf)
            
        
        case let .poll(question,kind,maxSelections,answers,votes,endTime):
            writeInt(&buf, Int32(4))
            FfiConverterString.write(question, into: &buf)
            FfiConverterTypePollKind.write(kind, into: &buf)
            FfiConverterUInt64.write(maxSelections, into: &buf)
            FfiConverterSequenceTypePollAnswer.write(answers, into: &buf)
            FfiConverterDictionaryStringSequenceString.write(votes, into: &buf)
            FfiConverterOptionUInt64.write(endTime, into: &buf)
            
        
        case let .unableToDecrypt(msg):
            writeInt(&buf, Int32(5))
            FfiConverterTypeEncryptedMessage.write(msg, into: &buf)
            
        
        case let .roomMembership(userId,change):
            writeInt(&buf, Int32(6))
            FfiConverterString.write(userId, into: &buf)
            FfiConverterOptionTypeMembershipChange.write(change, into: &buf)
            
        
        case let .profileChange(displayName,prevDisplayName,avatarUrl,prevAvatarUrl):
            writeInt(&buf, Int32(7))
            FfiConverterOptionString.write(displayName, into: &buf)
            FfiConverterOptionString.write(prevDisplayName, into: &buf)
            FfiConverterOptionString.write(avatarUrl, into: &buf)
            FfiConverterOptionString.write(prevAvatarUrl, into: &buf)
            
        
        case let .state(stateKey,content):
            writeInt(&buf, Int32(8))
            FfiConverterString.write(stateKey, into: &buf)
            FfiConverterTypeOtherState.write(content, into: &buf)
            
        
        case let .failedToParseMessageLike(eventType,error):
            writeInt(&buf, Int32(9))
            FfiConverterString.write(eventType, into: &buf)
            FfiConverterString.write(error, into: &buf)
            
        
        case let .failedToParseState(eventType,stateKey,error):
            writeInt(&buf, Int32(10))
            FfiConverterString.write(eventType, into: &buf)
            FfiConverterString.write(stateKey, into: &buf)
            FfiConverterString.write(error, into: &buf)
            
        }
    }
}


public func FfiConverterTypeTimelineItemContentKind_lift(_ buf: RustBuffer) throws -> TimelineItemContentKind {
    return try FfiConverterTypeTimelineItemContentKind.lift(buf)
}

public func FfiConverterTypeTimelineItemContentKind_lower(_ value: TimelineItemContentKind) -> RustBuffer {
    return FfiConverterTypeTimelineItemContentKind.lower(value)
}




// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum VirtualTimelineItem {
    
    case dayDivider(ts: UInt64)
    case readMarker
}

public struct FfiConverterTypeVirtualTimelineItem: FfiConverterRustBuffer {
    typealias SwiftType = VirtualTimelineItem

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> VirtualTimelineItem {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .dayDivider(
            ts: try FfiConverterUInt64.read(from: &buf)
        )
        
        case 2: return .readMarker
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: VirtualTimelineItem, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .dayDivider(ts):
            writeInt(&buf, Int32(1))
            FfiConverterUInt64.write(ts, into: &buf)
            
        
        case .readMarker:
            writeInt(&buf, Int32(2))
        
        }
    }
}


public func FfiConverterTypeVirtualTimelineItem_lift(_ buf: RustBuffer) throws -> VirtualTimelineItem {
    return try FfiConverterTypeVirtualTimelineItem.lift(buf)
}

public func FfiConverterTypeVirtualTimelineItem_lower(_ value: VirtualTimelineItem) -> RustBuffer {
    return FfiConverterTypeVirtualTimelineItem.lower(value)
}


extension VirtualTimelineItem: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum WidgetEventFilter {
    
    case messageLike(eventType: String, msgtype: String?)
    case state(eventType: String, stateKey: String?)
}

public struct FfiConverterTypeWidgetEventFilter: FfiConverterRustBuffer {
    typealias SwiftType = WidgetEventFilter

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> WidgetEventFilter {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .messageLike(
            eventType: try FfiConverterString.read(from: &buf), 
            msgtype: try FfiConverterOptionString.read(from: &buf)
        )
        
        case 2: return .state(
            eventType: try FfiConverterString.read(from: &buf), 
            stateKey: try FfiConverterOptionString.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: WidgetEventFilter, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .messageLike(eventType,msgtype):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(eventType, into: &buf)
            FfiConverterOptionString.write(msgtype, into: &buf)
            
        
        case let .state(eventType,stateKey):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(eventType, into: &buf)
            FfiConverterOptionString.write(stateKey, into: &buf)
            
        }
    }
}


public func FfiConverterTypeWidgetEventFilter_lift(_ buf: RustBuffer) throws -> WidgetEventFilter {
    return try FfiConverterTypeWidgetEventFilter.lift(buf)
}

public func FfiConverterTypeWidgetEventFilter_lower(_ value: WidgetEventFilter) -> RustBuffer {
    return FfiConverterTypeWidgetEventFilter.lower(value)
}


extension WidgetEventFilter: Equatable, Hashable {}



fileprivate extension NSLock {
    func withLock<T>(f: () throws -> T) rethrows -> T {
        self.lock()
        defer { self.unlock() }
        return try f()
    }
}

fileprivate typealias UniFFICallbackHandle = UInt64
fileprivate class UniFFICallbackHandleMap<T> {
    private var leftMap: [UniFFICallbackHandle: T] = [:]
    private var counter: [UniFFICallbackHandle: UInt64] = [:]
    private var rightMap: [ObjectIdentifier: UniFFICallbackHandle] = [:]

    private let lock = NSLock()
    private var currentHandle: UniFFICallbackHandle = 0
    private let stride: UniFFICallbackHandle = 1

    func insert(obj: T) -> UniFFICallbackHandle {
        lock.withLock {
            let id = ObjectIdentifier(obj as AnyObject)
            let handle = rightMap[id] ?? {
                currentHandle += stride
                let handle = currentHandle
                leftMap[handle] = obj
                rightMap[id] = handle
                return handle
            }()
            counter[handle] = (counter[handle] ?? 0) + 1
            return handle
        }
    }

    func get(handle: UniFFICallbackHandle) -> T? {
        lock.withLock {
            leftMap[handle]
        }
    }

    func delete(handle: UniFFICallbackHandle) {
        remove(handle: handle)
    }

    @discardableResult
    func remove(handle: UniFFICallbackHandle) -> T? {
        lock.withLock {
            defer { counter[handle] = (counter[handle] ?? 1) - 1 }
            guard counter[handle] == 1 else { return leftMap[handle] }
            let obj = leftMap.removeValue(forKey: handle)
            if let obj = obj {
                rightMap.removeValue(forKey: ObjectIdentifier(obj as AnyObject))
            }
            return obj
        }
    }
}

// Magic number for the Rust proxy to call using the same mechanism as every other method,
// to free the callback once it's dropped by Rust.
private let IDX_CALLBACK_FREE: Int32 = 0
// Callback return codes
private let UNIFFI_CALLBACK_SUCCESS: Int32 = 0
private let UNIFFI_CALLBACK_ERROR: Int32 = 1
private let UNIFFI_CALLBACK_UNEXPECTED_ERROR: Int32 = 2

// Declaration and FfiConverters for BackPaginationStatusListener Callback Interface

public protocol BackPaginationStatusListener : AnyObject {
    func onUpdate(status: BackPaginationStatus) 
    
}

// The ForeignCallback that is passed to Rust.
fileprivate let foreignCallbackCallbackInterfaceBackPaginationStatusListener : ForeignCallback =
    { (handle: UniFFICallbackHandle, method: Int32, argsData: UnsafePointer<UInt8>, argsLen: Int32, out_buf: UnsafeMutablePointer<RustBuffer>) -> Int32 in
    

    func invokeOnUpdate(_ swiftCallbackInterface: BackPaginationStatusListener, _ argsData: UnsafePointer<UInt8>, _ argsLen: Int32, _ out_buf: UnsafeMutablePointer<RustBuffer>) throws -> Int32 {
        var reader = createReader(data: Data(bytes: argsData, count: Int(argsLen)))
        func makeCall() throws -> Int32 {
            try swiftCallbackInterface.onUpdate(
                    status:  try FfiConverterTypeBackPaginationStatus.read(from: &reader)
                    )
            return UNIFFI_CALLBACK_SUCCESS
        }
        return try makeCall()
    }


    switch method {
        case IDX_CALLBACK_FREE:
            FfiConverterCallbackInterfaceBackPaginationStatusListener.drop(handle: handle)
            // Sucessful return
            // See docs of ForeignCallback in `uniffi_core/src/ffi/foreigncallbacks.rs`
            return UNIFFI_CALLBACK_SUCCESS
        case 1:
            let cb: BackPaginationStatusListener
            do {
                cb = try FfiConverterCallbackInterfaceBackPaginationStatusListener.lift(handle)
            } catch {
                out_buf.pointee = FfiConverterString.lower("BackPaginationStatusListener: Invalid handle")
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }
            do {
                return try invokeOnUpdate(cb, argsData, argsLen, out_buf)
            } catch let error {
                out_buf.pointee = FfiConverterString.lower(String(describing: error))
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }
        
        // This should never happen, because an out of bounds method index won't
        // ever be used. Once we can catch errors, we should return an InternalError.
        // https://github.com/mozilla/uniffi-rs/issues/351
        default:
            // An unexpected error happened.
            // See docs of ForeignCallback in `uniffi_core/src/ffi/foreigncallbacks.rs`
            return UNIFFI_CALLBACK_UNEXPECTED_ERROR
    }
}

// FfiConverter protocol for callback interfaces
fileprivate struct FfiConverterCallbackInterfaceBackPaginationStatusListener {
    private static let initCallbackOnce: () = {
        // Swift ensures this initializer code will once run once, even when accessed by multiple threads.
        try! rustCall { (err: UnsafeMutablePointer<RustCallStatus>) in
            uniffi_matrix_sdk_ffi_fn_init_callback_backpaginationstatuslistener(foreignCallbackCallbackInterfaceBackPaginationStatusListener, err)
        }
    }()

    private static func ensureCallbackinitialized() {
        _ = initCallbackOnce
    }

    static func drop(handle: UniFFICallbackHandle) {
        handleMap.remove(handle: handle)
    }

    private static var handleMap = UniFFICallbackHandleMap<BackPaginationStatusListener>()
}

extension FfiConverterCallbackInterfaceBackPaginationStatusListener : FfiConverter {
    typealias SwiftType = BackPaginationStatusListener
    // We can use Handle as the FfiType because it's a typealias to UInt64
    typealias FfiType = UniFFICallbackHandle

    public static func lift(_ handle: UniFFICallbackHandle) throws -> SwiftType {
        ensureCallbackinitialized();
        guard let callback = handleMap.get(handle: handle) else {
            throw UniffiInternalError.unexpectedStaleHandle
        }
        return callback
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        ensureCallbackinitialized();
        let handle: UniFFICallbackHandle = try readInt(&buf)
        return try lift(handle)
    }

    public static func lower(_ v: SwiftType) -> UniFFICallbackHandle {
        ensureCallbackinitialized();
        return handleMap.insert(obj: v)
    }

    public static func write(_ v: SwiftType, into buf: inout [UInt8]) {
        ensureCallbackinitialized();
        writeInt(&buf, lower(v))
    }
}



// Declaration and FfiConverters for ClientDelegate Callback Interface

public protocol ClientDelegate : AnyObject {
    func didReceiveAuthError(isSoftLogout: Bool) 
    func didRefreshTokens() 
    
}

// The ForeignCallback that is passed to Rust.
fileprivate let foreignCallbackCallbackInterfaceClientDelegate : ForeignCallback =
    { (handle: UniFFICallbackHandle, method: Int32, argsData: UnsafePointer<UInt8>, argsLen: Int32, out_buf: UnsafeMutablePointer<RustBuffer>) -> Int32 in
    

    func invokeDidReceiveAuthError(_ swiftCallbackInterface: ClientDelegate, _ argsData: UnsafePointer<UInt8>, _ argsLen: Int32, _ out_buf: UnsafeMutablePointer<RustBuffer>) throws -> Int32 {
        var reader = createReader(data: Data(bytes: argsData, count: Int(argsLen)))
        func makeCall() throws -> Int32 {
            try swiftCallbackInterface.didReceiveAuthError(
                    isSoftLogout:  try FfiConverterBool.read(from: &reader)
                    )
            return UNIFFI_CALLBACK_SUCCESS
        }
        return try makeCall()
    }

    func invokeDidRefreshTokens(_ swiftCallbackInterface: ClientDelegate, _ argsData: UnsafePointer<UInt8>, _ argsLen: Int32, _ out_buf: UnsafeMutablePointer<RustBuffer>) throws -> Int32 {
        func makeCall() throws -> Int32 {
            try swiftCallbackInterface.didRefreshTokens(
                    )
            return UNIFFI_CALLBACK_SUCCESS
        }
        return try makeCall()
    }


    switch method {
        case IDX_CALLBACK_FREE:
            FfiConverterCallbackInterfaceClientDelegate.drop(handle: handle)
            // Sucessful return
            // See docs of ForeignCallback in `uniffi_core/src/ffi/foreigncallbacks.rs`
            return UNIFFI_CALLBACK_SUCCESS
        case 1:
            let cb: ClientDelegate
            do {
                cb = try FfiConverterCallbackInterfaceClientDelegate.lift(handle)
            } catch {
                out_buf.pointee = FfiConverterString.lower("ClientDelegate: Invalid handle")
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }
            do {
                return try invokeDidReceiveAuthError(cb, argsData, argsLen, out_buf)
            } catch let error {
                out_buf.pointee = FfiConverterString.lower(String(describing: error))
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }
        case 2:
            let cb: ClientDelegate
            do {
                cb = try FfiConverterCallbackInterfaceClientDelegate.lift(handle)
            } catch {
                out_buf.pointee = FfiConverterString.lower("ClientDelegate: Invalid handle")
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }
            do {
                return try invokeDidRefreshTokens(cb, argsData, argsLen, out_buf)
            } catch let error {
                out_buf.pointee = FfiConverterString.lower(String(describing: error))
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }
        
        // This should never happen, because an out of bounds method index won't
        // ever be used. Once we can catch errors, we should return an InternalError.
        // https://github.com/mozilla/uniffi-rs/issues/351
        default:
            // An unexpected error happened.
            // See docs of ForeignCallback in `uniffi_core/src/ffi/foreigncallbacks.rs`
            return UNIFFI_CALLBACK_UNEXPECTED_ERROR
    }
}

// FfiConverter protocol for callback interfaces
fileprivate struct FfiConverterCallbackInterfaceClientDelegate {
    private static let initCallbackOnce: () = {
        // Swift ensures this initializer code will once run once, even when accessed by multiple threads.
        try! rustCall { (err: UnsafeMutablePointer<RustCallStatus>) in
            uniffi_matrix_sdk_ffi_fn_init_callback_clientdelegate(foreignCallbackCallbackInterfaceClientDelegate, err)
        }
    }()

    private static func ensureCallbackinitialized() {
        _ = initCallbackOnce
    }

    static func drop(handle: UniFFICallbackHandle) {
        handleMap.remove(handle: handle)
    }

    private static var handleMap = UniFFICallbackHandleMap<ClientDelegate>()
}

extension FfiConverterCallbackInterfaceClientDelegate : FfiConverter {
    typealias SwiftType = ClientDelegate
    // We can use Handle as the FfiType because it's a typealias to UInt64
    typealias FfiType = UniFFICallbackHandle

    public static func lift(_ handle: UniFFICallbackHandle) throws -> SwiftType {
        ensureCallbackinitialized();
        guard let callback = handleMap.get(handle: handle) else {
            throw UniffiInternalError.unexpectedStaleHandle
        }
        return callback
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        ensureCallbackinitialized();
        let handle: UniFFICallbackHandle = try readInt(&buf)
        return try lift(handle)
    }

    public static func lower(_ v: SwiftType) -> UniFFICallbackHandle {
        ensureCallbackinitialized();
        return handleMap.insert(obj: v)
    }

    public static func write(_ v: SwiftType, into buf: inout [UInt8]) {
        ensureCallbackinitialized();
        writeInt(&buf, lower(v))
    }
}



// Declaration and FfiConverters for NotificationSettingsDelegate Callback Interface

public protocol NotificationSettingsDelegate : AnyObject {
    func settingsDidChange() 
    
}

// The ForeignCallback that is passed to Rust.
fileprivate let foreignCallbackCallbackInterfaceNotificationSettingsDelegate : ForeignCallback =
    { (handle: UniFFICallbackHandle, method: Int32, argsData: UnsafePointer<UInt8>, argsLen: Int32, out_buf: UnsafeMutablePointer<RustBuffer>) -> Int32 in
    

    func invokeSettingsDidChange(_ swiftCallbackInterface: NotificationSettingsDelegate, _ argsData: UnsafePointer<UInt8>, _ argsLen: Int32, _ out_buf: UnsafeMutablePointer<RustBuffer>) throws -> Int32 {
        func makeCall() throws -> Int32 {
            try swiftCallbackInterface.settingsDidChange(
                    )
            return UNIFFI_CALLBACK_SUCCESS
        }
        return try makeCall()
    }


    switch method {
        case IDX_CALLBACK_FREE:
            FfiConverterCallbackInterfaceNotificationSettingsDelegate.drop(handle: handle)
            // Sucessful return
            // See docs of ForeignCallback in `uniffi_core/src/ffi/foreigncallbacks.rs`
            return UNIFFI_CALLBACK_SUCCESS
        case 1:
            let cb: NotificationSettingsDelegate
            do {
                cb = try FfiConverterCallbackInterfaceNotificationSettingsDelegate.lift(handle)
            } catch {
                out_buf.pointee = FfiConverterString.lower("NotificationSettingsDelegate: Invalid handle")
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }
            do {
                return try invokeSettingsDidChange(cb, argsData, argsLen, out_buf)
            } catch let error {
                out_buf.pointee = FfiConverterString.lower(String(describing: error))
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }
        
        // This should never happen, because an out of bounds method index won't
        // ever be used. Once we can catch errors, we should return an InternalError.
        // https://github.com/mozilla/uniffi-rs/issues/351
        default:
            // An unexpected error happened.
            // See docs of ForeignCallback in `uniffi_core/src/ffi/foreigncallbacks.rs`
            return UNIFFI_CALLBACK_UNEXPECTED_ERROR
    }
}

// FfiConverter protocol for callback interfaces
fileprivate struct FfiConverterCallbackInterfaceNotificationSettingsDelegate {
    private static let initCallbackOnce: () = {
        // Swift ensures this initializer code will once run once, even when accessed by multiple threads.
        try! rustCall { (err: UnsafeMutablePointer<RustCallStatus>) in
            uniffi_matrix_sdk_ffi_fn_init_callback_notificationsettingsdelegate(foreignCallbackCallbackInterfaceNotificationSettingsDelegate, err)
        }
    }()

    private static func ensureCallbackinitialized() {
        _ = initCallbackOnce
    }

    static func drop(handle: UniFFICallbackHandle) {
        handleMap.remove(handle: handle)
    }

    private static var handleMap = UniFFICallbackHandleMap<NotificationSettingsDelegate>()
}

extension FfiConverterCallbackInterfaceNotificationSettingsDelegate : FfiConverter {
    typealias SwiftType = NotificationSettingsDelegate
    // We can use Handle as the FfiType because it's a typealias to UInt64
    typealias FfiType = UniFFICallbackHandle

    public static func lift(_ handle: UniFFICallbackHandle) throws -> SwiftType {
        ensureCallbackinitialized();
        guard let callback = handleMap.get(handle: handle) else {
            throw UniffiInternalError.unexpectedStaleHandle
        }
        return callback
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        ensureCallbackinitialized();
        let handle: UniFFICallbackHandle = try readInt(&buf)
        return try lift(handle)
    }

    public static func lower(_ v: SwiftType) -> UniFFICallbackHandle {
        ensureCallbackinitialized();
        return handleMap.insert(obj: v)
    }

    public static func write(_ v: SwiftType, into buf: inout [UInt8]) {
        ensureCallbackinitialized();
        writeInt(&buf, lower(v))
    }
}



// Declaration and FfiConverters for ProgressWatcher Callback Interface

public protocol ProgressWatcher : AnyObject {
    func transmissionProgress(progress: TransmissionProgress) 
    
}

// The ForeignCallback that is passed to Rust.
fileprivate let foreignCallbackCallbackInterfaceProgressWatcher : ForeignCallback =
    { (handle: UniFFICallbackHandle, method: Int32, argsData: UnsafePointer<UInt8>, argsLen: Int32, out_buf: UnsafeMutablePointer<RustBuffer>) -> Int32 in
    

    func invokeTransmissionProgress(_ swiftCallbackInterface: ProgressWatcher, _ argsData: UnsafePointer<UInt8>, _ argsLen: Int32, _ out_buf: UnsafeMutablePointer<RustBuffer>) throws -> Int32 {
        var reader = createReader(data: Data(bytes: argsData, count: Int(argsLen)))
        func makeCall() throws -> Int32 {
            try swiftCallbackInterface.transmissionProgress(
                    progress:  try FfiConverterTypeTransmissionProgress.read(from: &reader)
                    )
            return UNIFFI_CALLBACK_SUCCESS
        }
        return try makeCall()
    }


    switch method {
        case IDX_CALLBACK_FREE:
            FfiConverterCallbackInterfaceProgressWatcher.drop(handle: handle)
            // Sucessful return
            // See docs of ForeignCallback in `uniffi_core/src/ffi/foreigncallbacks.rs`
            return UNIFFI_CALLBACK_SUCCESS
        case 1:
            let cb: ProgressWatcher
            do {
                cb = try FfiConverterCallbackInterfaceProgressWatcher.lift(handle)
            } catch {
                out_buf.pointee = FfiConverterString.lower("ProgressWatcher: Invalid handle")
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }
            do {
                return try invokeTransmissionProgress(cb, argsData, argsLen, out_buf)
            } catch let error {
                out_buf.pointee = FfiConverterString.lower(String(describing: error))
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }
        
        // This should never happen, because an out of bounds method index won't
        // ever be used. Once we can catch errors, we should return an InternalError.
        // https://github.com/mozilla/uniffi-rs/issues/351
        default:
            // An unexpected error happened.
            // See docs of ForeignCallback in `uniffi_core/src/ffi/foreigncallbacks.rs`
            return UNIFFI_CALLBACK_UNEXPECTED_ERROR
    }
}

// FfiConverter protocol for callback interfaces
fileprivate struct FfiConverterCallbackInterfaceProgressWatcher {
    private static let initCallbackOnce: () = {
        // Swift ensures this initializer code will once run once, even when accessed by multiple threads.
        try! rustCall { (err: UnsafeMutablePointer<RustCallStatus>) in
            uniffi_matrix_sdk_ffi_fn_init_callback_progresswatcher(foreignCallbackCallbackInterfaceProgressWatcher, err)
        }
    }()

    private static func ensureCallbackinitialized() {
        _ = initCallbackOnce
    }

    static func drop(handle: UniFFICallbackHandle) {
        handleMap.remove(handle: handle)
    }

    private static var handleMap = UniFFICallbackHandleMap<ProgressWatcher>()
}

extension FfiConverterCallbackInterfaceProgressWatcher : FfiConverter {
    typealias SwiftType = ProgressWatcher
    // We can use Handle as the FfiType because it's a typealias to UInt64
    typealias FfiType = UniFFICallbackHandle

    public static func lift(_ handle: UniFFICallbackHandle) throws -> SwiftType {
        ensureCallbackinitialized();
        guard let callback = handleMap.get(handle: handle) else {
            throw UniffiInternalError.unexpectedStaleHandle
        }
        return callback
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        ensureCallbackinitialized();
        let handle: UniFFICallbackHandle = try readInt(&buf)
        return try lift(handle)
    }

    public static func lower(_ v: SwiftType) -> UniFFICallbackHandle {
        ensureCallbackinitialized();
        return handleMap.insert(obj: v)
    }

    public static func write(_ v: SwiftType, into buf: inout [UInt8]) {
        ensureCallbackinitialized();
        writeInt(&buf, lower(v))
    }
}



// Declaration and FfiConverters for RoomInfoListener Callback Interface

public protocol RoomInfoListener : AnyObject {
    func call(roomInfo: RoomInfo) 
    
}

// The ForeignCallback that is passed to Rust.
fileprivate let foreignCallbackCallbackInterfaceRoomInfoListener : ForeignCallback =
    { (handle: UniFFICallbackHandle, method: Int32, argsData: UnsafePointer<UInt8>, argsLen: Int32, out_buf: UnsafeMutablePointer<RustBuffer>) -> Int32 in
    

    func invokeCall(_ swiftCallbackInterface: RoomInfoListener, _ argsData: UnsafePointer<UInt8>, _ argsLen: Int32, _ out_buf: UnsafeMutablePointer<RustBuffer>) throws -> Int32 {
        var reader = createReader(data: Data(bytes: argsData, count: Int(argsLen)))
        func makeCall() throws -> Int32 {
            try swiftCallbackInterface.call(
                    roomInfo:  try FfiConverterTypeRoomInfo.read(from: &reader)
                    )
            return UNIFFI_CALLBACK_SUCCESS
        }
        return try makeCall()
    }


    switch method {
        case IDX_CALLBACK_FREE:
            FfiConverterCallbackInterfaceRoomInfoListener.drop(handle: handle)
            // Sucessful return
            // See docs of ForeignCallback in `uniffi_core/src/ffi/foreigncallbacks.rs`
            return UNIFFI_CALLBACK_SUCCESS
        case 1:
            let cb: RoomInfoListener
            do {
                cb = try FfiConverterCallbackInterfaceRoomInfoListener.lift(handle)
            } catch {
                out_buf.pointee = FfiConverterString.lower("RoomInfoListener: Invalid handle")
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }
            do {
                return try invokeCall(cb, argsData, argsLen, out_buf)
            } catch let error {
                out_buf.pointee = FfiConverterString.lower(String(describing: error))
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }
        
        // This should never happen, because an out of bounds method index won't
        // ever be used. Once we can catch errors, we should return an InternalError.
        // https://github.com/mozilla/uniffi-rs/issues/351
        default:
            // An unexpected error happened.
            // See docs of ForeignCallback in `uniffi_core/src/ffi/foreigncallbacks.rs`
            return UNIFFI_CALLBACK_UNEXPECTED_ERROR
    }
}

// FfiConverter protocol for callback interfaces
fileprivate struct FfiConverterCallbackInterfaceRoomInfoListener {
    private static let initCallbackOnce: () = {
        // Swift ensures this initializer code will once run once, even when accessed by multiple threads.
        try! rustCall { (err: UnsafeMutablePointer<RustCallStatus>) in
            uniffi_matrix_sdk_ffi_fn_init_callback_roominfolistener(foreignCallbackCallbackInterfaceRoomInfoListener, err)
        }
    }()

    private static func ensureCallbackinitialized() {
        _ = initCallbackOnce
    }

    static func drop(handle: UniFFICallbackHandle) {
        handleMap.remove(handle: handle)
    }

    private static var handleMap = UniFFICallbackHandleMap<RoomInfoListener>()
}

extension FfiConverterCallbackInterfaceRoomInfoListener : FfiConverter {
    typealias SwiftType = RoomInfoListener
    // We can use Handle as the FfiType because it's a typealias to UInt64
    typealias FfiType = UniFFICallbackHandle

    public static func lift(_ handle: UniFFICallbackHandle) throws -> SwiftType {
        ensureCallbackinitialized();
        guard let callback = handleMap.get(handle: handle) else {
            throw UniffiInternalError.unexpectedStaleHandle
        }
        return callback
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        ensureCallbackinitialized();
        let handle: UniFFICallbackHandle = try readInt(&buf)
        return try lift(handle)
    }

    public static func lower(_ v: SwiftType) -> UniFFICallbackHandle {
        ensureCallbackinitialized();
        return handleMap.insert(obj: v)
    }

    public static func write(_ v: SwiftType, into buf: inout [UInt8]) {
        ensureCallbackinitialized();
        writeInt(&buf, lower(v))
    }
}



// Declaration and FfiConverters for RoomListEntriesListener Callback Interface

public protocol RoomListEntriesListener : AnyObject {
    func onUpdate(roomEntriesUpdate: [RoomListEntriesUpdate]) 
    
}

// The ForeignCallback that is passed to Rust.
fileprivate let foreignCallbackCallbackInterfaceRoomListEntriesListener : ForeignCallback =
    { (handle: UniFFICallbackHandle, method: Int32, argsData: UnsafePointer<UInt8>, argsLen: Int32, out_buf: UnsafeMutablePointer<RustBuffer>) -> Int32 in
    

    func invokeOnUpdate(_ swiftCallbackInterface: RoomListEntriesListener, _ argsData: UnsafePointer<UInt8>, _ argsLen: Int32, _ out_buf: UnsafeMutablePointer<RustBuffer>) throws -> Int32 {
        var reader = createReader(data: Data(bytes: argsData, count: Int(argsLen)))
        func makeCall() throws -> Int32 {
            try swiftCallbackInterface.onUpdate(
                    roomEntriesUpdate:  try FfiConverterSequenceTypeRoomListEntriesUpdate.read(from: &reader)
                    )
            return UNIFFI_CALLBACK_SUCCESS
        }
        return try makeCall()
    }


    switch method {
        case IDX_CALLBACK_FREE:
            FfiConverterCallbackInterfaceRoomListEntriesListener.drop(handle: handle)
            // Sucessful return
            // See docs of ForeignCallback in `uniffi_core/src/ffi/foreigncallbacks.rs`
            return UNIFFI_CALLBACK_SUCCESS
        case 1:
            let cb: RoomListEntriesListener
            do {
                cb = try FfiConverterCallbackInterfaceRoomListEntriesListener.lift(handle)
            } catch {
                out_buf.pointee = FfiConverterString.lower("RoomListEntriesListener: Invalid handle")
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }
            do {
                return try invokeOnUpdate(cb, argsData, argsLen, out_buf)
            } catch let error {
                out_buf.pointee = FfiConverterString.lower(String(describing: error))
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }
        
        // This should never happen, because an out of bounds method index won't
        // ever be used. Once we can catch errors, we should return an InternalError.
        // https://github.com/mozilla/uniffi-rs/issues/351
        default:
            // An unexpected error happened.
            // See docs of ForeignCallback in `uniffi_core/src/ffi/foreigncallbacks.rs`
            return UNIFFI_CALLBACK_UNEXPECTED_ERROR
    }
}

// FfiConverter protocol for callback interfaces
fileprivate struct FfiConverterCallbackInterfaceRoomListEntriesListener {
    private static let initCallbackOnce: () = {
        // Swift ensures this initializer code will once run once, even when accessed by multiple threads.
        try! rustCall { (err: UnsafeMutablePointer<RustCallStatus>) in
            uniffi_matrix_sdk_ffi_fn_init_callback_roomlistentrieslistener(foreignCallbackCallbackInterfaceRoomListEntriesListener, err)
        }
    }()

    private static func ensureCallbackinitialized() {
        _ = initCallbackOnce
    }

    static func drop(handle: UniFFICallbackHandle) {
        handleMap.remove(handle: handle)
    }

    private static var handleMap = UniFFICallbackHandleMap<RoomListEntriesListener>()
}

extension FfiConverterCallbackInterfaceRoomListEntriesListener : FfiConverter {
    typealias SwiftType = RoomListEntriesListener
    // We can use Handle as the FfiType because it's a typealias to UInt64
    typealias FfiType = UniFFICallbackHandle

    public static func lift(_ handle: UniFFICallbackHandle) throws -> SwiftType {
        ensureCallbackinitialized();
        guard let callback = handleMap.get(handle: handle) else {
            throw UniffiInternalError.unexpectedStaleHandle
        }
        return callback
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        ensureCallbackinitialized();
        let handle: UniFFICallbackHandle = try readInt(&buf)
        return try lift(handle)
    }

    public static func lower(_ v: SwiftType) -> UniFFICallbackHandle {
        ensureCallbackinitialized();
        return handleMap.insert(obj: v)
    }

    public static func write(_ v: SwiftType, into buf: inout [UInt8]) {
        ensureCallbackinitialized();
        writeInt(&buf, lower(v))
    }
}



// Declaration and FfiConverters for RoomListLoadingStateListener Callback Interface

public protocol RoomListLoadingStateListener : AnyObject {
    func onUpdate(state: RoomListLoadingState) 
    
}

// The ForeignCallback that is passed to Rust.
fileprivate let foreignCallbackCallbackInterfaceRoomListLoadingStateListener : ForeignCallback =
    { (handle: UniFFICallbackHandle, method: Int32, argsData: UnsafePointer<UInt8>, argsLen: Int32, out_buf: UnsafeMutablePointer<RustBuffer>) -> Int32 in
    

    func invokeOnUpdate(_ swiftCallbackInterface: RoomListLoadingStateListener, _ argsData: UnsafePointer<UInt8>, _ argsLen: Int32, _ out_buf: UnsafeMutablePointer<RustBuffer>) throws -> Int32 {
        var reader = createReader(data: Data(bytes: argsData, count: Int(argsLen)))
        func makeCall() throws -> Int32 {
            try swiftCallbackInterface.onUpdate(
                    state:  try FfiConverterTypeRoomListLoadingState.read(from: &reader)
                    )
            return UNIFFI_CALLBACK_SUCCESS
        }
        return try makeCall()
    }


    switch method {
        case IDX_CALLBACK_FREE:
            FfiConverterCallbackInterfaceRoomListLoadingStateListener.drop(handle: handle)
            // Sucessful return
            // See docs of ForeignCallback in `uniffi_core/src/ffi/foreigncallbacks.rs`
            return UNIFFI_CALLBACK_SUCCESS
        case 1:
            let cb: RoomListLoadingStateListener
            do {
                cb = try FfiConverterCallbackInterfaceRoomListLoadingStateListener.lift(handle)
            } catch {
                out_buf.pointee = FfiConverterString.lower("RoomListLoadingStateListener: Invalid handle")
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }
            do {
                return try invokeOnUpdate(cb, argsData, argsLen, out_buf)
            } catch let error {
                out_buf.pointee = FfiConverterString.lower(String(describing: error))
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }
        
        // This should never happen, because an out of bounds method index won't
        // ever be used. Once we can catch errors, we should return an InternalError.
        // https://github.com/mozilla/uniffi-rs/issues/351
        default:
            // An unexpected error happened.
            // See docs of ForeignCallback in `uniffi_core/src/ffi/foreigncallbacks.rs`
            return UNIFFI_CALLBACK_UNEXPECTED_ERROR
    }
}

// FfiConverter protocol for callback interfaces
fileprivate struct FfiConverterCallbackInterfaceRoomListLoadingStateListener {
    private static let initCallbackOnce: () = {
        // Swift ensures this initializer code will once run once, even when accessed by multiple threads.
        try! rustCall { (err: UnsafeMutablePointer<RustCallStatus>) in
            uniffi_matrix_sdk_ffi_fn_init_callback_roomlistloadingstatelistener(foreignCallbackCallbackInterfaceRoomListLoadingStateListener, err)
        }
    }()

    private static func ensureCallbackinitialized() {
        _ = initCallbackOnce
    }

    static func drop(handle: UniFFICallbackHandle) {
        handleMap.remove(handle: handle)
    }

    private static var handleMap = UniFFICallbackHandleMap<RoomListLoadingStateListener>()
}

extension FfiConverterCallbackInterfaceRoomListLoadingStateListener : FfiConverter {
    typealias SwiftType = RoomListLoadingStateListener
    // We can use Handle as the FfiType because it's a typealias to UInt64
    typealias FfiType = UniFFICallbackHandle

    public static func lift(_ handle: UniFFICallbackHandle) throws -> SwiftType {
        ensureCallbackinitialized();
        guard let callback = handleMap.get(handle: handle) else {
            throw UniffiInternalError.unexpectedStaleHandle
        }
        return callback
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        ensureCallbackinitialized();
        let handle: UniFFICallbackHandle = try readInt(&buf)
        return try lift(handle)
    }

    public static func lower(_ v: SwiftType) -> UniFFICallbackHandle {
        ensureCallbackinitialized();
        return handleMap.insert(obj: v)
    }

    public static func write(_ v: SwiftType, into buf: inout [UInt8]) {
        ensureCallbackinitialized();
        writeInt(&buf, lower(v))
    }
}



// Declaration and FfiConverters for RoomListServiceStateListener Callback Interface

public protocol RoomListServiceStateListener : AnyObject {
    func onUpdate(state: RoomListServiceState) 
    
}

// The ForeignCallback that is passed to Rust.
fileprivate let foreignCallbackCallbackInterfaceRoomListServiceStateListener : ForeignCallback =
    { (handle: UniFFICallbackHandle, method: Int32, argsData: UnsafePointer<UInt8>, argsLen: Int32, out_buf: UnsafeMutablePointer<RustBuffer>) -> Int32 in
    

    func invokeOnUpdate(_ swiftCallbackInterface: RoomListServiceStateListener, _ argsData: UnsafePointer<UInt8>, _ argsLen: Int32, _ out_buf: UnsafeMutablePointer<RustBuffer>) throws -> Int32 {
        var reader = createReader(data: Data(bytes: argsData, count: Int(argsLen)))
        func makeCall() throws -> Int32 {
            try swiftCallbackInterface.onUpdate(
                    state:  try FfiConverterTypeRoomListServiceState.read(from: &reader)
                    )
            return UNIFFI_CALLBACK_SUCCESS
        }
        return try makeCall()
    }


    switch method {
        case IDX_CALLBACK_FREE:
            FfiConverterCallbackInterfaceRoomListServiceStateListener.drop(handle: handle)
            // Sucessful return
            // See docs of ForeignCallback in `uniffi_core/src/ffi/foreigncallbacks.rs`
            return UNIFFI_CALLBACK_SUCCESS
        case 1:
            let cb: RoomListServiceStateListener
            do {
                cb = try FfiConverterCallbackInterfaceRoomListServiceStateListener.lift(handle)
            } catch {
                out_buf.pointee = FfiConverterString.lower("RoomListServiceStateListener: Invalid handle")
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }
            do {
                return try invokeOnUpdate(cb, argsData, argsLen, out_buf)
            } catch let error {
                out_buf.pointee = FfiConverterString.lower(String(describing: error))
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }
        
        // This should never happen, because an out of bounds method index won't
        // ever be used. Once we can catch errors, we should return an InternalError.
        // https://github.com/mozilla/uniffi-rs/issues/351
        default:
            // An unexpected error happened.
            // See docs of ForeignCallback in `uniffi_core/src/ffi/foreigncallbacks.rs`
            return UNIFFI_CALLBACK_UNEXPECTED_ERROR
    }
}

// FfiConverter protocol for callback interfaces
fileprivate struct FfiConverterCallbackInterfaceRoomListServiceStateListener {
    private static let initCallbackOnce: () = {
        // Swift ensures this initializer code will once run once, even when accessed by multiple threads.
        try! rustCall { (err: UnsafeMutablePointer<RustCallStatus>) in
            uniffi_matrix_sdk_ffi_fn_init_callback_roomlistservicestatelistener(foreignCallbackCallbackInterfaceRoomListServiceStateListener, err)
        }
    }()

    private static func ensureCallbackinitialized() {
        _ = initCallbackOnce
    }

    static func drop(handle: UniFFICallbackHandle) {
        handleMap.remove(handle: handle)
    }

    private static var handleMap = UniFFICallbackHandleMap<RoomListServiceStateListener>()
}

extension FfiConverterCallbackInterfaceRoomListServiceStateListener : FfiConverter {
    typealias SwiftType = RoomListServiceStateListener
    // We can use Handle as the FfiType because it's a typealias to UInt64
    typealias FfiType = UniFFICallbackHandle

    public static func lift(_ handle: UniFFICallbackHandle) throws -> SwiftType {
        ensureCallbackinitialized();
        guard let callback = handleMap.get(handle: handle) else {
            throw UniffiInternalError.unexpectedStaleHandle
        }
        return callback
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        ensureCallbackinitialized();
        let handle: UniFFICallbackHandle = try readInt(&buf)
        return try lift(handle)
    }

    public static func lower(_ v: SwiftType) -> UniFFICallbackHandle {
        ensureCallbackinitialized();
        return handleMap.insert(obj: v)
    }

    public static func write(_ v: SwiftType, into buf: inout [UInt8]) {
        ensureCallbackinitialized();
        writeInt(&buf, lower(v))
    }
}



// Declaration and FfiConverters for SessionVerificationControllerDelegate Callback Interface

public protocol SessionVerificationControllerDelegate : AnyObject {
    func didAcceptVerificationRequest() 
    func didStartSasVerification() 
    func didReceiveVerificationData(data: [SessionVerificationEmoji]) 
    func didFail() 
    func didCancel() 
    func didFinish() 
    
}

// The ForeignCallback that is passed to Rust.
fileprivate let foreignCallbackCallbackInterfaceSessionVerificationControllerDelegate : ForeignCallback =
    { (handle: UniFFICallbackHandle, method: Int32, argsData: UnsafePointer<UInt8>, argsLen: Int32, out_buf: UnsafeMutablePointer<RustBuffer>) -> Int32 in
    

    func invokeDidAcceptVerificationRequest(_ swiftCallbackInterface: SessionVerificationControllerDelegate, _ argsData: UnsafePointer<UInt8>, _ argsLen: Int32, _ out_buf: UnsafeMutablePointer<RustBuffer>) throws -> Int32 {
        func makeCall() throws -> Int32 {
            try swiftCallbackInterface.didAcceptVerificationRequest(
                    )
            return UNIFFI_CALLBACK_SUCCESS
        }
        return try makeCall()
    }

    func invokeDidStartSasVerification(_ swiftCallbackInterface: SessionVerificationControllerDelegate, _ argsData: UnsafePointer<UInt8>, _ argsLen: Int32, _ out_buf: UnsafeMutablePointer<RustBuffer>) throws -> Int32 {
        func makeCall() throws -> Int32 {
            try swiftCallbackInterface.didStartSasVerification(
                    )
            return UNIFFI_CALLBACK_SUCCESS
        }
        return try makeCall()
    }

    func invokeDidReceiveVerificationData(_ swiftCallbackInterface: SessionVerificationControllerDelegate, _ argsData: UnsafePointer<UInt8>, _ argsLen: Int32, _ out_buf: UnsafeMutablePointer<RustBuffer>) throws -> Int32 {
        var reader = createReader(data: Data(bytes: argsData, count: Int(argsLen)))
        func makeCall() throws -> Int32 {
            try swiftCallbackInterface.didReceiveVerificationData(
                    data:  try FfiConverterSequenceTypeSessionVerificationEmoji.read(from: &reader)
                    )
            return UNIFFI_CALLBACK_SUCCESS
        }
        return try makeCall()
    }

    func invokeDidFail(_ swiftCallbackInterface: SessionVerificationControllerDelegate, _ argsData: UnsafePointer<UInt8>, _ argsLen: Int32, _ out_buf: UnsafeMutablePointer<RustBuffer>) throws -> Int32 {
        func makeCall() throws -> Int32 {
            try swiftCallbackInterface.didFail(
                    )
            return UNIFFI_CALLBACK_SUCCESS
        }
        return try makeCall()
    }

    func invokeDidCancel(_ swiftCallbackInterface: SessionVerificationControllerDelegate, _ argsData: UnsafePointer<UInt8>, _ argsLen: Int32, _ out_buf: UnsafeMutablePointer<RustBuffer>) throws -> Int32 {
        func makeCall() throws -> Int32 {
            try swiftCallbackInterface.didCancel(
                    )
            return UNIFFI_CALLBACK_SUCCESS
        }
        return try makeCall()
    }

    func invokeDidFinish(_ swiftCallbackInterface: SessionVerificationControllerDelegate, _ argsData: UnsafePointer<UInt8>, _ argsLen: Int32, _ out_buf: UnsafeMutablePointer<RustBuffer>) throws -> Int32 {
        func makeCall() throws -> Int32 {
            try swiftCallbackInterface.didFinish(
                    )
            return UNIFFI_CALLBACK_SUCCESS
        }
        return try makeCall()
    }


    switch method {
        case IDX_CALLBACK_FREE:
            FfiConverterCallbackInterfaceSessionVerificationControllerDelegate.drop(handle: handle)
            // Sucessful return
            // See docs of ForeignCallback in `uniffi_core/src/ffi/foreigncallbacks.rs`
            return UNIFFI_CALLBACK_SUCCESS
        case 1:
            let cb: SessionVerificationControllerDelegate
            do {
                cb = try FfiConverterCallbackInterfaceSessionVerificationControllerDelegate.lift(handle)
            } catch {
                out_buf.pointee = FfiConverterString.lower("SessionVerificationControllerDelegate: Invalid handle")
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }
            do {
                return try invokeDidAcceptVerificationRequest(cb, argsData, argsLen, out_buf)
            } catch let error {
                out_buf.pointee = FfiConverterString.lower(String(describing: error))
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }
        case 2:
            let cb: SessionVerificationControllerDelegate
            do {
                cb = try FfiConverterCallbackInterfaceSessionVerificationControllerDelegate.lift(handle)
            } catch {
                out_buf.pointee = FfiConverterString.lower("SessionVerificationControllerDelegate: Invalid handle")
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }
            do {
                return try invokeDidStartSasVerification(cb, argsData, argsLen, out_buf)
            } catch let error {
                out_buf.pointee = FfiConverterString.lower(String(describing: error))
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }
        case 3:
            let cb: SessionVerificationControllerDelegate
            do {
                cb = try FfiConverterCallbackInterfaceSessionVerificationControllerDelegate.lift(handle)
            } catch {
                out_buf.pointee = FfiConverterString.lower("SessionVerificationControllerDelegate: Invalid handle")
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }
            do {
                return try invokeDidReceiveVerificationData(cb, argsData, argsLen, out_buf)
            } catch let error {
                out_buf.pointee = FfiConverterString.lower(String(describing: error))
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }
        case 4:
            let cb: SessionVerificationControllerDelegate
            do {
                cb = try FfiConverterCallbackInterfaceSessionVerificationControllerDelegate.lift(handle)
            } catch {
                out_buf.pointee = FfiConverterString.lower("SessionVerificationControllerDelegate: Invalid handle")
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }
            do {
                return try invokeDidFail(cb, argsData, argsLen, out_buf)
            } catch let error {
                out_buf.pointee = FfiConverterString.lower(String(describing: error))
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }
        case 5:
            let cb: SessionVerificationControllerDelegate
            do {
                cb = try FfiConverterCallbackInterfaceSessionVerificationControllerDelegate.lift(handle)
            } catch {
                out_buf.pointee = FfiConverterString.lower("SessionVerificationControllerDelegate: Invalid handle")
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }
            do {
                return try invokeDidCancel(cb, argsData, argsLen, out_buf)
            } catch let error {
                out_buf.pointee = FfiConverterString.lower(String(describing: error))
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }
        case 6:
            let cb: SessionVerificationControllerDelegate
            do {
                cb = try FfiConverterCallbackInterfaceSessionVerificationControllerDelegate.lift(handle)
            } catch {
                out_buf.pointee = FfiConverterString.lower("SessionVerificationControllerDelegate: Invalid handle")
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }
            do {
                return try invokeDidFinish(cb, argsData, argsLen, out_buf)
            } catch let error {
                out_buf.pointee = FfiConverterString.lower(String(describing: error))
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }
        
        // This should never happen, because an out of bounds method index won't
        // ever be used. Once we can catch errors, we should return an InternalError.
        // https://github.com/mozilla/uniffi-rs/issues/351
        default:
            // An unexpected error happened.
            // See docs of ForeignCallback in `uniffi_core/src/ffi/foreigncallbacks.rs`
            return UNIFFI_CALLBACK_UNEXPECTED_ERROR
    }
}

// FfiConverter protocol for callback interfaces
fileprivate struct FfiConverterCallbackInterfaceSessionVerificationControllerDelegate {
    private static let initCallbackOnce: () = {
        // Swift ensures this initializer code will once run once, even when accessed by multiple threads.
        try! rustCall { (err: UnsafeMutablePointer<RustCallStatus>) in
            uniffi_matrix_sdk_ffi_fn_init_callback_sessionverificationcontrollerdelegate(foreignCallbackCallbackInterfaceSessionVerificationControllerDelegate, err)
        }
    }()

    private static func ensureCallbackinitialized() {
        _ = initCallbackOnce
    }

    static func drop(handle: UniFFICallbackHandle) {
        handleMap.remove(handle: handle)
    }

    private static var handleMap = UniFFICallbackHandleMap<SessionVerificationControllerDelegate>()
}

extension FfiConverterCallbackInterfaceSessionVerificationControllerDelegate : FfiConverter {
    typealias SwiftType = SessionVerificationControllerDelegate
    // We can use Handle as the FfiType because it's a typealias to UInt64
    typealias FfiType = UniFFICallbackHandle

    public static func lift(_ handle: UniFFICallbackHandle) throws -> SwiftType {
        ensureCallbackinitialized();
        guard let callback = handleMap.get(handle: handle) else {
            throw UniffiInternalError.unexpectedStaleHandle
        }
        return callback
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        ensureCallbackinitialized();
        let handle: UniFFICallbackHandle = try readInt(&buf)
        return try lift(handle)
    }

    public static func lower(_ v: SwiftType) -> UniFFICallbackHandle {
        ensureCallbackinitialized();
        return handleMap.insert(obj: v)
    }

    public static func write(_ v: SwiftType, into buf: inout [UInt8]) {
        ensureCallbackinitialized();
        writeInt(&buf, lower(v))
    }
}



// Declaration and FfiConverters for SyncServiceStateObserver Callback Interface

public protocol SyncServiceStateObserver : AnyObject {
    func onUpdate(state: SyncServiceState) 
    
}

// The ForeignCallback that is passed to Rust.
fileprivate let foreignCallbackCallbackInterfaceSyncServiceStateObserver : ForeignCallback =
    { (handle: UniFFICallbackHandle, method: Int32, argsData: UnsafePointer<UInt8>, argsLen: Int32, out_buf: UnsafeMutablePointer<RustBuffer>) -> Int32 in
    

    func invokeOnUpdate(_ swiftCallbackInterface: SyncServiceStateObserver, _ argsData: UnsafePointer<UInt8>, _ argsLen: Int32, _ out_buf: UnsafeMutablePointer<RustBuffer>) throws -> Int32 {
        var reader = createReader(data: Data(bytes: argsData, count: Int(argsLen)))
        func makeCall() throws -> Int32 {
            try swiftCallbackInterface.onUpdate(
                    state:  try FfiConverterTypeSyncServiceState.read(from: &reader)
                    )
            return UNIFFI_CALLBACK_SUCCESS
        }
        return try makeCall()
    }


    switch method {
        case IDX_CALLBACK_FREE:
            FfiConverterCallbackInterfaceSyncServiceStateObserver.drop(handle: handle)
            // Sucessful return
            // See docs of ForeignCallback in `uniffi_core/src/ffi/foreigncallbacks.rs`
            return UNIFFI_CALLBACK_SUCCESS
        case 1:
            let cb: SyncServiceStateObserver
            do {
                cb = try FfiConverterCallbackInterfaceSyncServiceStateObserver.lift(handle)
            } catch {
                out_buf.pointee = FfiConverterString.lower("SyncServiceStateObserver: Invalid handle")
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }
            do {
                return try invokeOnUpdate(cb, argsData, argsLen, out_buf)
            } catch let error {
                out_buf.pointee = FfiConverterString.lower(String(describing: error))
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }
        
        // This should never happen, because an out of bounds method index won't
        // ever be used. Once we can catch errors, we should return an InternalError.
        // https://github.com/mozilla/uniffi-rs/issues/351
        default:
            // An unexpected error happened.
            // See docs of ForeignCallback in `uniffi_core/src/ffi/foreigncallbacks.rs`
            return UNIFFI_CALLBACK_UNEXPECTED_ERROR
    }
}

// FfiConverter protocol for callback interfaces
fileprivate struct FfiConverterCallbackInterfaceSyncServiceStateObserver {
    private static let initCallbackOnce: () = {
        // Swift ensures this initializer code will once run once, even when accessed by multiple threads.
        try! rustCall { (err: UnsafeMutablePointer<RustCallStatus>) in
            uniffi_matrix_sdk_ffi_fn_init_callback_syncservicestateobserver(foreignCallbackCallbackInterfaceSyncServiceStateObserver, err)
        }
    }()

    private static func ensureCallbackinitialized() {
        _ = initCallbackOnce
    }

    static func drop(handle: UniFFICallbackHandle) {
        handleMap.remove(handle: handle)
    }

    private static var handleMap = UniFFICallbackHandleMap<SyncServiceStateObserver>()
}

extension FfiConverterCallbackInterfaceSyncServiceStateObserver : FfiConverter {
    typealias SwiftType = SyncServiceStateObserver
    // We can use Handle as the FfiType because it's a typealias to UInt64
    typealias FfiType = UniFFICallbackHandle

    public static func lift(_ handle: UniFFICallbackHandle) throws -> SwiftType {
        ensureCallbackinitialized();
        guard let callback = handleMap.get(handle: handle) else {
            throw UniffiInternalError.unexpectedStaleHandle
        }
        return callback
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        ensureCallbackinitialized();
        let handle: UniFFICallbackHandle = try readInt(&buf)
        return try lift(handle)
    }

    public static func lower(_ v: SwiftType) -> UniFFICallbackHandle {
        ensureCallbackinitialized();
        return handleMap.insert(obj: v)
    }

    public static func write(_ v: SwiftType, into buf: inout [UInt8]) {
        ensureCallbackinitialized();
        writeInt(&buf, lower(v))
    }
}



// Declaration and FfiConverters for TimelineListener Callback Interface

public protocol TimelineListener : AnyObject {
    func onUpdate(diff: [TimelineDiff]) 
    
}

// The ForeignCallback that is passed to Rust.
fileprivate let foreignCallbackCallbackInterfaceTimelineListener : ForeignCallback =
    { (handle: UniFFICallbackHandle, method: Int32, argsData: UnsafePointer<UInt8>, argsLen: Int32, out_buf: UnsafeMutablePointer<RustBuffer>) -> Int32 in
    

    func invokeOnUpdate(_ swiftCallbackInterface: TimelineListener, _ argsData: UnsafePointer<UInt8>, _ argsLen: Int32, _ out_buf: UnsafeMutablePointer<RustBuffer>) throws -> Int32 {
        var reader = createReader(data: Data(bytes: argsData, count: Int(argsLen)))
        func makeCall() throws -> Int32 {
            try swiftCallbackInterface.onUpdate(
                    diff:  try FfiConverterSequenceTypeTimelineDiff.read(from: &reader)
                    )
            return UNIFFI_CALLBACK_SUCCESS
        }
        return try makeCall()
    }


    switch method {
        case IDX_CALLBACK_FREE:
            FfiConverterCallbackInterfaceTimelineListener.drop(handle: handle)
            // Sucessful return
            // See docs of ForeignCallback in `uniffi_core/src/ffi/foreigncallbacks.rs`
            return UNIFFI_CALLBACK_SUCCESS
        case 1:
            let cb: TimelineListener
            do {
                cb = try FfiConverterCallbackInterfaceTimelineListener.lift(handle)
            } catch {
                out_buf.pointee = FfiConverterString.lower("TimelineListener: Invalid handle")
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }
            do {
                return try invokeOnUpdate(cb, argsData, argsLen, out_buf)
            } catch let error {
                out_buf.pointee = FfiConverterString.lower(String(describing: error))
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }
        
        // This should never happen, because an out of bounds method index won't
        // ever be used. Once we can catch errors, we should return an InternalError.
        // https://github.com/mozilla/uniffi-rs/issues/351
        default:
            // An unexpected error happened.
            // See docs of ForeignCallback in `uniffi_core/src/ffi/foreigncallbacks.rs`
            return UNIFFI_CALLBACK_UNEXPECTED_ERROR
    }
}

// FfiConverter protocol for callback interfaces
fileprivate struct FfiConverterCallbackInterfaceTimelineListener {
    private static let initCallbackOnce: () = {
        // Swift ensures this initializer code will once run once, even when accessed by multiple threads.
        try! rustCall { (err: UnsafeMutablePointer<RustCallStatus>) in
            uniffi_matrix_sdk_ffi_fn_init_callback_timelinelistener(foreignCallbackCallbackInterfaceTimelineListener, err)
        }
    }()

    private static func ensureCallbackinitialized() {
        _ = initCallbackOnce
    }

    static func drop(handle: UniFFICallbackHandle) {
        handleMap.remove(handle: handle)
    }

    private static var handleMap = UniFFICallbackHandleMap<TimelineListener>()
}

extension FfiConverterCallbackInterfaceTimelineListener : FfiConverter {
    typealias SwiftType = TimelineListener
    // We can use Handle as the FfiType because it's a typealias to UInt64
    typealias FfiType = UniFFICallbackHandle

    public static func lift(_ handle: UniFFICallbackHandle) throws -> SwiftType {
        ensureCallbackinitialized();
        guard let callback = handleMap.get(handle: handle) else {
            throw UniffiInternalError.unexpectedStaleHandle
        }
        return callback
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        ensureCallbackinitialized();
        let handle: UniFFICallbackHandle = try readInt(&buf)
        return try lift(handle)
    }

    public static func lower(_ v: SwiftType) -> UniFFICallbackHandle {
        ensureCallbackinitialized();
        return handleMap.insert(obj: v)
    }

    public static func write(_ v: SwiftType, into buf: inout [UInt8]) {
        ensureCallbackinitialized();
        writeInt(&buf, lower(v))
    }
}



// Declaration and FfiConverters for WidgetPermissionsProvider Callback Interface

public protocol WidgetPermissionsProvider : AnyObject {
    func acquirePermissions(permissions: WidgetPermissions)  -> WidgetPermissions
    
}

// The ForeignCallback that is passed to Rust.
fileprivate let foreignCallbackCallbackInterfaceWidgetPermissionsProvider : ForeignCallback =
    { (handle: UniFFICallbackHandle, method: Int32, argsData: UnsafePointer<UInt8>, argsLen: Int32, out_buf: UnsafeMutablePointer<RustBuffer>) -> Int32 in
    

    func invokeAcquirePermissions(_ swiftCallbackInterface: WidgetPermissionsProvider, _ argsData: UnsafePointer<UInt8>, _ argsLen: Int32, _ out_buf: UnsafeMutablePointer<RustBuffer>) throws -> Int32 {
        var reader = createReader(data: Data(bytes: argsData, count: Int(argsLen)))
        func makeCall() throws -> Int32 {
            let result =  swiftCallbackInterface.acquirePermissions(
                    permissions:  try FfiConverterTypeWidgetPermissions.read(from: &reader)
                    )
            var writer = [UInt8]()
            FfiConverterTypeWidgetPermissions.write(result, into: &writer)
            out_buf.pointee = RustBuffer(bytes: writer)
            return UNIFFI_CALLBACK_SUCCESS
        }
        return try makeCall()
    }


    switch method {
        case IDX_CALLBACK_FREE:
            FfiConverterCallbackInterfaceWidgetPermissionsProvider.drop(handle: handle)
            // Sucessful return
            // See docs of ForeignCallback in `uniffi_core/src/ffi/foreigncallbacks.rs`
            return UNIFFI_CALLBACK_SUCCESS
        case 1:
            let cb: WidgetPermissionsProvider
            do {
                cb = try FfiConverterCallbackInterfaceWidgetPermissionsProvider.lift(handle)
            } catch {
                out_buf.pointee = FfiConverterString.lower("WidgetPermissionsProvider: Invalid handle")
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }
            do {
                return try invokeAcquirePermissions(cb, argsData, argsLen, out_buf)
            } catch let error {
                out_buf.pointee = FfiConverterString.lower(String(describing: error))
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }
        
        // This should never happen, because an out of bounds method index won't
        // ever be used. Once we can catch errors, we should return an InternalError.
        // https://github.com/mozilla/uniffi-rs/issues/351
        default:
            // An unexpected error happened.
            // See docs of ForeignCallback in `uniffi_core/src/ffi/foreigncallbacks.rs`
            return UNIFFI_CALLBACK_UNEXPECTED_ERROR
    }
}

// FfiConverter protocol for callback interfaces
fileprivate struct FfiConverterCallbackInterfaceWidgetPermissionsProvider {
    private static let initCallbackOnce: () = {
        // Swift ensures this initializer code will once run once, even when accessed by multiple threads.
        try! rustCall { (err: UnsafeMutablePointer<RustCallStatus>) in
            uniffi_matrix_sdk_ffi_fn_init_callback_widgetpermissionsprovider(foreignCallbackCallbackInterfaceWidgetPermissionsProvider, err)
        }
    }()

    private static func ensureCallbackinitialized() {
        _ = initCallbackOnce
    }

    static func drop(handle: UniFFICallbackHandle) {
        handleMap.remove(handle: handle)
    }

    private static var handleMap = UniFFICallbackHandleMap<WidgetPermissionsProvider>()
}

extension FfiConverterCallbackInterfaceWidgetPermissionsProvider : FfiConverter {
    typealias SwiftType = WidgetPermissionsProvider
    // We can use Handle as the FfiType because it's a typealias to UInt64
    typealias FfiType = UniFFICallbackHandle

    public static func lift(_ handle: UniFFICallbackHandle) throws -> SwiftType {
        ensureCallbackinitialized();
        guard let callback = handleMap.get(handle: handle) else {
            throw UniffiInternalError.unexpectedStaleHandle
        }
        return callback
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        ensureCallbackinitialized();
        let handle: UniFFICallbackHandle = try readInt(&buf)
        return try lift(handle)
    }

    public static func lower(_ v: SwiftType) -> UniFFICallbackHandle {
        ensureCallbackinitialized();
        return handleMap.insert(obj: v)
    }

    public static func write(_ v: SwiftType, into buf: inout [UInt8]) {
        ensureCallbackinitialized();
        writeInt(&buf, lower(v))
    }
}

fileprivate struct FfiConverterOptionUInt8: FfiConverterRustBuffer {
    typealias SwiftType = UInt8?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterUInt8.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterUInt8.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionUInt32: FfiConverterRustBuffer {
    typealias SwiftType = UInt32?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterUInt32.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterUInt32.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionInt32: FfiConverterRustBuffer {
    typealias SwiftType = Int32?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterInt32.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterInt32.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionUInt64: FfiConverterRustBuffer {
    typealias SwiftType = UInt64?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterUInt64.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterUInt64.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionBool: FfiConverterRustBuffer {
    typealias SwiftType = Bool?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterBool.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterBool.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionString: FfiConverterRustBuffer {
    typealias SwiftType = String?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterString.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterString.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionDuration: FfiConverterRustBuffer {
    typealias SwiftType = TimeInterval?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterDuration.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterDuration.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeEventTimelineItem: FfiConverterRustBuffer {
    typealias SwiftType = EventTimelineItem?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeEventTimelineItem.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeEventTimelineItem.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeHomeserverLoginDetails: FfiConverterRustBuffer {
    typealias SwiftType = HomeserverLoginDetails?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeHomeserverLoginDetails.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeHomeserverLoginDetails.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeMediaSource: FfiConverterRustBuffer {
    typealias SwiftType = MediaSource?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeMediaSource.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeMediaSource.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeMessage: FfiConverterRustBuffer {
    typealias SwiftType = Message?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeMessage.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeMessage.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeRoom: FfiConverterRustBuffer {
    typealias SwiftType = Room?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeRoom.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeRoom.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeRoomMember: FfiConverterRustBuffer {
    typealias SwiftType = RoomMember?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeRoomMember.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeRoomMember.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeTimelineItem: FfiConverterRustBuffer {
    typealias SwiftType = TimelineItem?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeTimelineItem.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeTimelineItem.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeAudioInfo: FfiConverterRustBuffer {
    typealias SwiftType = AudioInfo?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeAudioInfo.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeAudioInfo.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeFileInfo: FfiConverterRustBuffer {
    typealias SwiftType = FileInfo?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeFileInfo.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeFileInfo.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeFormattedBody: FfiConverterRustBuffer {
    typealias SwiftType = FormattedBody?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeFormattedBody.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeFormattedBody.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeImageInfo: FfiConverterRustBuffer {
    typealias SwiftType = ImageInfo?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeImageInfo.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeImageInfo.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeInReplyToDetails: FfiConverterRustBuffer {
    typealias SwiftType = InReplyToDetails?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeInReplyToDetails.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeInReplyToDetails.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeInsertData: FfiConverterRustBuffer {
    typealias SwiftType = InsertData?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeInsertData.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeInsertData.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeNotificationItem: FfiConverterRustBuffer {
    typealias SwiftType = NotificationItem?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeNotificationItem.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeNotificationItem.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeOidcConfiguration: FfiConverterRustBuffer {
    typealias SwiftType = OidcConfiguration?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeOidcConfiguration.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeOidcConfiguration.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeRoomSubscription: FfiConverterRustBuffer {
    typealias SwiftType = RoomSubscription?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeRoomSubscription.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeRoomSubscription.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeSetData: FfiConverterRustBuffer {
    typealias SwiftType = SetData?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeSetData.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeSetData.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeThumbnailInfo: FfiConverterRustBuffer {
    typealias SwiftType = ThumbnailInfo?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeThumbnailInfo.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeThumbnailInfo.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeTracingFileConfiguration: FfiConverterRustBuffer {
    typealias SwiftType = TracingFileConfiguration?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeTracingFileConfiguration.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeTracingFileConfiguration.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeVideoInfo: FfiConverterRustBuffer {
    typealias SwiftType = VideoInfo?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeVideoInfo.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeVideoInfo.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeAssetType: FfiConverterRustBuffer {
    typealias SwiftType = AssetType?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeAssetType.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeAssetType.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeEventItemOrigin: FfiConverterRustBuffer {
    typealias SwiftType = EventItemOrigin?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeEventItemOrigin.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeEventItemOrigin.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeEventSendState: FfiConverterRustBuffer {
    typealias SwiftType = EventSendState?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeEventSendState.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeEventSendState.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeMembershipChange: FfiConverterRustBuffer {
    typealias SwiftType = MembershipChange?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeMembershipChange.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeMembershipChange.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeMessageType: FfiConverterRustBuffer {
    typealias SwiftType = MessageType?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeMessageType.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeMessageType.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypePushFormat: FfiConverterRustBuffer {
    typealias SwiftType = PushFormat?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypePushFormat.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypePushFormat.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeRoomNotificationMode: FfiConverterRustBuffer {
    typealias SwiftType = RoomNotificationMode?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeRoomNotificationMode.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeRoomNotificationMode.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeVirtualTimelineItem: FfiConverterRustBuffer {
    typealias SwiftType = VirtualTimelineItem?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeVirtualTimelineItem.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeVirtualTimelineItem.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionCallbackInterfaceClientDelegate: FfiConverterRustBuffer {
    typealias SwiftType = ClientDelegate?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterCallbackInterfaceClientDelegate.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterCallbackInterfaceClientDelegate.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionCallbackInterfaceNotificationSettingsDelegate: FfiConverterRustBuffer {
    typealias SwiftType = NotificationSettingsDelegate?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterCallbackInterfaceNotificationSettingsDelegate.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterCallbackInterfaceNotificationSettingsDelegate.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionCallbackInterfaceProgressWatcher: FfiConverterRustBuffer {
    typealias SwiftType = ProgressWatcher?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterCallbackInterfaceProgressWatcher.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterCallbackInterfaceProgressWatcher.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionCallbackInterfaceSessionVerificationControllerDelegate: FfiConverterRustBuffer {
    typealias SwiftType = SessionVerificationControllerDelegate?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterCallbackInterfaceSessionVerificationControllerDelegate.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterCallbackInterfaceSessionVerificationControllerDelegate.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionSequenceString: FfiConverterRustBuffer {
    typealias SwiftType = [String]?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterSequenceString.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterSequenceString.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionSequenceTypeTimelineItem: FfiConverterRustBuffer {
    typealias SwiftType = [TimelineItem]?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterSequenceTypeTimelineItem.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterSequenceTypeTimelineItem.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionSequenceTypeRequiredState: FfiConverterRustBuffer {
    typealias SwiftType = [RequiredState]?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterSequenceTypeRequiredState.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterSequenceTypeRequiredState.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterSequenceUInt8: FfiConverterRustBuffer {
    typealias SwiftType = [UInt8]

    public static func write(_ value: [UInt8], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterUInt8.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [UInt8] {
        let len: Int32 = try readInt(&buf)
        var seq = [UInt8]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterUInt8.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceString: FfiConverterRustBuffer {
    typealias SwiftType = [String]

    public static func write(_ value: [String], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterString.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String] {
        let len: Int32 = try readInt(&buf)
        var seq = [String]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterString.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeRoom: FfiConverterRustBuffer {
    typealias SwiftType = [Room]

    public static func write(_ value: [Room], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeRoom.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Room] {
        let len: Int32 = try readInt(&buf)
        var seq = [Room]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeRoom.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeRoomMember: FfiConverterRustBuffer {
    typealias SwiftType = [RoomMember]

    public static func write(_ value: [RoomMember], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeRoomMember.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [RoomMember] {
        let len: Int32 = try readInt(&buf)
        var seq = [RoomMember]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeRoomMember.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeSessionVerificationEmoji: FfiConverterRustBuffer {
    typealias SwiftType = [SessionVerificationEmoji]

    public static func write(_ value: [SessionVerificationEmoji], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeSessionVerificationEmoji.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [SessionVerificationEmoji] {
        let len: Int32 = try readInt(&buf)
        var seq = [SessionVerificationEmoji]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeSessionVerificationEmoji.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeTimelineDiff: FfiConverterRustBuffer {
    typealias SwiftType = [TimelineDiff]

    public static func write(_ value: [TimelineDiff], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeTimelineDiff.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [TimelineDiff] {
        let len: Int32 = try readInt(&buf)
        var seq = [TimelineDiff]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeTimelineDiff.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeTimelineItem: FfiConverterRustBuffer {
    typealias SwiftType = [TimelineItem]

    public static func write(_ value: [TimelineItem], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeTimelineItem.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [TimelineItem] {
        let len: Int32 = try readInt(&buf)
        var seq = [TimelineItem]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeTimelineItem.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypePollAnswer: FfiConverterRustBuffer {
    typealias SwiftType = [PollAnswer]

    public static func write(_ value: [PollAnswer], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypePollAnswer.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [PollAnswer] {
        let len: Int32 = try readInt(&buf)
        var seq = [PollAnswer]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypePollAnswer.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeReaction: FfiConverterRustBuffer {
    typealias SwiftType = [Reaction]

    public static func write(_ value: [Reaction], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeReaction.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Reaction] {
        let len: Int32 = try readInt(&buf)
        var seq = [Reaction]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeReaction.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeReactionSenderData: FfiConverterRustBuffer {
    typealias SwiftType = [ReactionSenderData]

    public static func write(_ value: [ReactionSenderData], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeReactionSenderData.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [ReactionSenderData] {
        let len: Int32 = try readInt(&buf)
        var seq = [ReactionSenderData]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeReactionSenderData.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeRequiredState: FfiConverterRustBuffer {
    typealias SwiftType = [RequiredState]

    public static func write(_ value: [RequiredState], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeRequiredState.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [RequiredState] {
        let len: Int32 = try readInt(&buf)
        var seq = [RequiredState]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeRequiredState.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeRoomListRange: FfiConverterRustBuffer {
    typealias SwiftType = [RoomListRange]

    public static func write(_ value: [RoomListRange], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeRoomListRange.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [RoomListRange] {
        let len: Int32 = try readInt(&buf)
        var seq = [RoomListRange]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeRoomListRange.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeUserProfile: FfiConverterRustBuffer {
    typealias SwiftType = [UserProfile]

    public static func write(_ value: [UserProfile], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeUserProfile.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [UserProfile] {
        let len: Int32 = try readInt(&buf)
        var seq = [UserProfile]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeUserProfile.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeRoomListEntriesUpdate: FfiConverterRustBuffer {
    typealias SwiftType = [RoomListEntriesUpdate]

    public static func write(_ value: [RoomListEntriesUpdate], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeRoomListEntriesUpdate.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [RoomListEntriesUpdate] {
        let len: Int32 = try readInt(&buf)
        var seq = [RoomListEntriesUpdate]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeRoomListEntriesUpdate.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeRoomListEntry: FfiConverterRustBuffer {
    typealias SwiftType = [RoomListEntry]

    public static func write(_ value: [RoomListEntry], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeRoomListEntry.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [RoomListEntry] {
        let len: Int32 = try readInt(&buf)
        var seq = [RoomListEntry]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeRoomListEntry.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeWidgetEventFilter: FfiConverterRustBuffer {
    typealias SwiftType = [WidgetEventFilter]

    public static func write(_ value: [WidgetEventFilter], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeWidgetEventFilter.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [WidgetEventFilter] {
        let len: Int32 = try readInt(&buf)
        var seq = [WidgetEventFilter]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeWidgetEventFilter.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterDictionaryStringString: FfiConverterRustBuffer {
    public static func write(_ value: [String: String], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterString.write(key, into: &buf)
            FfiConverterString.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String: String] {
        let len: Int32 = try readInt(&buf)
        var dict = [String: String]()
        dict.reserveCapacity(Int(len))
        for _ in 0..<len {
            let key = try FfiConverterString.read(from: &buf)
            let value = try FfiConverterString.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

fileprivate struct FfiConverterDictionaryStringTypeReceipt: FfiConverterRustBuffer {
    public static func write(_ value: [String: Receipt], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterString.write(key, into: &buf)
            FfiConverterTypeReceipt.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String: Receipt] {
        let len: Int32 = try readInt(&buf)
        var dict = [String: Receipt]()
        dict.reserveCapacity(Int(len))
        for _ in 0..<len {
            let key = try FfiConverterString.read(from: &buf)
            let value = try FfiConverterTypeReceipt.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

fileprivate struct FfiConverterDictionaryStringSequenceString: FfiConverterRustBuffer {
    public static func write(_ value: [String: [String]], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterString.write(key, into: &buf)
            FfiConverterSequenceString.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String: [String]] {
        let len: Int32 = try readInt(&buf)
        var dict = [String: [String]]()
        dict.reserveCapacity(Int(len))
        for _ in 0..<len {
            let key = try FfiConverterString.read(from: &buf)
            let value = try FfiConverterSequenceString.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}// Callbacks for async functions

// Callback handlers for an async calls.  These are invoked by Rust when the future is ready.  They
// lift the return value or error and resume the suspended function.
fileprivate func uniffiFutureCallbackHandlerVoid(
    rawContinutation: UnsafeRawPointer,
    returnValue: UInt8,
    callStatus: RustCallStatus) {

    let continuation = rawContinutation.bindMemory(
        to: CheckedContinuation<(), Error>.self,
        capacity: 1
    )

    do {
        try uniffiCheckCallStatus(callStatus: callStatus, errorHandler: nil)
        continuation.pointee.resume(returning: ())
    } catch let error {
        continuation.pointee.resume(throwing: error)
    }
}
fileprivate func uniffiFutureCallbackHandlerVoidTypeAuthenticationError(
    rawContinutation: UnsafeRawPointer,
    returnValue: UInt8,
    callStatus: RustCallStatus) {

    let continuation = rawContinutation.bindMemory(
        to: CheckedContinuation<(), Error>.self,
        capacity: 1
    )

    do {
        try uniffiCheckCallStatus(callStatus: callStatus, errorHandler: FfiConverterTypeAuthenticationError.lift)
        continuation.pointee.resume(returning: ())
    } catch let error {
        continuation.pointee.resume(throwing: error)
    }
}
fileprivate func uniffiFutureCallbackHandlerVoidTypeClientError(
    rawContinutation: UnsafeRawPointer,
    returnValue: UInt8,
    callStatus: RustCallStatus) {

    let continuation = rawContinutation.bindMemory(
        to: CheckedContinuation<(), Error>.self,
        capacity: 1
    )

    do {
        try uniffiCheckCallStatus(callStatus: callStatus, errorHandler: FfiConverterTypeClientError.lift)
        continuation.pointee.resume(returning: ())
    } catch let error {
        continuation.pointee.resume(throwing: error)
    }
}
fileprivate func uniffiFutureCallbackHandlerVoidTypeNotificationSettingsError(
    rawContinutation: UnsafeRawPointer,
    returnValue: UInt8,
    callStatus: RustCallStatus) {

    let continuation = rawContinutation.bindMemory(
        to: CheckedContinuation<(), Error>.self,
        capacity: 1
    )

    do {
        try uniffiCheckCallStatus(callStatus: callStatus, errorHandler: FfiConverterTypeNotificationSettingsError.lift)
        continuation.pointee.resume(returning: ())
    } catch let error {
        continuation.pointee.resume(throwing: error)
    }
}
fileprivate func uniffiFutureCallbackHandlerVoidTypeRoomError(
    rawContinutation: UnsafeRawPointer,
    returnValue: UInt8,
    callStatus: RustCallStatus) {

    let continuation = rawContinutation.bindMemory(
        to: CheckedContinuation<(), Error>.self,
        capacity: 1
    )

    do {
        try uniffiCheckCallStatus(callStatus: callStatus, errorHandler: FfiConverterTypeRoomError.lift)
        continuation.pointee.resume(returning: ())
    } catch let error {
        continuation.pointee.resume(throwing: error)
    }
}
fileprivate func uniffiFutureCallbackHandlerVoidTypeRoomListError(
    rawContinutation: UnsafeRawPointer,
    returnValue: UInt8,
    callStatus: RustCallStatus) {

    let continuation = rawContinutation.bindMemory(
        to: CheckedContinuation<(), Error>.self,
        capacity: 1
    )

    do {
        try uniffiCheckCallStatus(callStatus: callStatus, errorHandler: FfiConverterTypeRoomListError.lift)
        continuation.pointee.resume(returning: ())
    } catch let error {
        continuation.pointee.resume(throwing: error)
    }
}
fileprivate func uniffiFutureCallbackHandlerUInt32(
    rawContinutation: UnsafeRawPointer,
    returnValue: UInt32,
    callStatus: RustCallStatus) {

    let continuation = rawContinutation.bindMemory(
        to: CheckedContinuation<UInt32, Error>.self,
        capacity: 1
    )

    do {
        try uniffiCheckCallStatus(callStatus: callStatus, errorHandler: nil)
        continuation.pointee.resume(returning: try FfiConverterUInt32.lift(returnValue))
    } catch let error {
        continuation.pointee.resume(throwing: error)
    }
}
fileprivate func uniffiFutureCallbackHandlerUInt64(
    rawContinutation: UnsafeRawPointer,
    returnValue: UInt64,
    callStatus: RustCallStatus) {

    let continuation = rawContinutation.bindMemory(
        to: CheckedContinuation<UInt64, Error>.self,
        capacity: 1
    )

    do {
        try uniffiCheckCallStatus(callStatus: callStatus, errorHandler: nil)
        continuation.pointee.resume(returning: try FfiConverterUInt64.lift(returnValue))
    } catch let error {
        continuation.pointee.resume(throwing: error)
    }
}
fileprivate func uniffiFutureCallbackHandlerInt64(
    rawContinutation: UnsafeRawPointer,
    returnValue: Int64,
    callStatus: RustCallStatus) {

    let continuation = rawContinutation.bindMemory(
        to: CheckedContinuation<Int64, Error>.self,
        capacity: 1
    )

    do {
        try uniffiCheckCallStatus(callStatus: callStatus, errorHandler: nil)
        continuation.pointee.resume(returning: try FfiConverterInt64.lift(returnValue))
    } catch let error {
        continuation.pointee.resume(throwing: error)
    }
}
fileprivate func uniffiFutureCallbackHandlerBool(
    rawContinutation: UnsafeRawPointer,
    returnValue: Int8,
    callStatus: RustCallStatus) {

    let continuation = rawContinutation.bindMemory(
        to: CheckedContinuation<Bool, Error>.self,
        capacity: 1
    )

    do {
        try uniffiCheckCallStatus(callStatus: callStatus, errorHandler: nil)
        continuation.pointee.resume(returning: try FfiConverterBool.lift(returnValue))
    } catch let error {
        continuation.pointee.resume(throwing: error)
    }
}
fileprivate func uniffiFutureCallbackHandlerBoolTypeClientError(
    rawContinutation: UnsafeRawPointer,
    returnValue: Int8,
    callStatus: RustCallStatus) {

    let continuation = rawContinutation.bindMemory(
        to: CheckedContinuation<Bool, Error>.self,
        capacity: 1
    )

    do {
        try uniffiCheckCallStatus(callStatus: callStatus, errorHandler: FfiConverterTypeClientError.lift)
        continuation.pointee.resume(returning: try FfiConverterBool.lift(returnValue))
    } catch let error {
        continuation.pointee.resume(throwing: error)
    }
}
fileprivate func uniffiFutureCallbackHandlerBoolTypeNotificationSettingsError(
    rawContinutation: UnsafeRawPointer,
    returnValue: Int8,
    callStatus: RustCallStatus) {

    let continuation = rawContinutation.bindMemory(
        to: CheckedContinuation<Bool, Error>.self,
        capacity: 1
    )

    do {
        try uniffiCheckCallStatus(callStatus: callStatus, errorHandler: FfiConverterTypeNotificationSettingsError.lift)
        continuation.pointee.resume(returning: try FfiConverterBool.lift(returnValue))
    } catch let error {
        continuation.pointee.resume(throwing: error)
    }
}
fileprivate func uniffiFutureCallbackHandlerString(
    rawContinutation: UnsafeRawPointer,
    returnValue: RustBuffer,
    callStatus: RustCallStatus) {

    let continuation = rawContinutation.bindMemory(
        to: CheckedContinuation<String, Error>.self,
        capacity: 1
    )

    do {
        try uniffiCheckCallStatus(callStatus: callStatus, errorHandler: nil)
        continuation.pointee.resume(returning: try FfiConverterString.lift(returnValue))
    } catch let error {
        continuation.pointee.resume(throwing: error)
    }
}
fileprivate func uniffiFutureCallbackHandlerStringTypeClientError(
    rawContinutation: UnsafeRawPointer,
    returnValue: RustBuffer,
    callStatus: RustCallStatus) {

    let continuation = rawContinutation.bindMemory(
        to: CheckedContinuation<String, Error>.self,
        capacity: 1
    )

    do {
        try uniffiCheckCallStatus(callStatus: callStatus, errorHandler: FfiConverterTypeClientError.lift)
        continuation.pointee.resume(returning: try FfiConverterString.lift(returnValue))
    } catch let error {
        continuation.pointee.resume(throwing: error)
    }
}
fileprivate func uniffiFutureCallbackHandlerTypeAuthenticationService(
    rawContinutation: UnsafeRawPointer,
    returnValue: UnsafeMutableRawPointer,
    callStatus: RustCallStatus) {

    let continuation = rawContinutation.bindMemory(
        to: CheckedContinuation<AuthenticationService, Error>.self,
        capacity: 1
    )

    do {
        try uniffiCheckCallStatus(callStatus: callStatus, errorHandler: nil)
        continuation.pointee.resume(returning: try FfiConverterTypeAuthenticationService.lift(returnValue))
    } catch let error {
        continuation.pointee.resume(throwing: error)
    }
}
fileprivate func uniffiFutureCallbackHandlerTypeClientTypeAuthenticationError(
    rawContinutation: UnsafeRawPointer,
    returnValue: UnsafeMutableRawPointer,
    callStatus: RustCallStatus) {

    let continuation = rawContinutation.bindMemory(
        to: CheckedContinuation<Client, Error>.self,
        capacity: 1
    )

    do {
        try uniffiCheckCallStatus(callStatus: callStatus, errorHandler: FfiConverterTypeAuthenticationError.lift)
        continuation.pointee.resume(returning: try FfiConverterTypeClient.lift(returnValue))
    } catch let error {
        continuation.pointee.resume(throwing: error)
    }
}
fileprivate func uniffiFutureCallbackHandlerTypeClientTypeClientError(
    rawContinutation: UnsafeRawPointer,
    returnValue: UnsafeMutableRawPointer,
    callStatus: RustCallStatus) {

    let continuation = rawContinutation.bindMemory(
        to: CheckedContinuation<Client, Error>.self,
        capacity: 1
    )

    do {
        try uniffiCheckCallStatus(callStatus: callStatus, errorHandler: FfiConverterTypeClientError.lift)
        continuation.pointee.resume(returning: try FfiConverterTypeClient.lift(returnValue))
    } catch let error {
        continuation.pointee.resume(throwing: error)
    }
}
fileprivate func uniffiFutureCallbackHandlerTypeClientBuilder(
    rawContinutation: UnsafeRawPointer,
    returnValue: UnsafeMutableRawPointer,
    callStatus: RustCallStatus) {

    let continuation = rawContinutation.bindMemory(
        to: CheckedContinuation<ClientBuilder, Error>.self,
        capacity: 1
    )

    do {
        try uniffiCheckCallStatus(callStatus: callStatus, errorHandler: nil)
        continuation.pointee.resume(returning: try FfiConverterTypeClientBuilder.lift(returnValue))
    } catch let error {
        continuation.pointee.resume(throwing: error)
    }
}
fileprivate func uniffiFutureCallbackHandlerTypeMediaFileHandleTypeClientError(
    rawContinutation: UnsafeRawPointer,
    returnValue: UnsafeMutableRawPointer,
    callStatus: RustCallStatus) {

    let continuation = rawContinutation.bindMemory(
        to: CheckedContinuation<MediaFileHandle, Error>.self,
        capacity: 1
    )

    do {
        try uniffiCheckCallStatus(callStatus: callStatus, errorHandler: FfiConverterTypeClientError.lift)
        continuation.pointee.resume(returning: try FfiConverterTypeMediaFileHandle.lift(returnValue))
    } catch let error {
        continuation.pointee.resume(throwing: error)
    }
}
fileprivate func uniffiFutureCallbackHandlerTypeMediaSource(
    rawContinutation: UnsafeRawPointer,
    returnValue: UnsafeMutableRawPointer,
    callStatus: RustCallStatus) {

    let continuation = rawContinutation.bindMemory(
        to: CheckedContinuation<MediaSource, Error>.self,
        capacity: 1
    )

    do {
        try uniffiCheckCallStatus(callStatus: callStatus, errorHandler: nil)
        continuation.pointee.resume(returning: try FfiConverterTypeMediaSource.lift(returnValue))
    } catch let error {
        continuation.pointee.resume(throwing: error)
    }
}
fileprivate func uniffiFutureCallbackHandlerTypeMediaSourceTypeClientError(
    rawContinutation: UnsafeRawPointer,
    returnValue: UnsafeMutableRawPointer,
    callStatus: RustCallStatus) {

    let continuation = rawContinutation.bindMemory(
        to: CheckedContinuation<MediaSource, Error>.self,
        capacity: 1
    )

    do {
        try uniffiCheckCallStatus(callStatus: callStatus, errorHandler: FfiConverterTypeClientError.lift)
        continuation.pointee.resume(returning: try FfiConverterTypeMediaSource.lift(returnValue))
    } catch let error {
        continuation.pointee.resume(throwing: error)
    }
}
fileprivate func uniffiFutureCallbackHandlerTypeNotificationClient(
    rawContinutation: UnsafeRawPointer,
    returnValue: UnsafeMutableRawPointer,
    callStatus: RustCallStatus) {

    let continuation = rawContinutation.bindMemory(
        to: CheckedContinuation<NotificationClient, Error>.self,
        capacity: 1
    )

    do {
        try uniffiCheckCallStatus(callStatus: callStatus, errorHandler: nil)
        continuation.pointee.resume(returning: try FfiConverterTypeNotificationClient.lift(returnValue))
    } catch let error {
        continuation.pointee.resume(throwing: error)
    }
}
fileprivate func uniffiFutureCallbackHandlerTypeNotificationClientBuilder(
    rawContinutation: UnsafeRawPointer,
    returnValue: UnsafeMutableRawPointer,
    callStatus: RustCallStatus) {

    let continuation = rawContinutation.bindMemory(
        to: CheckedContinuation<NotificationClientBuilder, Error>.self,
        capacity: 1
    )

    do {
        try uniffiCheckCallStatus(callStatus: callStatus, errorHandler: nil)
        continuation.pointee.resume(returning: try FfiConverterTypeNotificationClientBuilder.lift(returnValue))
    } catch let error {
        continuation.pointee.resume(throwing: error)
    }
}
fileprivate func uniffiFutureCallbackHandlerTypeNotificationClientBuilderTypeClientError(
    rawContinutation: UnsafeRawPointer,
    returnValue: UnsafeMutableRawPointer,
    callStatus: RustCallStatus) {

    let continuation = rawContinutation.bindMemory(
        to: CheckedContinuation<NotificationClientBuilder, Error>.self,
        capacity: 1
    )

    do {
        try uniffiCheckCallStatus(callStatus: callStatus, errorHandler: FfiConverterTypeClientError.lift)
        continuation.pointee.resume(returning: try FfiConverterTypeNotificationClientBuilder.lift(returnValue))
    } catch let error {
        continuation.pointee.resume(throwing: error)
    }
}
fileprivate func uniffiFutureCallbackHandlerTypeNotificationSettings(
    rawContinutation: UnsafeRawPointer,
    returnValue: UnsafeMutableRawPointer,
    callStatus: RustCallStatus) {

    let continuation = rawContinutation.bindMemory(
        to: CheckedContinuation<NotificationSettings, Error>.self,
        capacity: 1
    )

    do {
        try uniffiCheckCallStatus(callStatus: callStatus, errorHandler: nil)
        continuation.pointee.resume(returning: try FfiConverterTypeNotificationSettings.lift(returnValue))
    } catch let error {
        continuation.pointee.resume(throwing: error)
    }
}
fileprivate func uniffiFutureCallbackHandlerTypeOidcAuthenticationDataTypeAuthenticationError(
    rawContinutation: UnsafeRawPointer,
    returnValue: UnsafeMutableRawPointer,
    callStatus: RustCallStatus) {

    let continuation = rawContinutation.bindMemory(
        to: CheckedContinuation<OidcAuthenticationData, Error>.self,
        capacity: 1
    )

    do {
        try uniffiCheckCallStatus(callStatus: callStatus, errorHandler: FfiConverterTypeAuthenticationError.lift)
        continuation.pointee.resume(returning: try FfiConverterTypeOidcAuthenticationData.lift(returnValue))
    } catch let error {
        continuation.pointee.resume(throwing: error)
    }
}
fileprivate func uniffiFutureCallbackHandlerTypeRoom(
    rawContinutation: UnsafeRawPointer,
    returnValue: UnsafeMutableRawPointer,
    callStatus: RustCallStatus) {

    let continuation = rawContinutation.bindMemory(
        to: CheckedContinuation<Room, Error>.self,
        capacity: 1
    )

    do {
        try uniffiCheckCallStatus(callStatus: callStatus, errorHandler: nil)
        continuation.pointee.resume(returning: try FfiConverterTypeRoom.lift(returnValue))
    } catch let error {
        continuation.pointee.resume(throwing: error)
    }
}
fileprivate func uniffiFutureCallbackHandlerTypeRoomListTypeRoomListError(
    rawContinutation: UnsafeRawPointer,
    returnValue: UnsafeMutableRawPointer,
    callStatus: RustCallStatus) {

    let continuation = rawContinutation.bindMemory(
        to: CheckedContinuation<RoomList, Error>.self,
        capacity: 1
    )

    do {
        try uniffiCheckCallStatus(callStatus: callStatus, errorHandler: FfiConverterTypeRoomListError.lift)
        continuation.pointee.resume(returning: try FfiConverterTypeRoomList.lift(returnValue))
    } catch let error {
        continuation.pointee.resume(throwing: error)
    }
}
fileprivate func uniffiFutureCallbackHandlerTypeRoomListItemTypeRoomListError(
    rawContinutation: UnsafeRawPointer,
    returnValue: UnsafeMutableRawPointer,
    callStatus: RustCallStatus) {

    let continuation = rawContinutation.bindMemory(
        to: CheckedContinuation<RoomListItem, Error>.self,
        capacity: 1
    )

    do {
        try uniffiCheckCallStatus(callStatus: callStatus, errorHandler: FfiConverterTypeRoomListError.lift)
        continuation.pointee.resume(returning: try FfiConverterTypeRoomListItem.lift(returnValue))
    } catch let error {
        continuation.pointee.resume(throwing: error)
    }
}
fileprivate func uniffiFutureCallbackHandlerTypeRoomListService(
    rawContinutation: UnsafeRawPointer,
    returnValue: UnsafeMutableRawPointer,
    callStatus: RustCallStatus) {

    let continuation = rawContinutation.bindMemory(
        to: CheckedContinuation<RoomListService, Error>.self,
        capacity: 1
    )

    do {
        try uniffiCheckCallStatus(callStatus: callStatus, errorHandler: nil)
        continuation.pointee.resume(returning: try FfiConverterTypeRoomListService.lift(returnValue))
    } catch let error {
        continuation.pointee.resume(throwing: error)
    }
}
fileprivate func uniffiFutureCallbackHandlerTypeRoomMemberTypeClientError(
    rawContinutation: UnsafeRawPointer,
    returnValue: UnsafeMutableRawPointer,
    callStatus: RustCallStatus) {

    let continuation = rawContinutation.bindMemory(
        to: CheckedContinuation<RoomMember, Error>.self,
        capacity: 1
    )

    do {
        try uniffiCheckCallStatus(callStatus: callStatus, errorHandler: FfiConverterTypeClientError.lift)
        continuation.pointee.resume(returning: try FfiConverterTypeRoomMember.lift(returnValue))
    } catch let error {
        continuation.pointee.resume(throwing: error)
    }
}
fileprivate func uniffiFutureCallbackHandlerTypeRoomMessageEventContentWithoutRelation(
    rawContinutation: UnsafeRawPointer,
    returnValue: UnsafeMutableRawPointer,
    callStatus: RustCallStatus) {

    let continuation = rawContinutation.bindMemory(
        to: CheckedContinuation<RoomMessageEventContentWithoutRelation, Error>.self,
        capacity: 1
    )

    do {
        try uniffiCheckCallStatus(callStatus: callStatus, errorHandler: nil)
        continuation.pointee.resume(returning: try FfiConverterTypeRoomMessageEventContentWithoutRelation.lift(returnValue))
    } catch let error {
        continuation.pointee.resume(throwing: error)
    }
}
fileprivate func uniffiFutureCallbackHandlerTypeRoomMessageEventContentWithoutRelationTypeClientError(
    rawContinutation: UnsafeRawPointer,
    returnValue: UnsafeMutableRawPointer,
    callStatus: RustCallStatus) {

    let continuation = rawContinutation.bindMemory(
        to: CheckedContinuation<RoomMessageEventContentWithoutRelation, Error>.self,
        capacity: 1
    )

    do {
        try uniffiCheckCallStatus(callStatus: callStatus, errorHandler: FfiConverterTypeClientError.lift)
        continuation.pointee.resume(returning: try FfiConverterTypeRoomMessageEventContentWithoutRelation.lift(returnValue))
    } catch let error {
        continuation.pointee.resume(throwing: error)
    }
}
fileprivate func uniffiFutureCallbackHandlerTypeSendAttachmentJoinHandle(
    rawContinutation: UnsafeRawPointer,
    returnValue: UnsafeMutableRawPointer,
    callStatus: RustCallStatus) {

    let continuation = rawContinutation.bindMemory(
        to: CheckedContinuation<SendAttachmentJoinHandle, Error>.self,
        capacity: 1
    )

    do {
        try uniffiCheckCallStatus(callStatus: callStatus, errorHandler: nil)
        continuation.pointee.resume(returning: try FfiConverterTypeSendAttachmentJoinHandle.lift(returnValue))
    } catch let error {
        continuation.pointee.resume(throwing: error)
    }
}
fileprivate func uniffiFutureCallbackHandlerTypeSessionVerificationControllerTypeClientError(
    rawContinutation: UnsafeRawPointer,
    returnValue: UnsafeMutableRawPointer,
    callStatus: RustCallStatus) {

    let continuation = rawContinutation.bindMemory(
        to: CheckedContinuation<SessionVerificationController, Error>.self,
        capacity: 1
    )

    do {
        try uniffiCheckCallStatus(callStatus: callStatus, errorHandler: FfiConverterTypeClientError.lift)
        continuation.pointee.resume(returning: try FfiConverterTypeSessionVerificationController.lift(returnValue))
    } catch let error {
        continuation.pointee.resume(throwing: error)
    }
}
fileprivate func uniffiFutureCallbackHandlerTypeSpan(
    rawContinutation: UnsafeRawPointer,
    returnValue: UnsafeMutableRawPointer,
    callStatus: RustCallStatus) {

    let continuation = rawContinutation.bindMemory(
        to: CheckedContinuation<Span, Error>.self,
        capacity: 1
    )

    do {
        try uniffiCheckCallStatus(callStatus: callStatus, errorHandler: nil)
        continuation.pointee.resume(returning: try FfiConverterTypeSpan.lift(returnValue))
    } catch let error {
        continuation.pointee.resume(throwing: error)
    }
}
fileprivate func uniffiFutureCallbackHandlerTypeSyncServiceTypeClientError(
    rawContinutation: UnsafeRawPointer,
    returnValue: UnsafeMutableRawPointer,
    callStatus: RustCallStatus) {

    let continuation = rawContinutation.bindMemory(
        to: CheckedContinuation<SyncService, Error>.self,
        capacity: 1
    )

    do {
        try uniffiCheckCallStatus(callStatus: callStatus, errorHandler: FfiConverterTypeClientError.lift)
        continuation.pointee.resume(returning: try FfiConverterTypeSyncService.lift(returnValue))
    } catch let error {
        continuation.pointee.resume(throwing: error)
    }
}
fileprivate func uniffiFutureCallbackHandlerTypeSyncServiceBuilder(
    rawContinutation: UnsafeRawPointer,
    returnValue: UnsafeMutableRawPointer,
    callStatus: RustCallStatus) {

    let continuation = rawContinutation.bindMemory(
        to: CheckedContinuation<SyncServiceBuilder, Error>.self,
        capacity: 1
    )

    do {
        try uniffiCheckCallStatus(callStatus: callStatus, errorHandler: nil)
        continuation.pointee.resume(returning: try FfiConverterTypeSyncServiceBuilder.lift(returnValue))
    } catch let error {
        continuation.pointee.resume(throwing: error)
    }
}
fileprivate func uniffiFutureCallbackHandlerTypeTaskHandle(
    rawContinutation: UnsafeRawPointer,
    returnValue: UnsafeMutableRawPointer,
    callStatus: RustCallStatus) {

    let continuation = rawContinutation.bindMemory(
        to: CheckedContinuation<TaskHandle, Error>.self,
        capacity: 1
    )

    do {
        try uniffiCheckCallStatus(callStatus: callStatus, errorHandler: nil)
        continuation.pointee.resume(returning: try FfiConverterTypeTaskHandle.lift(returnValue))
    } catch let error {
        continuation.pointee.resume(throwing: error)
    }
}
fileprivate func uniffiFutureCallbackHandlerTypeTaskHandleTypeClientError(
    rawContinutation: UnsafeRawPointer,
    returnValue: UnsafeMutableRawPointer,
    callStatus: RustCallStatus) {

    let continuation = rawContinutation.bindMemory(
        to: CheckedContinuation<TaskHandle, Error>.self,
        capacity: 1
    )

    do {
        try uniffiCheckCallStatus(callStatus: callStatus, errorHandler: FfiConverterTypeClientError.lift)
        continuation.pointee.resume(returning: try FfiConverterTypeTaskHandle.lift(returnValue))
    } catch let error {
        continuation.pointee.resume(throwing: error)
    }
}
fileprivate func uniffiFutureCallbackHandlerTypeTimelineItemContent(
    rawContinutation: UnsafeRawPointer,
    returnValue: UnsafeMutableRawPointer,
    callStatus: RustCallStatus) {

    let continuation = rawContinutation.bindMemory(
        to: CheckedContinuation<TimelineItemContent, Error>.self,
        capacity: 1
    )

    do {
        try uniffiCheckCallStatus(callStatus: callStatus, errorHandler: nil)
        continuation.pointee.resume(returning: try FfiConverterTypeTimelineItemContent.lift(returnValue))
    } catch let error {
        continuation.pointee.resume(throwing: error)
    }
}
fileprivate func uniffiFutureCallbackHandlerTypeUnreadNotificationsCount(
    rawContinutation: UnsafeRawPointer,
    returnValue: UnsafeMutableRawPointer,
    callStatus: RustCallStatus) {

    let continuation = rawContinutation.bindMemory(
        to: CheckedContinuation<UnreadNotificationsCount, Error>.self,
        capacity: 1
    )

    do {
        try uniffiCheckCallStatus(callStatus: callStatus, errorHandler: nil)
        continuation.pointee.resume(returning: try FfiConverterTypeUnreadNotificationsCount.lift(returnValue))
    } catch let error {
        continuation.pointee.resume(throwing: error)
    }
}
fileprivate func uniffiFutureCallbackHandlerTypeEventTimelineItemDebugInfo(
    rawContinutation: UnsafeRawPointer,
    returnValue: RustBuffer,
    callStatus: RustCallStatus) {

    let continuation = rawContinutation.bindMemory(
        to: CheckedContinuation<EventTimelineItemDebugInfo, Error>.self,
        capacity: 1
    )

    do {
        try uniffiCheckCallStatus(callStatus: callStatus, errorHandler: nil)
        continuation.pointee.resume(returning: try FfiConverterTypeEventTimelineItemDebugInfo.lift(returnValue))
    } catch let error {
        continuation.pointee.resume(throwing: error)
    }
}
fileprivate func uniffiFutureCallbackHandlerTypeRoomInfoTypeClientError(
    rawContinutation: UnsafeRawPointer,
    returnValue: RustBuffer,
    callStatus: RustCallStatus) {

    let continuation = rawContinutation.bindMemory(
        to: CheckedContinuation<RoomInfo, Error>.self,
        capacity: 1
    )

    do {
        try uniffiCheckCallStatus(callStatus: callStatus, errorHandler: FfiConverterTypeClientError.lift)
        continuation.pointee.resume(returning: try FfiConverterTypeRoomInfo.lift(returnValue))
    } catch let error {
        continuation.pointee.resume(throwing: error)
    }
}
fileprivate func uniffiFutureCallbackHandlerTypeRoomListEntriesResult(
    rawContinutation: UnsafeRawPointer,
    returnValue: RustBuffer,
    callStatus: RustCallStatus) {

    let continuation = rawContinutation.bindMemory(
        to: CheckedContinuation<RoomListEntriesResult, Error>.self,
        capacity: 1
    )

    do {
        try uniffiCheckCallStatus(callStatus: callStatus, errorHandler: nil)
        continuation.pointee.resume(returning: try FfiConverterTypeRoomListEntriesResult.lift(returnValue))
    } catch let error {
        continuation.pointee.resume(throwing: error)
    }
}
fileprivate func uniffiFutureCallbackHandlerTypeRoomListEntriesWithDynamicFilterResult(
    rawContinutation: UnsafeRawPointer,
    returnValue: RustBuffer,
    callStatus: RustCallStatus) {

    let continuation = rawContinutation.bindMemory(
        to: CheckedContinuation<RoomListEntriesWithDynamicFilterResult, Error>.self,
        capacity: 1
    )

    do {
        try uniffiCheckCallStatus(callStatus: callStatus, errorHandler: nil)
        continuation.pointee.resume(returning: try FfiConverterTypeRoomListEntriesWithDynamicFilterResult.lift(returnValue))
    } catch let error {
        continuation.pointee.resume(throwing: error)
    }
}
fileprivate func uniffiFutureCallbackHandlerTypeRoomListLoadingStateResultTypeRoomListError(
    rawContinutation: UnsafeRawPointer,
    returnValue: RustBuffer,
    callStatus: RustCallStatus) {

    let continuation = rawContinutation.bindMemory(
        to: CheckedContinuation<RoomListLoadingStateResult, Error>.self,
        capacity: 1
    )

    do {
        try uniffiCheckCallStatus(callStatus: callStatus, errorHandler: FfiConverterTypeRoomListError.lift)
        continuation.pointee.resume(returning: try FfiConverterTypeRoomListLoadingStateResult.lift(returnValue))
    } catch let error {
        continuation.pointee.resume(throwing: error)
    }
}
fileprivate func uniffiFutureCallbackHandlerTypeRoomNotificationSettingsTypeNotificationSettingsError(
    rawContinutation: UnsafeRawPointer,
    returnValue: RustBuffer,
    callStatus: RustCallStatus) {

    let continuation = rawContinutation.bindMemory(
        to: CheckedContinuation<RoomNotificationSettings, Error>.self,
        capacity: 1
    )

    do {
        try uniffiCheckCallStatus(callStatus: callStatus, errorHandler: FfiConverterTypeNotificationSettingsError.lift)
        continuation.pointee.resume(returning: try FfiConverterTypeRoomNotificationSettings.lift(returnValue))
    } catch let error {
        continuation.pointee.resume(throwing: error)
    }
}
fileprivate func uniffiFutureCallbackHandlerTypeRoomTimelineListenerResult(
    rawContinutation: UnsafeRawPointer,
    returnValue: RustBuffer,
    callStatus: RustCallStatus) {

    let continuation = rawContinutation.bindMemory(
        to: CheckedContinuation<RoomTimelineListenerResult, Error>.self,
        capacity: 1
    )

    do {
        try uniffiCheckCallStatus(callStatus: callStatus, errorHandler: nil)
        continuation.pointee.resume(returning: try FfiConverterTypeRoomTimelineListenerResult.lift(returnValue))
    } catch let error {
        continuation.pointee.resume(throwing: error)
    }
}
fileprivate func uniffiFutureCallbackHandlerTypeSearchUsersResultsTypeClientError(
    rawContinutation: UnsafeRawPointer,
    returnValue: RustBuffer,
    callStatus: RustCallStatus) {

    let continuation = rawContinutation.bindMemory(
        to: CheckedContinuation<SearchUsersResults, Error>.self,
        capacity: 1
    )

    do {
        try uniffiCheckCallStatus(callStatus: callStatus, errorHandler: FfiConverterTypeClientError.lift)
        continuation.pointee.resume(returning: try FfiConverterTypeSearchUsersResults.lift(returnValue))
    } catch let error {
        continuation.pointee.resume(throwing: error)
    }
}
fileprivate func uniffiFutureCallbackHandlerTypeSessionTypeClientError(
    rawContinutation: UnsafeRawPointer,
    returnValue: RustBuffer,
    callStatus: RustCallStatus) {

    let continuation = rawContinutation.bindMemory(
        to: CheckedContinuation<Session, Error>.self,
        capacity: 1
    )

    do {
        try uniffiCheckCallStatus(callStatus: callStatus, errorHandler: FfiConverterTypeClientError.lift)
        continuation.pointee.resume(returning: try FfiConverterTypeSession.lift(returnValue))
    } catch let error {
        continuation.pointee.resume(throwing: error)
    }
}
fileprivate func uniffiFutureCallbackHandlerTypeUserProfileTypeClientError(
    rawContinutation: UnsafeRawPointer,
    returnValue: RustBuffer,
    callStatus: RustCallStatus) {

    let continuation = rawContinutation.bindMemory(
        to: CheckedContinuation<UserProfile, Error>.self,
        capacity: 1
    )

    do {
        try uniffiCheckCallStatus(callStatus: callStatus, errorHandler: FfiConverterTypeClientError.lift)
        continuation.pointee.resume(returning: try FfiConverterTypeUserProfile.lift(returnValue))
    } catch let error {
        continuation.pointee.resume(throwing: error)
    }
}
fileprivate func uniffiFutureCallbackHandlerTypeMembership(
    rawContinutation: UnsafeRawPointer,
    returnValue: RustBuffer,
    callStatus: RustCallStatus) {

    let continuation = rawContinutation.bindMemory(
        to: CheckedContinuation<Membership, Error>.self,
        capacity: 1
    )

    do {
        try uniffiCheckCallStatus(callStatus: callStatus, errorHandler: nil)
        continuation.pointee.resume(returning: try FfiConverterTypeMembership.lift(returnValue))
    } catch let error {
        continuation.pointee.resume(throwing: error)
    }
}
fileprivate func uniffiFutureCallbackHandlerTypeMembershipState(
    rawContinutation: UnsafeRawPointer,
    returnValue: RustBuffer,
    callStatus: RustCallStatus) {

    let continuation = rawContinutation.bindMemory(
        to: CheckedContinuation<MembershipState, Error>.self,
        capacity: 1
    )

    do {
        try uniffiCheckCallStatus(callStatus: callStatus, errorHandler: nil)
        continuation.pointee.resume(returning: try FfiConverterTypeMembershipState.lift(returnValue))
    } catch let error {
        continuation.pointee.resume(throwing: error)
    }
}
fileprivate func uniffiFutureCallbackHandlerTypeProfileDetails(
    rawContinutation: UnsafeRawPointer,
    returnValue: RustBuffer,
    callStatus: RustCallStatus) {

    let continuation = rawContinutation.bindMemory(
        to: CheckedContinuation<ProfileDetails, Error>.self,
        capacity: 1
    )

    do {
        try uniffiCheckCallStatus(callStatus: callStatus, errorHandler: nil)
        continuation.pointee.resume(returning: try FfiConverterTypeProfileDetails.lift(returnValue))
    } catch let error {
        continuation.pointee.resume(throwing: error)
    }
}
fileprivate func uniffiFutureCallbackHandlerTypeRoomNotificationMode(
    rawContinutation: UnsafeRawPointer,
    returnValue: RustBuffer,
    callStatus: RustCallStatus) {

    let continuation = rawContinutation.bindMemory(
        to: CheckedContinuation<RoomNotificationMode, Error>.self,
        capacity: 1
    )

    do {
        try uniffiCheckCallStatus(callStatus: callStatus, errorHandler: nil)
        continuation.pointee.resume(returning: try FfiConverterTypeRoomNotificationMode.lift(returnValue))
    } catch let error {
        continuation.pointee.resume(throwing: error)
    }
}
fileprivate func uniffiFutureCallbackHandlerTypeTimelineChange(
    rawContinutation: UnsafeRawPointer,
    returnValue: RustBuffer,
    callStatus: RustCallStatus) {

    let continuation = rawContinutation.bindMemory(
        to: CheckedContinuation<TimelineChange, Error>.self,
        capacity: 1
    )

    do {
        try uniffiCheckCallStatus(callStatus: callStatus, errorHandler: nil)
        continuation.pointee.resume(returning: try FfiConverterTypeTimelineChange.lift(returnValue))
    } catch let error {
        continuation.pointee.resume(throwing: error)
    }
}
fileprivate func uniffiFutureCallbackHandlerTypeTimelineEventTypeTypeClientError(
    rawContinutation: UnsafeRawPointer,
    returnValue: RustBuffer,
    callStatus: RustCallStatus) {

    let continuation = rawContinutation.bindMemory(
        to: CheckedContinuation<TimelineEventType, Error>.self,
        capacity: 1
    )

    do {
        try uniffiCheckCallStatus(callStatus: callStatus, errorHandler: FfiConverterTypeClientError.lift)
        continuation.pointee.resume(returning: try FfiConverterTypeTimelineEventType.lift(returnValue))
    } catch let error {
        continuation.pointee.resume(throwing: error)
    }
}
fileprivate func uniffiFutureCallbackHandlerTypeTimelineItemContentKind(
    rawContinutation: UnsafeRawPointer,
    returnValue: RustBuffer,
    callStatus: RustCallStatus) {

    let continuation = rawContinutation.bindMemory(
        to: CheckedContinuation<TimelineItemContentKind, Error>.self,
        capacity: 1
    )

    do {
        try uniffiCheckCallStatus(callStatus: callStatus, errorHandler: nil)
        continuation.pointee.resume(returning: try FfiConverterTypeTimelineItemContentKind.lift(returnValue))
    } catch let error {
        continuation.pointee.resume(throwing: error)
    }
}
fileprivate func uniffiFutureCallbackHandlerOptionUInt32(
    rawContinutation: UnsafeRawPointer,
    returnValue: RustBuffer,
    callStatus: RustCallStatus) {

    let continuation = rawContinutation.bindMemory(
        to: CheckedContinuation<UInt32?, Error>.self,
        capacity: 1
    )

    do {
        try uniffiCheckCallStatus(callStatus: callStatus, errorHandler: nil)
        continuation.pointee.resume(returning: try FfiConverterOptionUInt32.lift(returnValue))
    } catch let error {
        continuation.pointee.resume(throwing: error)
    }
}
fileprivate func uniffiFutureCallbackHandlerOptionString(
    rawContinutation: UnsafeRawPointer,
    returnValue: RustBuffer,
    callStatus: RustCallStatus) {

    let continuation = rawContinutation.bindMemory(
        to: CheckedContinuation<String?, Error>.self,
        capacity: 1
    )

    do {
        try uniffiCheckCallStatus(callStatus: callStatus, errorHandler: nil)
        continuation.pointee.resume(returning: try FfiConverterOptionString.lift(returnValue))
    } catch let error {
        continuation.pointee.resume(throwing: error)
    }
}
fileprivate func uniffiFutureCallbackHandlerOptionStringTypeClientError(
    rawContinutation: UnsafeRawPointer,
    returnValue: RustBuffer,
    callStatus: RustCallStatus) {

    let continuation = rawContinutation.bindMemory(
        to: CheckedContinuation<String?, Error>.self,
        capacity: 1
    )

    do {
        try uniffiCheckCallStatus(callStatus: callStatus, errorHandler: FfiConverterTypeClientError.lift)
        continuation.pointee.resume(returning: try FfiConverterOptionString.lift(returnValue))
    } catch let error {
        continuation.pointee.resume(throwing: error)
    }
}
fileprivate func uniffiFutureCallbackHandlerOptionTypeEventTimelineItem(
    rawContinutation: UnsafeRawPointer,
    returnValue: RustBuffer,
    callStatus: RustCallStatus) {

    let continuation = rawContinutation.bindMemory(
        to: CheckedContinuation<EventTimelineItem?, Error>.self,
        capacity: 1
    )

    do {
        try uniffiCheckCallStatus(callStatus: callStatus, errorHandler: nil)
        continuation.pointee.resume(returning: try FfiConverterOptionTypeEventTimelineItem.lift(returnValue))
    } catch let error {
        continuation.pointee.resume(throwing: error)
    }
}
fileprivate func uniffiFutureCallbackHandlerOptionTypeHomeserverLoginDetails(
    rawContinutation: UnsafeRawPointer,
    returnValue: RustBuffer,
    callStatus: RustCallStatus) {

    let continuation = rawContinutation.bindMemory(
        to: CheckedContinuation<HomeserverLoginDetails?, Error>.self,
        capacity: 1
    )

    do {
        try uniffiCheckCallStatus(callStatus: callStatus, errorHandler: nil)
        continuation.pointee.resume(returning: try FfiConverterOptionTypeHomeserverLoginDetails.lift(returnValue))
    } catch let error {
        continuation.pointee.resume(throwing: error)
    }
}
fileprivate func uniffiFutureCallbackHandlerOptionTypeMessage(
    rawContinutation: UnsafeRawPointer,
    returnValue: RustBuffer,
    callStatus: RustCallStatus) {

    let continuation = rawContinutation.bindMemory(
        to: CheckedContinuation<Message?, Error>.self,
        capacity: 1
    )

    do {
        try uniffiCheckCallStatus(callStatus: callStatus, errorHandler: nil)
        continuation.pointee.resume(returning: try FfiConverterOptionTypeMessage.lift(returnValue))
    } catch let error {
        continuation.pointee.resume(throwing: error)
    }
}
fileprivate func uniffiFutureCallbackHandlerOptionTypeRoomTypeClientError(
    rawContinutation: UnsafeRawPointer,
    returnValue: RustBuffer,
    callStatus: RustCallStatus) {

    let continuation = rawContinutation.bindMemory(
        to: CheckedContinuation<Room?, Error>.self,
        capacity: 1
    )

    do {
        try uniffiCheckCallStatus(callStatus: callStatus, errorHandler: FfiConverterTypeClientError.lift)
        continuation.pointee.resume(returning: try FfiConverterOptionTypeRoom.lift(returnValue))
    } catch let error {
        continuation.pointee.resume(throwing: error)
    }
}
fileprivate func uniffiFutureCallbackHandlerOptionTypeRoomMember(
    rawContinutation: UnsafeRawPointer,
    returnValue: RustBuffer,
    callStatus: RustCallStatus) {

    let continuation = rawContinutation.bindMemory(
        to: CheckedContinuation<RoomMember?, Error>.self,
        capacity: 1
    )

    do {
        try uniffiCheckCallStatus(callStatus: callStatus, errorHandler: nil)
        continuation.pointee.resume(returning: try FfiConverterOptionTypeRoomMember.lift(returnValue))
    } catch let error {
        continuation.pointee.resume(throwing: error)
    }
}
fileprivate func uniffiFutureCallbackHandlerOptionTypeTimelineItem(
    rawContinutation: UnsafeRawPointer,
    returnValue: RustBuffer,
    callStatus: RustCallStatus) {

    let continuation = rawContinutation.bindMemory(
        to: CheckedContinuation<TimelineItem?, Error>.self,
        capacity: 1
    )

    do {
        try uniffiCheckCallStatus(callStatus: callStatus, errorHandler: nil)
        continuation.pointee.resume(returning: try FfiConverterOptionTypeTimelineItem.lift(returnValue))
    } catch let error {
        continuation.pointee.resume(throwing: error)
    }
}
fileprivate func uniffiFutureCallbackHandlerOptionTypeInReplyToDetails(
    rawContinutation: UnsafeRawPointer,
    returnValue: RustBuffer,
    callStatus: RustCallStatus) {

    let continuation = rawContinutation.bindMemory(
        to: CheckedContinuation<InReplyToDetails?, Error>.self,
        capacity: 1
    )

    do {
        try uniffiCheckCallStatus(callStatus: callStatus, errorHandler: nil)
        continuation.pointee.resume(returning: try FfiConverterOptionTypeInReplyToDetails.lift(returnValue))
    } catch let error {
        continuation.pointee.resume(throwing: error)
    }
}
fileprivate func uniffiFutureCallbackHandlerOptionTypeInsertData(
    rawContinutation: UnsafeRawPointer,
    returnValue: RustBuffer,
    callStatus: RustCallStatus) {

    let continuation = rawContinutation.bindMemory(
        to: CheckedContinuation<InsertData?, Error>.self,
        capacity: 1
    )

    do {
        try uniffiCheckCallStatus(callStatus: callStatus, errorHandler: nil)
        continuation.pointee.resume(returning: try FfiConverterOptionTypeInsertData.lift(returnValue))
    } catch let error {
        continuation.pointee.resume(throwing: error)
    }
}
fileprivate func uniffiFutureCallbackHandlerOptionTypeNotificationItemTypeClientError(
    rawContinutation: UnsafeRawPointer,
    returnValue: RustBuffer,
    callStatus: RustCallStatus) {

    let continuation = rawContinutation.bindMemory(
        to: CheckedContinuation<NotificationItem?, Error>.self,
        capacity: 1
    )

    do {
        try uniffiCheckCallStatus(callStatus: callStatus, errorHandler: FfiConverterTypeClientError.lift)
        continuation.pointee.resume(returning: try FfiConverterOptionTypeNotificationItem.lift(returnValue))
    } catch let error {
        continuation.pointee.resume(throwing: error)
    }
}
fileprivate func uniffiFutureCallbackHandlerOptionTypeSetData(
    rawContinutation: UnsafeRawPointer,
    returnValue: RustBuffer,
    callStatus: RustCallStatus) {

    let continuation = rawContinutation.bindMemory(
        to: CheckedContinuation<SetData?, Error>.self,
        capacity: 1
    )

    do {
        try uniffiCheckCallStatus(callStatus: callStatus, errorHandler: nil)
        continuation.pointee.resume(returning: try FfiConverterOptionTypeSetData.lift(returnValue))
    } catch let error {
        continuation.pointee.resume(throwing: error)
    }
}
fileprivate func uniffiFutureCallbackHandlerOptionTypeEventItemOrigin(
    rawContinutation: UnsafeRawPointer,
    returnValue: RustBuffer,
    callStatus: RustCallStatus) {

    let continuation = rawContinutation.bindMemory(
        to: CheckedContinuation<EventItemOrigin?, Error>.self,
        capacity: 1
    )

    do {
        try uniffiCheckCallStatus(callStatus: callStatus, errorHandler: nil)
        continuation.pointee.resume(returning: try FfiConverterOptionTypeEventItemOrigin.lift(returnValue))
    } catch let error {
        continuation.pointee.resume(throwing: error)
    }
}
fileprivate func uniffiFutureCallbackHandlerOptionTypeEventSendState(
    rawContinutation: UnsafeRawPointer,
    returnValue: RustBuffer,
    callStatus: RustCallStatus) {

    let continuation = rawContinutation.bindMemory(
        to: CheckedContinuation<EventSendState?, Error>.self,
        capacity: 1
    )

    do {
        try uniffiCheckCallStatus(callStatus: callStatus, errorHandler: nil)
        continuation.pointee.resume(returning: try FfiConverterOptionTypeEventSendState.lift(returnValue))
    } catch let error {
        continuation.pointee.resume(throwing: error)
    }
}
fileprivate func uniffiFutureCallbackHandlerOptionTypeMessageType(
    rawContinutation: UnsafeRawPointer,
    returnValue: RustBuffer,
    callStatus: RustCallStatus) {

    let continuation = rawContinutation.bindMemory(
        to: CheckedContinuation<MessageType?, Error>.self,
        capacity: 1
    )

    do {
        try uniffiCheckCallStatus(callStatus: callStatus, errorHandler: nil)
        continuation.pointee.resume(returning: try FfiConverterOptionTypeMessageType.lift(returnValue))
    } catch let error {
        continuation.pointee.resume(throwing: error)
    }
}
fileprivate func uniffiFutureCallbackHandlerOptionTypeRoomNotificationModeTypeNotificationSettingsError(
    rawContinutation: UnsafeRawPointer,
    returnValue: RustBuffer,
    callStatus: RustCallStatus) {

    let continuation = rawContinutation.bindMemory(
        to: CheckedContinuation<RoomNotificationMode?, Error>.self,
        capacity: 1
    )

    do {
        try uniffiCheckCallStatus(callStatus: callStatus, errorHandler: FfiConverterTypeNotificationSettingsError.lift)
        continuation.pointee.resume(returning: try FfiConverterOptionTypeRoomNotificationMode.lift(returnValue))
    } catch let error {
        continuation.pointee.resume(throwing: error)
    }
}
fileprivate func uniffiFutureCallbackHandlerOptionTypeVirtualTimelineItem(
    rawContinutation: UnsafeRawPointer,
    returnValue: RustBuffer,
    callStatus: RustCallStatus) {

    let continuation = rawContinutation.bindMemory(
        to: CheckedContinuation<VirtualTimelineItem?, Error>.self,
        capacity: 1
    )

    do {
        try uniffiCheckCallStatus(callStatus: callStatus, errorHandler: nil)
        continuation.pointee.resume(returning: try FfiConverterOptionTypeVirtualTimelineItem.lift(returnValue))
    } catch let error {
        continuation.pointee.resume(throwing: error)
    }
}
fileprivate func uniffiFutureCallbackHandlerOptionSequenceTypeTimelineItem(
    rawContinutation: UnsafeRawPointer,
    returnValue: RustBuffer,
    callStatus: RustCallStatus) {

    let continuation = rawContinutation.bindMemory(
        to: CheckedContinuation<[TimelineItem]?, Error>.self,
        capacity: 1
    )

    do {
        try uniffiCheckCallStatus(callStatus: callStatus, errorHandler: nil)
        continuation.pointee.resume(returning: try FfiConverterOptionSequenceTypeTimelineItem.lift(returnValue))
    } catch let error {
        continuation.pointee.resume(throwing: error)
    }
}
fileprivate func uniffiFutureCallbackHandlerSequenceUInt8TypeClientError(
    rawContinutation: UnsafeRawPointer,
    returnValue: RustBuffer,
    callStatus: RustCallStatus) {

    let continuation = rawContinutation.bindMemory(
        to: CheckedContinuation<[UInt8], Error>.self,
        capacity: 1
    )

    do {
        try uniffiCheckCallStatus(callStatus: callStatus, errorHandler: FfiConverterTypeClientError.lift)
        continuation.pointee.resume(returning: try FfiConverterSequenceUInt8.lift(returnValue))
    } catch let error {
        continuation.pointee.resume(throwing: error)
    }
}
fileprivate func uniffiFutureCallbackHandlerSequenceString(
    rawContinutation: UnsafeRawPointer,
    returnValue: RustBuffer,
    callStatus: RustCallStatus) {

    let continuation = rawContinutation.bindMemory(
        to: CheckedContinuation<[String], Error>.self,
        capacity: 1
    )

    do {
        try uniffiCheckCallStatus(callStatus: callStatus, errorHandler: nil)
        continuation.pointee.resume(returning: try FfiConverterSequenceString.lift(returnValue))
    } catch let error {
        continuation.pointee.resume(throwing: error)
    }
}
fileprivate func uniffiFutureCallbackHandlerSequenceTypeRoom(
    rawContinutation: UnsafeRawPointer,
    returnValue: RustBuffer,
    callStatus: RustCallStatus) {

    let continuation = rawContinutation.bindMemory(
        to: CheckedContinuation<[Room], Error>.self,
        capacity: 1
    )

    do {
        try uniffiCheckCallStatus(callStatus: callStatus, errorHandler: nil)
        continuation.pointee.resume(returning: try FfiConverterSequenceTypeRoom.lift(returnValue))
    } catch let error {
        continuation.pointee.resume(throwing: error)
    }
}
fileprivate func uniffiFutureCallbackHandlerSequenceTypeRoomMemberTypeClientError(
    rawContinutation: UnsafeRawPointer,
    returnValue: RustBuffer,
    callStatus: RustCallStatus) {

    let continuation = rawContinutation.bindMemory(
        to: CheckedContinuation<[RoomMember], Error>.self,
        capacity: 1
    )

    do {
        try uniffiCheckCallStatus(callStatus: callStatus, errorHandler: FfiConverterTypeClientError.lift)
        continuation.pointee.resume(returning: try FfiConverterSequenceTypeRoomMember.lift(returnValue))
    } catch let error {
        continuation.pointee.resume(throwing: error)
    }
}
fileprivate func uniffiFutureCallbackHandlerSequenceTypeReaction(
    rawContinutation: UnsafeRawPointer,
    returnValue: RustBuffer,
    callStatus: RustCallStatus) {

    let continuation = rawContinutation.bindMemory(
        to: CheckedContinuation<[Reaction], Error>.self,
        capacity: 1
    )

    do {
        try uniffiCheckCallStatus(callStatus: callStatus, errorHandler: nil)
        continuation.pointee.resume(returning: try FfiConverterSequenceTypeReaction.lift(returnValue))
    } catch let error {
        continuation.pointee.resume(throwing: error)
    }
}
fileprivate func uniffiFutureCallbackHandlerDictionaryStringTypeReceipt(
    rawContinutation: UnsafeRawPointer,
    returnValue: RustBuffer,
    callStatus: RustCallStatus) {

    let continuation = rawContinutation.bindMemory(
        to: CheckedContinuation<[String: Receipt], Error>.self,
        capacity: 1
    )

    do {
        try uniffiCheckCallStatus(callStatus: callStatus, errorHandler: nil)
        continuation.pointee.resume(returning: try FfiConverterDictionaryStringTypeReceipt.lift(returnValue))
    } catch let error {
        continuation.pointee.resume(throwing: error)
    }
}

public func genTransactionId()  -> String {
    return try!  FfiConverterString.lift(
        try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_func_gen_transaction_id($0)
}
    )
}

public func logEvent(file: String, line: UInt32?, level: LogLevel, target: String, message: String)  {
    try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_func_log_event(
        FfiConverterString.lower(file),
        FfiConverterOptionUInt32.lower(line),
        FfiConverterTypeLogLevel.lower(level),
        FfiConverterString.lower(target),
        FfiConverterString.lower(message),$0)
}
}



public func mediaSourceFromUrl(url: String)  -> MediaSource {
    return try!  FfiConverterTypeMediaSource.lift(
        try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_func_media_source_from_url(
        FfiConverterString.lower(url),$0)
}
    )
}

public func messageEventContentFromHtml(body: String, htmlBody: String)  -> RoomMessageEventContentWithoutRelation {
    return try!  FfiConverterTypeRoomMessageEventContentWithoutRelation.lift(
        try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_func_message_event_content_from_html(
        FfiConverterString.lower(body),
        FfiConverterString.lower(htmlBody),$0)
}
    )
}

public func messageEventContentFromMarkdown(md: String)  -> RoomMessageEventContentWithoutRelation {
    return try!  FfiConverterTypeRoomMessageEventContentWithoutRelation.lift(
        try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_func_message_event_content_from_markdown(
        FfiConverterString.lower(md),$0)
}
    )
}

public func messageEventContentNew(msgtype: MessageType)  -> RoomMessageEventContentWithoutRelation {
    return try!  FfiConverterTypeRoomMessageEventContentWithoutRelation.lift(
        try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_func_message_event_content_new(
        FfiConverterTypeMessageType.lower(msgtype),$0)
}
    )
}

public func runWidgetApi(room: Room, widget: Widget, permissionsProvider: WidgetPermissionsProvider) async  {
    var continuation: CheckedContinuation<(), Error>? = nil
    // Suspend the function and call the scaffolding function, passing it a callback handler from
    // `AsyncTypes.swift`
    //
    // Make sure to hold on to a reference to the continuation in the top-level scope so that
    // it's not freed before the callback is invoked.
    return try!  await withCheckedThrowingContinuation {
        continuation = $0
        try! rustCall() {
            uniffi_matrix_sdk_ffi_fn_func_run_widget_api(
                
        FfiConverterTypeRoom.lower(room),
        FfiConverterTypeWidget.lower(widget),
        FfiConverterCallbackInterfaceWidgetPermissionsProvider.lower(permissionsProvider),
                FfiConverterForeignExecutor.lower(UniFfiForeignExecutor()),
                uniffiFutureCallbackHandlerVoid,
                &continuation,
                $0
            )
        }
    }
}



public func sdkGitSha()  -> String {
    return try!  FfiConverterString.lift(
        try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_func_sdk_git_sha($0)
}
    )
}

public func setupOtlpTracing(config: OtlpTracingConfiguration)  {
    try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_func_setup_otlp_tracing(
        FfiConverterTypeOtlpTracingConfiguration.lower(config),$0)
}
}



public func setupTracing(config: TracingConfiguration)  {
    try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_func_setup_tracing(
        FfiConverterTypeTracingConfiguration.lower(config),$0)
}
}



private enum InitializationResult {
    case ok
    case contractVersionMismatch
    case apiChecksumMismatch
}
// Use a global variables to perform the versioning checks. Swift ensures that
// the code inside is only computed once.
private var initializationResult: InitializationResult {
    // Get the bindings contract version from our ComponentInterface
    let bindings_contract_version = 23
    // Get the scaffolding contract version by calling the into the dylib
    let scaffolding_contract_version = ffi_matrix_sdk_ffi_uniffi_contract_version()
    if bindings_contract_version != scaffolding_contract_version {
        return InitializationResult.contractVersionMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_func_gen_transaction_id() != 65533) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_func_log_event() != 58164) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_func_media_source_from_url() != 28929) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_func_message_event_content_from_html() != 48173) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_func_message_event_content_from_markdown() != 5412) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_func_message_event_content_new() != 65448) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_func_run_widget_api() != 39210) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_func_sdk_git_sha() != 11183) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_func_setup_otlp_tracing() != 57774) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_func_setup_tracing() != 48899) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_mediasource_to_json() != 2998) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_mediasource_url() != 34026) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_authenticationservice_configure_homeserver() != 20936) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_authenticationservice_homeserver_details() != 30828) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_authenticationservice_login() != 4340) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_authenticationservice_login_with_oidc_callback() != 25443) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_authenticationservice_url_for_oidc_login() != 6390) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_client_account_data() != 37263) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_client_account_url() != 29423) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_client_avatar_url() != 13474) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_client_cached_avatar_url() != 47976) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_client_create_room() != 9095) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_client_device_id() != 30759) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_client_display_name() != 57766) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_client_get_dm_room() != 2581) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_client_get_media_content() != 25167) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_client_get_media_file() != 23010) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_client_get_media_thumbnail() != 51889) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_client_get_notification_settings() != 43752) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_client_get_profile() != 11465) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_client_get_session_verification_controller() != 25701) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_client_homeserver() != 509) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_client_ignore_user() != 53606) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_client_login() != 62785) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_client_logout() != 16841) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_client_notification_client() != 43839) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_client_restore_session() != 19558) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_client_rooms() != 61954) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_client_search_users() != 1362) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_client_session() != 56470) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_client_set_account_data() != 32949) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_client_set_delegate() != 32036) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_client_set_display_name() != 45786) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_client_set_pusher() != 9540) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_client_sync_service() != 55738) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_client_unignore_user() != 6043) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_client_upload_media() != 20769) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_client_user_id() != 55803) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_base_path() != 13781) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_build() != 56797) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_disable_automatic_token_refresh() != 50220) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_disable_ssl_verification() != 1510) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_homeserver_url() != 43790) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_passphrase() != 25291) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_proxy() != 61852) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_server_name() != 46252) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_server_versions() != 64538) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_sliding_sync_proxy() != 37450) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_user_agent() != 42913) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_username() != 64379) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_eventtimelineitem_content() != 1802) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_eventtimelineitem_debug_info() != 45087) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_eventtimelineitem_event_id() != 57306) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_eventtimelineitem_is_editable() != 593) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_eventtimelineitem_is_local() != 47845) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_eventtimelineitem_is_own() != 18359) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_eventtimelineitem_is_remote() != 17688) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_eventtimelineitem_local_send_state() != 22720) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_eventtimelineitem_origin() != 28263) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_eventtimelineitem_reactions() != 64143) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_eventtimelineitem_read_receipts() != 40784) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_eventtimelineitem_sender() != 46892) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_eventtimelineitem_sender_profile() != 42856) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_eventtimelineitem_timestamp() != 481) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_eventtimelineitem_transaction_id() != 36352) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_homeserverlogindetails_supports_oidc_login() != 51854) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_homeserverlogindetails_supports_password_login() != 6028) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_homeserverlogindetails_url() != 40398) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_mediafilehandle_path() != 57070) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_message_body() != 2560) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_message_in_reply_to() != 1793) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_message_is_edited() != 3402) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_message_msgtype() != 50686) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_notificationclient_get_notification() != 9907) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_notificationclientbuilder_filter_by_push_rules() != 10529) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_notificationclientbuilder_finish() != 12382) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_notificationclientbuilder_retry_decryption() != 12777) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_contains_keywords_rules() != 42972) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_get_default_room_notification_mode() != 7288) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_get_room_notification_settings() != 654) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_get_rooms_with_user_defined_rules() != 687) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_get_user_defined_room_notification_mode() != 40224) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_is_call_enabled() != 38110) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_is_room_mention_enabled() != 36336) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_is_user_mention_enabled() != 9844) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_restore_default_room_notification_mode() != 43578) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_set_call_enabled() != 61774) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_set_default_room_notification_mode() != 64886) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_set_delegate() != 22622) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_set_room_mention_enabled() != 50730) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_set_room_notification_mode() != 21294) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_set_user_mention_enabled() != 63345) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_unmute_room() != 33146) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_oidcauthenticationdata_login_url() != 2455) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_active_members_count() != 62367) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_add_timeline_listener() != 43137) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_alternative_aliases() != 25219) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_avatar_url() != 38267) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_can_user_ban() != 47371) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_can_user_invite() != 62419) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_can_user_kick() != 47687) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_can_user_redact() != 54334) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_can_user_send_message() != 28210) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_can_user_send_state() != 54763) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_can_user_trigger_room_notification() != 8288) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_cancel_send() != 22141) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_canonical_alias() != 15084) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_create_poll() != 5532) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_display_name() != 38216) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_edit() != 35232) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_end_poll() != 8937) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_fetch_details_for_event() != 23233) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_fetch_members() != 63440) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_get_timeline_event_content_by_event_id() != 4338) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_id() != 27132) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_ignore_user() != 9941) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_invite_user_by_id() != 12569) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_invited_members_count() != 31452) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_inviter() != 8327) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_is_direct() != 46881) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_is_encrypted() != 29418) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_is_public() != 22937) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_is_space() != 8495) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_is_tombstoned() != 55887) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_join() != 4883) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_joined_members_count() != 44345) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_leave() != 11928) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_member() != 19441) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_member_avatar_url() != 5937) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_member_display_name() != 4559) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_members() != 48203) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_membership() != 17678) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_name() != 58791) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_own_user_id() != 26241) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_paginate_backwards() != 28035) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_redact() != 61747) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_remove_avatar() != 24698) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_remove_timeline() != 13720) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_report_content() != 58629) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_retry_decryption() != 17014) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_retry_send() != 39997) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_room_info() != 45186) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_send() != 39033) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_send_audio() != 19498) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_send_file() != 54377) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_send_image() != 56510) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_send_location() != 43614) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_send_poll_response() != 1386) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_send_read_marker() != 53306) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_send_read_receipt() != 6919) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_send_reply() != 58749) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_send_video() != 38775) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_set_name() != 39725) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_set_topic() != 55348) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_subscribe_to_back_pagination_status() != 27757) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_subscribe_to_room_info_updates() != 43609) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_toggle_reaction() != 25672) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_topic() != 23413) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_upload_avatar() != 33347) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_roomlist_entries() != 27911) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_roomlist_entries_with_dynamic_filter() != 18327) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_roomlist_loading_state() != 54823) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_roomlist_room() != 60000) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_roomlistentriesdynamicfilter_set() != 41193) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_roomlistitem_avatar_url() != 23609) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_roomlistitem_canonical_alias() != 56187) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_roomlistitem_full_room() != 50213) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_roomlistitem_has_unread_notifications() != 64858) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_roomlistitem_id() != 35737) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_roomlistitem_is_direct() != 24829) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_roomlistitem_latest_event() != 44019) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_roomlistitem_name() != 5949) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_roomlistitem_room_info() != 17731) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_roomlistitem_subscribe() != 16638) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_roomlistitem_unread_notifications() != 36955) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_roomlistitem_unsubscribe() != 14844) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_roomlistservice_all_rooms() != 37160) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_roomlistservice_apply_input() != 46775) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_roomlistservice_invites() != 56087) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_roomlistservice_room() != 48446) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_roomlistservice_state() != 7038) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_roommember_avatar_url() != 9148) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_roommember_can_ban() != 19267) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_roommember_can_invite() != 36172) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_roommember_can_kick() != 31109) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_roommember_can_redact() != 49727) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_roommember_can_send_message() != 14989) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_roommember_can_send_state() != 43889) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_roommember_can_trigger_room_notification() != 62393) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_roommember_display_name() != 28367) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_roommember_ignore() != 32455) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_roommember_is_account_user() != 37767) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_roommember_is_ignored() != 46154) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_roommember_is_name_ambiguous() != 65246) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_roommember_membership() != 34335) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_roommember_normalized_power_level() != 49076) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_roommember_power_level() != 17042) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_roommember_unignore() != 56817) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_roommember_user_id() != 19498) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_sendattachmentjoinhandle_cancel() != 58929) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_sendattachmentjoinhandle_join() != 25237) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_sessionverificationcontroller_approve_verification() != 468) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_sessionverificationcontroller_cancel_verification() != 63679) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_sessionverificationcontroller_decline_verification() != 50627) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_sessionverificationcontroller_is_verified() != 949) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_sessionverificationcontroller_request_verification() != 51679) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_sessionverificationcontroller_set_delegate() != 24735) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_sessionverificationcontroller_start_sas_verification() != 3726) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_sessionverificationemoji_description() != 55458) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_sessionverificationemoji_symbol() != 1848) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_span_enter() != 56663) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_span_exit() != 6123) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_span_is_none() != 23839) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_syncservice_room_list_service() != 18295) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_syncservice_start() != 4435) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_syncservice_state() != 15048) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_syncservice_stop() != 39770) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_syncservicebuilder_finish() != 61604) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_syncservicebuilder_with_encryption_sync() != 35198) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_taskhandle_cancel() != 59047) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_taskhandle_is_finished() != 3905) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_timelinediff_append() != 24298) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_timelinediff_change() != 50296) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_timelinediff_insert() != 10002) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_timelinediff_push_back() != 35483) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_timelinediff_push_front() != 40108) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_timelinediff_remove() != 13408) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_timelinediff_reset() != 34789) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_timelinediff_set() != 45340) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_timelineevent_event_id() != 20444) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_timelineevent_event_type() != 52643) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_timelineevent_sender_id() != 9141) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_timelineevent_timestamp() != 30335) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_timelineitem_as_event() != 755) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_timelineitem_as_virtual() != 10265) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_timelineitem_fmt_debug() != 25731) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_timelineitem_unique_id() != 27999) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_timelineitemcontent_as_message() != 58545) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_timelineitemcontent_kind() != 60128) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_unreadnotificationscount_has_notifications() != 38874) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_unreadnotificationscount_highlight_count() != 30763) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_unreadnotificationscount_notification_count() != 10233) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_constructor_mediasource_from_json() != 31512) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_constructor_authenticationservice_new() != 62706) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_constructor_clientbuilder_new() != 53567) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_constructor_span_current() != 47163) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_constructor_span_new() != 47854) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_backpaginationstatuslistener_on_update() != 2582) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_clientdelegate_did_receive_auth_error() != 54393) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_clientdelegate_did_refresh_tokens() != 32841) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_notificationsettingsdelegate_settings_did_change() != 4921) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_progresswatcher_transmission_progress() != 12165) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_roominfolistener_call() != 567) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_roomlistentrieslistener_on_update() != 36351) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_roomlistloadingstatelistener_on_update() != 53567) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_roomlistservicestatelistener_on_update() != 27905) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_sessionverificationcontrollerdelegate_did_accept_verification_request() != 59777) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_sessionverificationcontrollerdelegate_did_start_sas_verification() != 15715) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_sessionverificationcontrollerdelegate_did_receive_verification_data() != 46941) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_sessionverificationcontrollerdelegate_did_fail() != 52235) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_sessionverificationcontrollerdelegate_did_cancel() != 52154) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_sessionverificationcontrollerdelegate_did_finish() != 45558) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_syncservicestateobserver_on_update() != 52830) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_timelinelistener_on_update() != 974) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_widgetpermissionsprovider_acquire_permissions() != 21463) {
        return InitializationResult.apiChecksumMismatch
    }

    uniffiInitForeignExecutor()
    return InitializationResult.ok
}

private func uniffiEnsureInitialized() {
    switch initializationResult {
    case .ok:
        break
    case .contractVersionMismatch:
        fatalError("UniFFI contract version mismatch: try cleaning and rebuilding your project")
    case .apiChecksumMismatch:
        fatalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
}