// This file was autogenerated by some hot garbage in the `uniffi` crate.
// Trust me, you don't want to mess with it!
import Foundation

// Depending on the consumer's build setup, the low-level FFI code
// might be in a separate module, or it might be compiled inline into
// this module. This is a bit of light hackery to work with both.
#if canImport(matrix_sdk_ffiFFI)
import matrix_sdk_ffiFFI
#endif

fileprivate extension RustBuffer {
    // Allocate a new buffer, copying the contents of a `UInt8` array.
    init(bytes: [UInt8]) {
        let rbuf = bytes.withUnsafeBufferPointer { ptr in
            RustBuffer.from(ptr)
        }
        self.init(capacity: rbuf.capacity, len: rbuf.len, data: rbuf.data)
    }

    static func from(_ ptr: UnsafeBufferPointer<UInt8>) -> RustBuffer {
        try! rustCall { ffi_matrix_sdk_ffi_7e42_rustbuffer_from_bytes(ForeignBytes(bufferPointer: ptr), $0) }
    }

    // Frees the buffer in place.
    // The buffer must not be used after this is called.
    func deallocate() {
        try! rustCall { ffi_matrix_sdk_ffi_7e42_rustbuffer_free(self, $0) }
    }
}

fileprivate extension ForeignBytes {
    init(bufferPointer: UnsafeBufferPointer<UInt8>) {
        self.init(len: Int32(bufferPointer.count), data: bufferPointer.baseAddress)
    }
}

// For every type used in the interface, we provide helper methods for conveniently
// lifting and lowering that type from C-compatible data, and for reading and writing
// values of that type in a buffer.

// Helper classes/extensions that don't change.
// Someday, this will be in a library of its own.

fileprivate extension Data {
    init(rustBuffer: RustBuffer) {
        // TODO: This copies the buffer. Can we read directly from a
        // Rust buffer?
        self.init(bytes: rustBuffer.data!, count: Int(rustBuffer.len))
    }
}

// Define reader functionality.  Normally this would be defined in a class or
// struct, but we use standalone functions instead in order to make external
// types work.
//
// With external types, one swift source file needs to be able to call the read
// method on another source file's FfiConverter, but then what visibility
// should Reader have?
// - If Reader is fileprivate, then this means the read() must also
//   be fileprivate, which doesn't work with external types.
// - If Reader is internal/public, we'll get compile errors since both source
//   files will try define the same type.
//
// Instead, the read() method and these helper functions input a tuple of data

fileprivate func createReader(data: Data) -> (data: Data, offset: Data.Index) {
    (data: data, offset: 0)
}

// Reads an integer at the current offset, in big-endian order, and advances
// the offset on success. Throws if reading the integer would move the
// offset past the end of the buffer.
fileprivate func readInt<T: FixedWidthInteger>(_ reader: inout (data: Data, offset: Data.Index)) throws -> T {
    let range = reader.offset..<reader.offset + MemoryLayout<T>.size
    guard reader.data.count >= range.upperBound else {
        throw UniffiInternalError.bufferOverflow
    }
    if T.self == UInt8.self {
        let value = reader.data[reader.offset]
        reader.offset += 1
        return value as! T
    }
    var value: T = 0
    let _ = withUnsafeMutableBytes(of: &value, { reader.data.copyBytes(to: $0, from: range)})
    reader.offset = range.upperBound
    return value.bigEndian
}

// Reads an arbitrary number of bytes, to be used to read
// raw bytes, this is useful when lifting strings
fileprivate func readBytes(_ reader: inout (data: Data, offset: Data.Index), count: Int) throws -> Array<UInt8> {
    let range = reader.offset..<(reader.offset+count)
    guard reader.data.count >= range.upperBound else {
        throw UniffiInternalError.bufferOverflow
    }
    var value = [UInt8](repeating: 0, count: count)
    value.withUnsafeMutableBufferPointer({ buffer in
        reader.data.copyBytes(to: buffer, from: range)
    })
    reader.offset = range.upperBound
    return value
}

// Reads a float at the current offset.
fileprivate func readFloat(_ reader: inout (data: Data, offset: Data.Index)) throws -> Float {
    return Float(bitPattern: try readInt(&reader))
}

// Reads a float at the current offset.
fileprivate func readDouble(_ reader: inout (data: Data, offset: Data.Index)) throws -> Double {
    return Double(bitPattern: try readInt(&reader))
}

// Indicates if the offset has reached the end of the buffer.
fileprivate func hasRemaining(_ reader: (data: Data, offset: Data.Index)) -> Bool {
    return reader.offset < reader.data.count
}

// Define writer functionality.  Normally this would be defined in a class or
// struct, but we use standalone functions instead in order to make external
// types work.  See the above discussion on Readers for details.

fileprivate func createWriter() -> [UInt8] {
    return []
}

fileprivate func writeBytes<S>(_ writer: inout [UInt8], _ byteArr: S) where S: Sequence, S.Element == UInt8 {
    writer.append(contentsOf: byteArr)
}

// Writes an integer in big-endian order.
//
// Warning: make sure what you are trying to write
// is in the correct type!
fileprivate func writeInt<T: FixedWidthInteger>(_ writer: inout [UInt8], _ value: T) {
    var value = value.bigEndian
    withUnsafeBytes(of: &value) { writer.append(contentsOf: $0) }
}

fileprivate func writeFloat(_ writer: inout [UInt8], _ value: Float) {
    writeInt(&writer, value.bitPattern)
}

fileprivate func writeDouble(_ writer: inout [UInt8], _ value: Double) {
    writeInt(&writer, value.bitPattern)
}

// Protocol for types that transfer other types across the FFI. This is
// analogous go the Rust trait of the same name.
fileprivate protocol FfiConverter {
    associatedtype FfiType
    associatedtype SwiftType

    static func lift(_ value: FfiType) throws -> SwiftType
    static func lower(_ value: SwiftType) -> FfiType
    static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType
    static func write(_ value: SwiftType, into buf: inout [UInt8])
}

// Types conforming to `Primitive` pass themselves directly over the FFI.
fileprivate protocol FfiConverterPrimitive: FfiConverter where FfiType == SwiftType { }

extension FfiConverterPrimitive {
    public static func lift(_ value: FfiType) throws -> SwiftType {
        return value
    }

    public static func lower(_ value: SwiftType) -> FfiType {
        return value
    }
}

// Types conforming to `FfiConverterRustBuffer` lift and lower into a `RustBuffer`.
// Used for complex types where it's hard to write a custom lift/lower.
fileprivate protocol FfiConverterRustBuffer: FfiConverter where FfiType == RustBuffer {}

extension FfiConverterRustBuffer {
    public static func lift(_ buf: RustBuffer) throws -> SwiftType {
        var reader = createReader(data: Data(rustBuffer: buf))
        let value = try read(from: &reader)
        if hasRemaining(reader) {
            throw UniffiInternalError.incompleteData
        }
        buf.deallocate()
        return value
    }

    public static func lower(_ value: SwiftType) -> RustBuffer {
          var writer = createWriter()
          write(value, into: &writer)
          return RustBuffer(bytes: writer)
    }
}
// An error type for FFI errors. These errors occur at the UniFFI level, not
// the library level.
fileprivate enum UniffiInternalError: LocalizedError {
    case bufferOverflow
    case incompleteData
    case unexpectedOptionalTag
    case unexpectedEnumCase
    case unexpectedNullPointer
    case unexpectedRustCallStatusCode
    case unexpectedRustCallError
    case unexpectedStaleHandle
    case rustPanic(_ message: String)

    public var errorDescription: String? {
        switch self {
        case .bufferOverflow: return "Reading the requested value would read past the end of the buffer"
        case .incompleteData: return "The buffer still has data after lifting its containing value"
        case .unexpectedOptionalTag: return "Unexpected optional tag; should be 0 or 1"
        case .unexpectedEnumCase: return "Raw enum value doesn't match any cases"
        case .unexpectedNullPointer: return "Raw pointer value was null"
        case .unexpectedRustCallStatusCode: return "Unexpected RustCallStatus code"
        case .unexpectedRustCallError: return "CALL_ERROR but no errorClass specified"
        case .unexpectedStaleHandle: return "The object in the handle map has been dropped already"
        case let .rustPanic(message): return message
        }
    }
}

fileprivate let CALL_SUCCESS: Int8 = 0
fileprivate let CALL_ERROR: Int8 = 1
fileprivate let CALL_PANIC: Int8 = 2

fileprivate extension RustCallStatus {
    init() {
        self.init(
            code: CALL_SUCCESS,
            errorBuf: RustBuffer.init(
                capacity: 0,
                len: 0,
                data: nil
            )
        )
    }
}

private func rustCall<T>(_ callback: (UnsafeMutablePointer<RustCallStatus>) -> T) throws -> T {
    try makeRustCall(callback, errorHandler: {
        $0.deallocate()
        return UniffiInternalError.unexpectedRustCallError
    })
}

private func rustCallWithError<T, F: FfiConverter>
    (_ errorFfiConverter: F.Type, _ callback: (UnsafeMutablePointer<RustCallStatus>) -> T) throws -> T
    where F.SwiftType: Error, F.FfiType == RustBuffer
    {
    try makeRustCall(callback, errorHandler: { return try errorFfiConverter.lift($0) })
}

private func makeRustCall<T>(_ callback: (UnsafeMutablePointer<RustCallStatus>) -> T, errorHandler: (RustBuffer) throws -> Error) throws -> T {
    var callStatus = RustCallStatus.init()
    let returnedVal = callback(&callStatus)
    switch callStatus.code {
        case CALL_SUCCESS:
            return returnedVal

        case CALL_ERROR:
            throw try errorHandler(callStatus.errorBuf)

        case CALL_PANIC:
            // When the rust code sees a panic, it tries to construct a RustBuffer
            // with the message.  But if that code panics, then it just sends back
            // an empty buffer.
            if callStatus.errorBuf.len > 0 {
                throw UniffiInternalError.rustPanic(try FfiConverterString.lift(callStatus.errorBuf))
            } else {
                callStatus.errorBuf.deallocate()
                throw UniffiInternalError.rustPanic("Rust panic")
            }

        default:
            throw UniffiInternalError.unexpectedRustCallStatusCode
    }
}

// Public interface members begin here.


fileprivate struct FfiConverterUInt8: FfiConverterPrimitive {
    typealias FfiType = UInt8
    typealias SwiftType = UInt8

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt8 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: UInt8, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

fileprivate struct FfiConverterUInt16: FfiConverterPrimitive {
    typealias FfiType = UInt16
    typealias SwiftType = UInt16

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt16 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

fileprivate struct FfiConverterUInt32: FfiConverterPrimitive {
    typealias FfiType = UInt32
    typealias SwiftType = UInt32

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt32 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

fileprivate struct FfiConverterInt32: FfiConverterPrimitive {
    typealias FfiType = Int32
    typealias SwiftType = Int32

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Int32 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: Int32, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

fileprivate struct FfiConverterUInt64: FfiConverterPrimitive {
    typealias FfiType = UInt64
    typealias SwiftType = UInt64

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt64 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

fileprivate struct FfiConverterInt64: FfiConverterPrimitive {
    typealias FfiType = Int64
    typealias SwiftType = Int64

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Int64 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: Int64, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

fileprivate struct FfiConverterBool : FfiConverter {
    typealias FfiType = Int8
    typealias SwiftType = Bool

    public static func lift(_ value: Int8) throws -> Bool {
        return value != 0
    }

    public static func lower(_ value: Bool) -> Int8 {
        return value ? 1 : 0
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Bool {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: Bool, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

fileprivate struct FfiConverterString: FfiConverter {
    typealias SwiftType = String
    typealias FfiType = RustBuffer

    public static func lift(_ value: RustBuffer) throws -> String {
        defer {
            value.deallocate()
        }
        if value.data == nil {
            return String()
        }
        let bytes = UnsafeBufferPointer<UInt8>(start: value.data!, count: Int(value.len))
        return String(bytes: bytes, encoding: String.Encoding.utf8)!
    }

    public static func lower(_ value: String) -> RustBuffer {
        return value.utf8CString.withUnsafeBufferPointer { ptr in
            // The swift string gives us int8_t, we want uint8_t.
            ptr.withMemoryRebound(to: UInt8.self) { ptr in
                // The swift string gives us a trailing null byte, we don't want it.
                let buf = UnsafeBufferPointer(rebasing: ptr.prefix(upTo: ptr.count - 1))
                return RustBuffer.from(buf)
            }
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> String {
        let len: Int32 = try readInt(&buf)
        return String(bytes: try readBytes(&buf, count: Int(len)), encoding: String.Encoding.utf8)!
    }

    public static func write(_ value: String, into buf: inout [UInt8]) {
        let len = Int32(value.utf8.count)
        writeInt(&buf, len)
        writeBytes(&buf, value.utf8)
    }
}


public protocol AuthenticationServiceProtocol {
    func `configureHomeserver`(`serverNameOrHomeserverUrl`: String) throws
    func `homeserverDetails`()  -> HomeserverLoginDetails?
    func `login`(`username`: String, `password`: String, `initialDeviceName`: String?, `deviceId`: String?) throws -> Client
    func `restoreWithAccessToken`(`token`: String, `deviceId`: String) throws -> Client
    
}

public class AuthenticationService: AuthenticationServiceProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }
    public convenience init(`basePath`: String, `passphrase`: String?, `customSlidingSyncProxy`: String?)  {
        self.init(unsafeFromRawPointer: try!
    
    rustCall() {
    
    matrix_sdk_ffi_7e42_AuthenticationService_new(
        FfiConverterString.lower(`basePath`), 
        FfiConverterOptionString.lower(`passphrase`), 
        FfiConverterOptionString.lower(`customSlidingSyncProxy`), $0)
})
    }

    deinit {
        try! rustCall { ffi_matrix_sdk_ffi_7e42_AuthenticationService_object_free(pointer, $0) }
    }

    

    
    public func `configureHomeserver`(`serverNameOrHomeserverUrl`: String) throws {
        try
    rustCallWithError(FfiConverterTypeAuthenticationError.self) {
    _uniffi_matrix_sdk_ffi_impl_AuthenticationService_configure_homeserver_5456(self.pointer, 
        FfiConverterString.lower(`serverNameOrHomeserverUrl`), $0
    )
}
    }
    public func `homeserverDetails`()  -> HomeserverLoginDetails? {
        return try! FfiConverterOptionTypeHomeserverLoginDetails.lift(
            try!
    rustCall() {
    
    _uniffi_matrix_sdk_ffi_impl_AuthenticationService_homeserver_details_dd6a(self.pointer, $0
    )
}
        )
    }
    public func `login`(`username`: String, `password`: String, `initialDeviceName`: String?, `deviceId`: String?) throws -> Client {
        return try FfiConverterTypeClient.lift(
            try
    rustCallWithError(FfiConverterTypeAuthenticationError.self) {
    _uniffi_matrix_sdk_ffi_impl_AuthenticationService_login_fa49(self.pointer, 
        FfiConverterString.lower(`username`), 
        FfiConverterString.lower(`password`), 
        FfiConverterOptionString.lower(`initialDeviceName`), 
        FfiConverterOptionString.lower(`deviceId`), $0
    )
}
        )
    }
    public func `restoreWithAccessToken`(`token`: String, `deviceId`: String) throws -> Client {
        return try FfiConverterTypeClient.lift(
            try
    rustCallWithError(FfiConverterTypeAuthenticationError.self) {
    _uniffi_matrix_sdk_ffi_impl_AuthenticationService_restore_with_access_token_6783(self.pointer, 
        FfiConverterString.lower(`token`), 
        FfiConverterString.lower(`deviceId`), $0
    )
}
        )
    }
    
}


public struct FfiConverterTypeAuthenticationService: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = AuthenticationService

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AuthenticationService {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: AuthenticationService, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> AuthenticationService {
        return AuthenticationService(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: AuthenticationService) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}


public protocol ClientProtocol {
    func `setDelegate`(`delegate`: ClientDelegate?) 
    func `login`(`username`: String, `password`: String, `initialDeviceName`: String?, `deviceId`: String?) throws
    func `restoreSession`(`session`: Session) throws
    func `session`() throws -> Session
    func `userId`() throws -> String
    func `displayName`() throws -> String
    func `setDisplayName`(`name`: String) throws
    func `avatarUrl`() throws -> String
    func `deviceId`() throws -> String
    func `accountData`(`eventType`: String) throws -> String?
    func `setAccountData`(`eventType`: String, `content`: String) throws
    func `uploadMedia`(`mimeType`: String, `content`: [UInt8]) throws -> String
    func `getMediaContent`(`source`: MediaSource) throws -> [UInt8]
    func `getMediaThumbnail`(`source`: MediaSource, `width`: UInt64, `height`: UInt64) throws -> [UInt8]
    func `getSessionVerificationController`() throws -> SessionVerificationController
    func `fullSlidingSync`() throws -> SlidingSync
    func `logout`() throws
    func `hasFirstSynced`()  -> Bool
    func `homeserver`()  -> String
    func `isSoftLogout`()  -> Bool
    func `isSyncing`()  -> Bool
    func `rooms`()  -> [Room]
    func `slidingSync`()  -> SlidingSyncBuilder
    func `startSync`(`timelineLimit`: UInt16?) 
    
}

public class Client: ClientProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { ffi_matrix_sdk_ffi_7e42_Client_object_free(pointer, $0) }
    }

    

    
    public func `setDelegate`(`delegate`: ClientDelegate?)  {
        try!
    rustCall() {
    
    matrix_sdk_ffi_7e42_Client_set_delegate(self.pointer, 
        FfiConverterOptionCallbackInterfaceClientDelegate.lower(`delegate`), $0
    )
}
    }
    public func `login`(`username`: String, `password`: String, `initialDeviceName`: String?, `deviceId`: String?) throws {
        try
    rustCallWithError(FfiConverterTypeClientError.self) {
    matrix_sdk_ffi_7e42_Client_login(self.pointer, 
        FfiConverterString.lower(`username`), 
        FfiConverterString.lower(`password`), 
        FfiConverterOptionString.lower(`initialDeviceName`), 
        FfiConverterOptionString.lower(`deviceId`), $0
    )
}
    }
    public func `restoreSession`(`session`: Session) throws {
        try
    rustCallWithError(FfiConverterTypeClientError.self) {
    matrix_sdk_ffi_7e42_Client_restore_session(self.pointer, 
        FfiConverterTypeSession.lower(`session`), $0
    )
}
    }
    public func `session`() throws -> Session {
        return try FfiConverterTypeSession.lift(
            try
    rustCallWithError(FfiConverterTypeClientError.self) {
    matrix_sdk_ffi_7e42_Client_session(self.pointer, $0
    )
}
        )
    }
    public func `userId`() throws -> String {
        return try FfiConverterString.lift(
            try
    rustCallWithError(FfiConverterTypeClientError.self) {
    matrix_sdk_ffi_7e42_Client_user_id(self.pointer, $0
    )
}
        )
    }
    public func `displayName`() throws -> String {
        return try FfiConverterString.lift(
            try
    rustCallWithError(FfiConverterTypeClientError.self) {
    matrix_sdk_ffi_7e42_Client_display_name(self.pointer, $0
    )
}
        )
    }
    public func `setDisplayName`(`name`: String) throws {
        try
    rustCallWithError(FfiConverterTypeClientError.self) {
    matrix_sdk_ffi_7e42_Client_set_display_name(self.pointer, 
        FfiConverterString.lower(`name`), $0
    )
}
    }
    public func `avatarUrl`() throws -> String {
        return try FfiConverterString.lift(
            try
    rustCallWithError(FfiConverterTypeClientError.self) {
    matrix_sdk_ffi_7e42_Client_avatar_url(self.pointer, $0
    )
}
        )
    }
    public func `deviceId`() throws -> String {
        return try FfiConverterString.lift(
            try
    rustCallWithError(FfiConverterTypeClientError.self) {
    matrix_sdk_ffi_7e42_Client_device_id(self.pointer, $0
    )
}
        )
    }
    public func `accountData`(`eventType`: String) throws -> String? {
        return try FfiConverterOptionString.lift(
            try
    rustCallWithError(FfiConverterTypeClientError.self) {
    matrix_sdk_ffi_7e42_Client_account_data(self.pointer, 
        FfiConverterString.lower(`eventType`), $0
    )
}
        )
    }
    public func `setAccountData`(`eventType`: String, `content`: String) throws {
        try
    rustCallWithError(FfiConverterTypeClientError.self) {
    matrix_sdk_ffi_7e42_Client_set_account_data(self.pointer, 
        FfiConverterString.lower(`eventType`), 
        FfiConverterString.lower(`content`), $0
    )
}
    }
    public func `uploadMedia`(`mimeType`: String, `content`: [UInt8]) throws -> String {
        return try FfiConverterString.lift(
            try
    rustCallWithError(FfiConverterTypeClientError.self) {
    matrix_sdk_ffi_7e42_Client_upload_media(self.pointer, 
        FfiConverterString.lower(`mimeType`), 
        FfiConverterSequenceUInt8.lower(`content`), $0
    )
}
        )
    }
    public func `getMediaContent`(`source`: MediaSource) throws -> [UInt8] {
        return try FfiConverterSequenceUInt8.lift(
            try
    rustCallWithError(FfiConverterTypeClientError.self) {
    matrix_sdk_ffi_7e42_Client_get_media_content(self.pointer, 
        FfiConverterTypeMediaSource.lower(`source`), $0
    )
}
        )
    }
    public func `getMediaThumbnail`(`source`: MediaSource, `width`: UInt64, `height`: UInt64) throws -> [UInt8] {
        return try FfiConverterSequenceUInt8.lift(
            try
    rustCallWithError(FfiConverterTypeClientError.self) {
    matrix_sdk_ffi_7e42_Client_get_media_thumbnail(self.pointer, 
        FfiConverterTypeMediaSource.lower(`source`), 
        FfiConverterUInt64.lower(`width`), 
        FfiConverterUInt64.lower(`height`), $0
    )
}
        )
    }
    public func `getSessionVerificationController`() throws -> SessionVerificationController {
        return try FfiConverterTypeSessionVerificationController.lift(
            try
    rustCallWithError(FfiConverterTypeClientError.self) {
    matrix_sdk_ffi_7e42_Client_get_session_verification_controller(self.pointer, $0
    )
}
        )
    }
    public func `fullSlidingSync`() throws -> SlidingSync {
        return try FfiConverterTypeSlidingSync.lift(
            try
    rustCallWithError(FfiConverterTypeClientError.self) {
    matrix_sdk_ffi_7e42_Client_full_sliding_sync(self.pointer, $0
    )
}
        )
    }
    public func `logout`() throws {
        try
    rustCallWithError(FfiConverterTypeClientError.self) {
    matrix_sdk_ffi_7e42_Client_logout(self.pointer, $0
    )
}
    }
    public func `hasFirstSynced`()  -> Bool {
        return try! FfiConverterBool.lift(
            try!
    rustCall() {
    
    _uniffi_matrix_sdk_ffi_impl_Client_has_first_synced_4f8(self.pointer, $0
    )
}
        )
    }
    public func `homeserver`()  -> String {
        return try! FfiConverterString.lift(
            try!
    rustCall() {
    
    _uniffi_matrix_sdk_ffi_impl_Client_homeserver_9e34(self.pointer, $0
    )
}
        )
    }
    public func `isSoftLogout`()  -> Bool {
        return try! FfiConverterBool.lift(
            try!
    rustCall() {
    
    _uniffi_matrix_sdk_ffi_impl_Client_is_soft_logout_b74b(self.pointer, $0
    )
}
        )
    }
    public func `isSyncing`()  -> Bool {
        return try! FfiConverterBool.lift(
            try!
    rustCall() {
    
    _uniffi_matrix_sdk_ffi_impl_Client_is_syncing_5d85(self.pointer, $0
    )
}
        )
    }
    public func `rooms`()  -> [Room] {
        return try! FfiConverterSequenceTypeRoom.lift(
            try!
    rustCall() {
    
    _uniffi_matrix_sdk_ffi_impl_Client_rooms_7819(self.pointer, $0
    )
}
        )
    }
    public func `slidingSync`()  -> SlidingSyncBuilder {
        return try! FfiConverterTypeSlidingSyncBuilder.lift(
            try!
    rustCall() {
    
    _uniffi_matrix_sdk_ffi_impl_Client_sliding_sync_2052(self.pointer, $0
    )
}
        )
    }
    public func `startSync`(`timelineLimit`: UInt16?)  {
        try!
    rustCall() {
    
    _uniffi_matrix_sdk_ffi_impl_Client_start_sync_25c3(self.pointer, 
        FfiConverterOptionUInt16.lower(`timelineLimit`), $0
    )
}
    }
    
}


public struct FfiConverterTypeClient: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Client

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Client {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Client, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Client {
        return Client(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Client) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}


public protocol ClientBuilderProtocol {
    func `build`() throws -> Client
    func `basePath`(`path`: String)  -> ClientBuilder
    func `homeserverUrl`(`url`: String)  -> ClientBuilder
    func `passphrase`(`passphrase`: String?)  -> ClientBuilder
    func `serverName`(`serverName`: String)  -> ClientBuilder
    func `serverVersions`(`versions`: [String])  -> ClientBuilder
    func `slidingSyncProxy`(`slidingSyncProxy`: String?)  -> ClientBuilder
    func `userAgent`(`userAgent`: String)  -> ClientBuilder
    func `username`(`username`: String)  -> ClientBuilder
    
}

public class ClientBuilder: ClientBuilderProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }
    public convenience init()  {
        self.init(unsafeFromRawPointer: try!
    
    rustCall() {
    
    matrix_sdk_ffi_7e42_ClientBuilder_new($0)
})
    }

    deinit {
        try! rustCall { ffi_matrix_sdk_ffi_7e42_ClientBuilder_object_free(pointer, $0) }
    }

    

    
    public func `build`() throws -> Client {
        return try FfiConverterTypeClient.lift(
            try
    rustCallWithError(FfiConverterTypeClientError.self) {
    matrix_sdk_ffi_7e42_ClientBuilder_build(self.pointer, $0
    )
}
        )
    }
    public func `basePath`(`path`: String)  -> ClientBuilder {
        return try! FfiConverterTypeClientBuilder.lift(
            try!
    rustCall() {
    
    _uniffi_matrix_sdk_ffi_impl_ClientBuilder_base_path_51b4(self.pointer, 
        FfiConverterString.lower(`path`), $0
    )
}
        )
    }
    public func `homeserverUrl`(`url`: String)  -> ClientBuilder {
        return try! FfiConverterTypeClientBuilder.lift(
            try!
    rustCall() {
    
    _uniffi_matrix_sdk_ffi_impl_ClientBuilder_homeserver_url_4e68(self.pointer, 
        FfiConverterString.lower(`url`), $0
    )
}
        )
    }
    public func `passphrase`(`passphrase`: String?)  -> ClientBuilder {
        return try! FfiConverterTypeClientBuilder.lift(
            try!
    rustCall() {
    
    _uniffi_matrix_sdk_ffi_impl_ClientBuilder_passphrase_e0df(self.pointer, 
        FfiConverterOptionString.lower(`passphrase`), $0
    )
}
        )
    }
    public func `serverName`(`serverName`: String)  -> ClientBuilder {
        return try! FfiConverterTypeClientBuilder.lift(
            try!
    rustCall() {
    
    _uniffi_matrix_sdk_ffi_impl_ClientBuilder_server_name_c5a1(self.pointer, 
        FfiConverterString.lower(`serverName`), $0
    )
}
        )
    }
    public func `serverVersions`(`versions`: [String])  -> ClientBuilder {
        return try! FfiConverterTypeClientBuilder.lift(
            try!
    rustCall() {
    
    _uniffi_matrix_sdk_ffi_impl_ClientBuilder_server_versions_55f8(self.pointer, 
        FfiConverterSequenceString.lower(`versions`), $0
    )
}
        )
    }
    public func `slidingSyncProxy`(`slidingSyncProxy`: String?)  -> ClientBuilder {
        return try! FfiConverterTypeClientBuilder.lift(
            try!
    rustCall() {
    
    _uniffi_matrix_sdk_ffi_impl_ClientBuilder_sliding_sync_proxy_9658(self.pointer, 
        FfiConverterOptionString.lower(`slidingSyncProxy`), $0
    )
}
        )
    }
    public func `userAgent`(`userAgent`: String)  -> ClientBuilder {
        return try! FfiConverterTypeClientBuilder.lift(
            try!
    rustCall() {
    
    _uniffi_matrix_sdk_ffi_impl_ClientBuilder_user_agent_361d(self.pointer, 
        FfiConverterString.lower(`userAgent`), $0
    )
}
        )
    }
    public func `username`(`username`: String)  -> ClientBuilder {
        return try! FfiConverterTypeClientBuilder.lift(
            try!
    rustCall() {
    
    _uniffi_matrix_sdk_ffi_impl_ClientBuilder_username_5c1f(self.pointer, 
        FfiConverterString.lower(`username`), $0
    )
}
        )
    }
    
}


public struct FfiConverterTypeClientBuilder: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = ClientBuilder

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ClientBuilder {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: ClientBuilder, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ClientBuilder {
        return ClientBuilder(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: ClientBuilder) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}


public protocol EventTimelineItemProtocol {
    func `content`()  -> TimelineItemContent
    func `eventId`()  -> String?
    func `fmtDebug`()  -> String
    func `isEditable`()  -> Bool
    func `isLocal`()  -> Bool
    func `isOwn`()  -> Bool
    func `isRemote`()  -> Bool
    func `localSendState`()  -> EventSendState?
    func `raw`()  -> String?
    func `reactions`()  -> [Reaction]?
    func `sender`()  -> String
    func `senderProfile`()  -> ProfileTimelineDetails
    func `timestamp`()  -> UInt64
    func `uniqueIdentifier`()  -> String
    
}

public class EventTimelineItem: EventTimelineItemProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { _uniffi_matrix_sdk_ffi_object_free_EventTimelineItem_46cf(pointer, $0) }
    }

    

    
    public func `content`()  -> TimelineItemContent {
        return try! FfiConverterTypeTimelineItemContent.lift(
            try!
    rustCall() {
    
    _uniffi_matrix_sdk_ffi_impl_EventTimelineItem_content_2de3(self.pointer, $0
    )
}
        )
    }
    public func `eventId`()  -> String? {
        return try! FfiConverterOptionString.lift(
            try!
    rustCall() {
    
    _uniffi_matrix_sdk_ffi_impl_EventTimelineItem_event_id_4b2b(self.pointer, $0
    )
}
        )
    }
    public func `fmtDebug`()  -> String {
        return try! FfiConverterString.lift(
            try!
    rustCall() {
    
    _uniffi_matrix_sdk_ffi_impl_EventTimelineItem_fmt_debug_11a(self.pointer, $0
    )
}
        )
    }
    public func `isEditable`()  -> Bool {
        return try! FfiConverterBool.lift(
            try!
    rustCall() {
    
    _uniffi_matrix_sdk_ffi_impl_EventTimelineItem_is_editable_3862(self.pointer, $0
    )
}
        )
    }
    public func `isLocal`()  -> Bool {
        return try! FfiConverterBool.lift(
            try!
    rustCall() {
    
    _uniffi_matrix_sdk_ffi_impl_EventTimelineItem_is_local_3020(self.pointer, $0
    )
}
        )
    }
    public func `isOwn`()  -> Bool {
        return try! FfiConverterBool.lift(
            try!
    rustCall() {
    
    _uniffi_matrix_sdk_ffi_impl_EventTimelineItem_is_own_adc2(self.pointer, $0
    )
}
        )
    }
    public func `isRemote`()  -> Bool {
        return try! FfiConverterBool.lift(
            try!
    rustCall() {
    
    _uniffi_matrix_sdk_ffi_impl_EventTimelineItem_is_remote_8b79(self.pointer, $0
    )
}
        )
    }
    public func `localSendState`()  -> EventSendState? {
        return try! FfiConverterOptionTypeEventSendState.lift(
            try!
    rustCall() {
    
    _uniffi_matrix_sdk_ffi_impl_EventTimelineItem_local_send_state_250(self.pointer, $0
    )
}
        )
    }
    public func `raw`()  -> String? {
        return try! FfiConverterOptionString.lift(
            try!
    rustCall() {
    
    _uniffi_matrix_sdk_ffi_impl_EventTimelineItem_raw_3a9(self.pointer, $0
    )
}
        )
    }
    public func `reactions`()  -> [Reaction]? {
        return try! FfiConverterOptionSequenceTypeReaction.lift(
            try!
    rustCall() {
    
    _uniffi_matrix_sdk_ffi_impl_EventTimelineItem_reactions_ed6a(self.pointer, $0
    )
}
        )
    }
    public func `sender`()  -> String {
        return try! FfiConverterString.lift(
            try!
    rustCall() {
    
    _uniffi_matrix_sdk_ffi_impl_EventTimelineItem_sender_304e(self.pointer, $0
    )
}
        )
    }
    public func `senderProfile`()  -> ProfileTimelineDetails {
        return try! FfiConverterTypeProfileTimelineDetails.lift(
            try!
    rustCall() {
    
    _uniffi_matrix_sdk_ffi_impl_EventTimelineItem_sender_profile_5a53(self.pointer, $0
    )
}
        )
    }
    public func `timestamp`()  -> UInt64 {
        return try! FfiConverterUInt64.lift(
            try!
    rustCall() {
    
    _uniffi_matrix_sdk_ffi_impl_EventTimelineItem_timestamp_650b(self.pointer, $0
    )
}
        )
    }
    public func `uniqueIdentifier`()  -> String {
        return try! FfiConverterString.lift(
            try!
    rustCall() {
    
    _uniffi_matrix_sdk_ffi_impl_EventTimelineItem_unique_identifier_1709(self.pointer, $0
    )
}
        )
    }
    
}


public struct FfiConverterTypeEventTimelineItem: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = EventTimelineItem

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> EventTimelineItem {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: EventTimelineItem, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> EventTimelineItem {
        return EventTimelineItem(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: EventTimelineItem) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}


public protocol HomeserverLoginDetailsProtocol {
    func `authenticationIssuer`()  -> String?
    func `supportsPasswordLogin`()  -> Bool
    func `url`()  -> String
    
}

public class HomeserverLoginDetails: HomeserverLoginDetailsProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { _uniffi_matrix_sdk_ffi_object_free_HomeserverLoginDetails_2400(pointer, $0) }
    }

    

    
    public func `authenticationIssuer`()  -> String? {
        return try! FfiConverterOptionString.lift(
            try!
    rustCall() {
    
    _uniffi_matrix_sdk_ffi_impl_HomeserverLoginDetails_authentication_issuer_ea3c(self.pointer, $0
    )
}
        )
    }
    public func `supportsPasswordLogin`()  -> Bool {
        return try! FfiConverterBool.lift(
            try!
    rustCall() {
    
    _uniffi_matrix_sdk_ffi_impl_HomeserverLoginDetails_supports_password_login_2455(self.pointer, $0
    )
}
        )
    }
    public func `url`()  -> String {
        return try! FfiConverterString.lift(
            try!
    rustCall() {
    
    _uniffi_matrix_sdk_ffi_impl_HomeserverLoginDetails_url_da8f(self.pointer, $0
    )
}
        )
    }
    
}


public struct FfiConverterTypeHomeserverLoginDetails: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = HomeserverLoginDetails

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> HomeserverLoginDetails {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: HomeserverLoginDetails, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> HomeserverLoginDetails {
        return HomeserverLoginDetails(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: HomeserverLoginDetails) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}


public protocol MediaSourceProtocol {
    func `url`()  -> String
    
}

public class MediaSource: MediaSourceProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { ffi_matrix_sdk_ffi_7e42_MediaSource_object_free(pointer, $0) }
    }

    

    
    public func `url`()  -> String {
        return try! FfiConverterString.lift(
            try!
    rustCall() {
    
    matrix_sdk_ffi_7e42_MediaSource_url(self.pointer, $0
    )
}
        )
    }
    
}


public struct FfiConverterTypeMediaSource: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = MediaSource

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MediaSource {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: MediaSource, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> MediaSource {
        return MediaSource(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: MediaSource) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}


public protocol MessageProtocol {
    func `body`()  -> String
    func `inReplyTo`()  -> String?
    func `isEdited`()  -> Bool
    func `msgtype`()  -> MessageType?
    
}

public class Message: MessageProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { _uniffi_matrix_sdk_ffi_object_free_Message_1ab4(pointer, $0) }
    }

    

    
    public func `body`()  -> String {
        return try! FfiConverterString.lift(
            try!
    rustCall() {
    
    _uniffi_matrix_sdk_ffi_impl_Message_body_6236(self.pointer, $0
    )
}
        )
    }
    public func `inReplyTo`()  -> String? {
        return try! FfiConverterOptionString.lift(
            try!
    rustCall() {
    
    _uniffi_matrix_sdk_ffi_impl_Message_in_reply_to_7f06(self.pointer, $0
    )
}
        )
    }
    public func `isEdited`()  -> Bool {
        return try! FfiConverterBool.lift(
            try!
    rustCall() {
    
    _uniffi_matrix_sdk_ffi_impl_Message_is_edited_fcdd(self.pointer, $0
    )
}
        )
    }
    public func `msgtype`()  -> MessageType? {
        return try! FfiConverterOptionTypeMessageType.lift(
            try!
    rustCall() {
    
    _uniffi_matrix_sdk_ffi_impl_Message_msgtype_5024(self.pointer, $0
    )
}
        )
    }
    
}


public struct FfiConverterTypeMessage: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Message

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Message {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Message, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Message {
        return Message(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Message) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}


public protocol RoomProtocol {
    func `displayName`() throws -> String
    func `isEncrypted`() throws -> Bool
    func `members`() throws -> [RoomMember]
    func `memberAvatarUrl`(`userId`: String) throws -> String?
    func `memberDisplayName`(`userId`: String) throws -> String?
    func `addTimelineListener`(`listener`: TimelineListener)  -> [TimelineItem]
    func `paginateBackwards`(`opts`: PaginationOptions) throws
    func `sendReadReceipt`(`eventId`: String) throws
    func `sendReadMarker`(`fullyReadEventId`: String, `readReceiptEventId`: String?) throws
    func `send`(`msg`: RoomMessageEventContent, `txnId`: String?) 
    func `sendReply`(`msg`: String, `inReplyToEventId`: String, `txnId`: String?) throws
    func `edit`(`newMsg`: String, `originalEventId`: String, `txnId`: String?) throws
    func `redact`(`eventId`: String, `reason`: String?, `txnId`: String?) throws
    func `reportContent`(`eventId`: String, `score`: Int32?, `reason`: String?) throws
    func `sendReaction`(`eventId`: String, `key`: String) throws
    func `alternativeAliases`()  -> [String]
    func `avatarUrl`()  -> String?
    func `canonicalAlias`()  -> String?
    func `fetchMembers`() 
    func `id`()  -> String
    func `isDirect`()  -> Bool
    func `isPublic`()  -> Bool
    func `isSpace`()  -> Bool
    func `isTombstoned`()  -> Bool
    func `membership`()  -> Membership
    func `name`()  -> String?
    func `removeTimeline`() 
    func `retryDecryption`(`sessionIds`: [String]) 
    func `topic`()  -> String?
    
}

public class Room: RoomProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { ffi_matrix_sdk_ffi_7e42_Room_object_free(pointer, $0) }
    }

    

    
    public func `displayName`() throws -> String {
        return try FfiConverterString.lift(
            try
    rustCallWithError(FfiConverterTypeClientError.self) {
    matrix_sdk_ffi_7e42_Room_display_name(self.pointer, $0
    )
}
        )
    }
    public func `isEncrypted`() throws -> Bool {
        return try FfiConverterBool.lift(
            try
    rustCallWithError(FfiConverterTypeClientError.self) {
    matrix_sdk_ffi_7e42_Room_is_encrypted(self.pointer, $0
    )
}
        )
    }
    public func `members`() throws -> [RoomMember] {
        return try FfiConverterSequenceTypeRoomMember.lift(
            try
    rustCallWithError(FfiConverterTypeClientError.self) {
    matrix_sdk_ffi_7e42_Room_members(self.pointer, $0
    )
}
        )
    }
    public func `memberAvatarUrl`(`userId`: String) throws -> String? {
        return try FfiConverterOptionString.lift(
            try
    rustCallWithError(FfiConverterTypeClientError.self) {
    matrix_sdk_ffi_7e42_Room_member_avatar_url(self.pointer, 
        FfiConverterString.lower(`userId`), $0
    )
}
        )
    }
    public func `memberDisplayName`(`userId`: String) throws -> String? {
        return try FfiConverterOptionString.lift(
            try
    rustCallWithError(FfiConverterTypeClientError.self) {
    matrix_sdk_ffi_7e42_Room_member_display_name(self.pointer, 
        FfiConverterString.lower(`userId`), $0
    )
}
        )
    }
    public func `addTimelineListener`(`listener`: TimelineListener)  -> [TimelineItem] {
        return try! FfiConverterSequenceTypeTimelineItem.lift(
            try!
    rustCall() {
    
    matrix_sdk_ffi_7e42_Room_add_timeline_listener(self.pointer, 
        FfiConverterCallbackInterfaceTimelineListener.lower(`listener`), $0
    )
}
        )
    }
    public func `paginateBackwards`(`opts`: PaginationOptions) throws {
        try
    rustCallWithError(FfiConverterTypeClientError.self) {
    matrix_sdk_ffi_7e42_Room_paginate_backwards(self.pointer, 
        FfiConverterTypePaginationOptions.lower(`opts`), $0
    )
}
    }
    public func `sendReadReceipt`(`eventId`: String) throws {
        try
    rustCallWithError(FfiConverterTypeClientError.self) {
    matrix_sdk_ffi_7e42_Room_send_read_receipt(self.pointer, 
        FfiConverterString.lower(`eventId`), $0
    )
}
    }
    public func `sendReadMarker`(`fullyReadEventId`: String, `readReceiptEventId`: String?) throws {
        try
    rustCallWithError(FfiConverterTypeClientError.self) {
    matrix_sdk_ffi_7e42_Room_send_read_marker(self.pointer, 
        FfiConverterString.lower(`fullyReadEventId`), 
        FfiConverterOptionString.lower(`readReceiptEventId`), $0
    )
}
    }
    public func `send`(`msg`: RoomMessageEventContent, `txnId`: String?)  {
        try!
    rustCall() {
    
    matrix_sdk_ffi_7e42_Room_send(self.pointer, 
        FfiConverterTypeRoomMessageEventContent.lower(`msg`), 
        FfiConverterOptionString.lower(`txnId`), $0
    )
}
    }
    public func `sendReply`(`msg`: String, `inReplyToEventId`: String, `txnId`: String?) throws {
        try
    rustCallWithError(FfiConverterTypeClientError.self) {
    matrix_sdk_ffi_7e42_Room_send_reply(self.pointer, 
        FfiConverterString.lower(`msg`), 
        FfiConverterString.lower(`inReplyToEventId`), 
        FfiConverterOptionString.lower(`txnId`), $0
    )
}
    }
    public func `edit`(`newMsg`: String, `originalEventId`: String, `txnId`: String?) throws {
        try
    rustCallWithError(FfiConverterTypeClientError.self) {
    matrix_sdk_ffi_7e42_Room_edit(self.pointer, 
        FfiConverterString.lower(`newMsg`), 
        FfiConverterString.lower(`originalEventId`), 
        FfiConverterOptionString.lower(`txnId`), $0
    )
}
    }
    public func `redact`(`eventId`: String, `reason`: String?, `txnId`: String?) throws {
        try
    rustCallWithError(FfiConverterTypeClientError.self) {
    matrix_sdk_ffi_7e42_Room_redact(self.pointer, 
        FfiConverterString.lower(`eventId`), 
        FfiConverterOptionString.lower(`reason`), 
        FfiConverterOptionString.lower(`txnId`), $0
    )
}
    }
    public func `reportContent`(`eventId`: String, `score`: Int32?, `reason`: String?) throws {
        try
    rustCallWithError(FfiConverterTypeClientError.self) {
    matrix_sdk_ffi_7e42_Room_report_content(self.pointer, 
        FfiConverterString.lower(`eventId`), 
        FfiConverterOptionInt32.lower(`score`), 
        FfiConverterOptionString.lower(`reason`), $0
    )
}
    }
    public func `sendReaction`(`eventId`: String, `key`: String) throws {
        try
    rustCallWithError(FfiConverterTypeClientError.self) {
    matrix_sdk_ffi_7e42_Room_send_reaction(self.pointer, 
        FfiConverterString.lower(`eventId`), 
        FfiConverterString.lower(`key`), $0
    )
}
    }
    public func `alternativeAliases`()  -> [String] {
        return try! FfiConverterSequenceString.lift(
            try!
    rustCall() {
    
    _uniffi_matrix_sdk_ffi_impl_Room_alternative_aliases_a729(self.pointer, $0
    )
}
        )
    }
    public func `avatarUrl`()  -> String? {
        return try! FfiConverterOptionString.lift(
            try!
    rustCall() {
    
    _uniffi_matrix_sdk_ffi_impl_Room_avatar_url_faa5(self.pointer, $0
    )
}
        )
    }
    public func `canonicalAlias`()  -> String? {
        return try! FfiConverterOptionString.lift(
            try!
    rustCall() {
    
    _uniffi_matrix_sdk_ffi_impl_Room_canonical_alias_28ec(self.pointer, $0
    )
}
        )
    }
    public func `fetchMembers`()  {
        try!
    rustCall() {
    
    _uniffi_matrix_sdk_ffi_impl_Room_fetch_members_c181(self.pointer, $0
    )
}
    }
    public func `id`()  -> String {
        return try! FfiConverterString.lift(
            try!
    rustCall() {
    
    _uniffi_matrix_sdk_ffi_impl_Room_id_db81(self.pointer, $0
    )
}
        )
    }
    public func `isDirect`()  -> Bool {
        return try! FfiConverterBool.lift(
            try!
    rustCall() {
    
    _uniffi_matrix_sdk_ffi_impl_Room_is_direct_ef45(self.pointer, $0
    )
}
        )
    }
    public func `isPublic`()  -> Bool {
        return try! FfiConverterBool.lift(
            try!
    rustCall() {
    
    _uniffi_matrix_sdk_ffi_impl_Room_is_public_fee7(self.pointer, $0
    )
}
        )
    }
    public func `isSpace`()  -> Bool {
        return try! FfiConverterBool.lift(
            try!
    rustCall() {
    
    _uniffi_matrix_sdk_ffi_impl_Room_is_space_f6cb(self.pointer, $0
    )
}
        )
    }
    public func `isTombstoned`()  -> Bool {
        return try! FfiConverterBool.lift(
            try!
    rustCall() {
    
    _uniffi_matrix_sdk_ffi_impl_Room_is_tombstoned_7e34(self.pointer, $0
    )
}
        )
    }
    public func `membership`()  -> Membership {
        return try! FfiConverterTypeMembership.lift(
            try!
    rustCall() {
    
    _uniffi_matrix_sdk_ffi_impl_Room_membership_5040(self.pointer, $0
    )
}
        )
    }
    public func `name`()  -> String? {
        return try! FfiConverterOptionString.lift(
            try!
    rustCall() {
    
    _uniffi_matrix_sdk_ffi_impl_Room_name_9dcf(self.pointer, $0
    )
}
        )
    }
    public func `removeTimeline`()  {
        try!
    rustCall() {
    
    _uniffi_matrix_sdk_ffi_impl_Room_remove_timeline_a9df(self.pointer, $0
    )
}
    }
    public func `retryDecryption`(`sessionIds`: [String])  {
        try!
    rustCall() {
    
    _uniffi_matrix_sdk_ffi_impl_Room_retry_decryption_b803(self.pointer, 
        FfiConverterSequenceString.lower(`sessionIds`), $0
    )
}
    }
    public func `topic`()  -> String? {
        return try! FfiConverterOptionString.lift(
            try!
    rustCall() {
    
    _uniffi_matrix_sdk_ffi_impl_Room_topic_6137(self.pointer, $0
    )
}
        )
    }
    
}


public struct FfiConverterTypeRoom: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Room

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Room {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Room, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Room {
        return Room(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Room) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}


public protocol RoomMessageEventContentProtocol {
    
}

public class RoomMessageEventContent: RoomMessageEventContentProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { ffi_matrix_sdk_ffi_7e42_RoomMessageEventContent_object_free(pointer, $0) }
    }

    

    
    
}


public struct FfiConverterTypeRoomMessageEventContent: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = RoomMessageEventContent

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RoomMessageEventContent {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: RoomMessageEventContent, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> RoomMessageEventContent {
        return RoomMessageEventContent(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: RoomMessageEventContent) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}


public protocol SessionVerificationControllerProtocol {
    func `setDelegate`(`delegate`: SessionVerificationControllerDelegate?) 
    func `requestVerification`() throws
    func `startSasVerification`() throws
    func `approveVerification`() throws
    func `declineVerification`() throws
    func `cancelVerification`() throws
    func `isVerified`()  -> Bool
    
}

public class SessionVerificationController: SessionVerificationControllerProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { ffi_matrix_sdk_ffi_7e42_SessionVerificationController_object_free(pointer, $0) }
    }

    

    
    public func `setDelegate`(`delegate`: SessionVerificationControllerDelegate?)  {
        try!
    rustCall() {
    
    matrix_sdk_ffi_7e42_SessionVerificationController_set_delegate(self.pointer, 
        FfiConverterOptionCallbackInterfaceSessionVerificationControllerDelegate.lower(`delegate`), $0
    )
}
    }
    public func `requestVerification`() throws {
        try
    rustCallWithError(FfiConverterTypeClientError.self) {
    matrix_sdk_ffi_7e42_SessionVerificationController_request_verification(self.pointer, $0
    )
}
    }
    public func `startSasVerification`() throws {
        try
    rustCallWithError(FfiConverterTypeClientError.self) {
    matrix_sdk_ffi_7e42_SessionVerificationController_start_sas_verification(self.pointer, $0
    )
}
    }
    public func `approveVerification`() throws {
        try
    rustCallWithError(FfiConverterTypeClientError.self) {
    matrix_sdk_ffi_7e42_SessionVerificationController_approve_verification(self.pointer, $0
    )
}
    }
    public func `declineVerification`() throws {
        try
    rustCallWithError(FfiConverterTypeClientError.self) {
    matrix_sdk_ffi_7e42_SessionVerificationController_decline_verification(self.pointer, $0
    )
}
    }
    public func `cancelVerification`() throws {
        try
    rustCallWithError(FfiConverterTypeClientError.self) {
    matrix_sdk_ffi_7e42_SessionVerificationController_cancel_verification(self.pointer, $0
    )
}
    }
    public func `isVerified`()  -> Bool {
        return try! FfiConverterBool.lift(
            try!
    rustCall() {
    
    _uniffi_matrix_sdk_ffi_impl_SessionVerificationController_is_verified_388a(self.pointer, $0
    )
}
        )
    }
    
}


public struct FfiConverterTypeSessionVerificationController: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = SessionVerificationController

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SessionVerificationController {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: SessionVerificationController, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> SessionVerificationController {
        return SessionVerificationController(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: SessionVerificationController) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}


public protocol SessionVerificationEmojiProtocol {
    func `description`()  -> String
    func `symbol`()  -> String
    
}

public class SessionVerificationEmoji: SessionVerificationEmojiProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { ffi_matrix_sdk_ffi_7e42_SessionVerificationEmoji_object_free(pointer, $0) }
    }

    

    
    public func `description`()  -> String {
        return try! FfiConverterString.lift(
            try!
    rustCall() {
    
    _uniffi_matrix_sdk_ffi_impl_SessionVerificationEmoji_description_107e(self.pointer, $0
    )
}
        )
    }
    public func `symbol`()  -> String {
        return try! FfiConverterString.lift(
            try!
    rustCall() {
    
    _uniffi_matrix_sdk_ffi_impl_SessionVerificationEmoji_symbol_fa98(self.pointer, $0
    )
}
        )
    }
    
}


public struct FfiConverterTypeSessionVerificationEmoji: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = SessionVerificationEmoji

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SessionVerificationEmoji {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: SessionVerificationEmoji, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> SessionVerificationEmoji {
        return SessionVerificationEmoji(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: SessionVerificationEmoji) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}


public protocol SlidingSyncProtocol {
    func `setObserver`(`observer`: SlidingSyncObserver?) 
    func `subscribe`(`roomId`: String, `settings`: RoomSubscription?) throws
    func `unsubscribe`(`roomId`: String) throws
    func `getRoom`(`roomId`: String) throws -> SlidingSyncRoom?
    func `getRooms`(`roomIds`: [String]) throws -> [SlidingSyncRoom?]
    func `addCommonExtensions`() 
    func `addList`(`list`: SlidingSyncList)  -> SlidingSyncList?
    func `getList`(`name`: String)  -> SlidingSyncList?
    func `popList`(`name`: String)  -> SlidingSyncList?
    func `sync`()  -> TaskHandle
    
}

public class SlidingSync: SlidingSyncProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { ffi_matrix_sdk_ffi_7e42_SlidingSync_object_free(pointer, $0) }
    }

    

    
    public func `setObserver`(`observer`: SlidingSyncObserver?)  {
        try!
    rustCall() {
    
    matrix_sdk_ffi_7e42_SlidingSync_set_observer(self.pointer, 
        FfiConverterOptionCallbackInterfaceSlidingSyncObserver.lower(`observer`), $0
    )
}
    }
    public func `subscribe`(`roomId`: String, `settings`: RoomSubscription?) throws {
        try
    rustCallWithError(FfiConverterTypeClientError.self) {
    matrix_sdk_ffi_7e42_SlidingSync_subscribe(self.pointer, 
        FfiConverterString.lower(`roomId`), 
        FfiConverterOptionTypeRoomSubscription.lower(`settings`), $0
    )
}
    }
    public func `unsubscribe`(`roomId`: String) throws {
        try
    rustCallWithError(FfiConverterTypeClientError.self) {
    matrix_sdk_ffi_7e42_SlidingSync_unsubscribe(self.pointer, 
        FfiConverterString.lower(`roomId`), $0
    )
}
    }
    public func `getRoom`(`roomId`: String) throws -> SlidingSyncRoom? {
        return try FfiConverterOptionTypeSlidingSyncRoom.lift(
            try
    rustCallWithError(FfiConverterTypeClientError.self) {
    matrix_sdk_ffi_7e42_SlidingSync_get_room(self.pointer, 
        FfiConverterString.lower(`roomId`), $0
    )
}
        )
    }
    public func `getRooms`(`roomIds`: [String]) throws -> [SlidingSyncRoom?] {
        return try FfiConverterSequenceOptionTypeSlidingSyncRoom.lift(
            try
    rustCallWithError(FfiConverterTypeClientError.self) {
    matrix_sdk_ffi_7e42_SlidingSync_get_rooms(self.pointer, 
        FfiConverterSequenceString.lower(`roomIds`), $0
    )
}
        )
    }
    public func `addCommonExtensions`()  {
        try!
    rustCall() {
    
    _uniffi_matrix_sdk_ffi_impl_SlidingSync_add_common_extensions_26c4(self.pointer, $0
    )
}
    }
    public func `addList`(`list`: SlidingSyncList)  -> SlidingSyncList? {
        return try! FfiConverterOptionTypeSlidingSyncList.lift(
            try!
    rustCall() {
    
    _uniffi_matrix_sdk_ffi_impl_SlidingSync_add_list_6b80(self.pointer, 
        FfiConverterTypeSlidingSyncList.lower(`list`), $0
    )
}
        )
    }
    public func `getList`(`name`: String)  -> SlidingSyncList? {
        return try! FfiConverterOptionTypeSlidingSyncList.lift(
            try!
    rustCall() {
    
    _uniffi_matrix_sdk_ffi_impl_SlidingSync_get_list_8134(self.pointer, 
        FfiConverterString.lower(`name`), $0
    )
}
        )
    }
    public func `popList`(`name`: String)  -> SlidingSyncList? {
        return try! FfiConverterOptionTypeSlidingSyncList.lift(
            try!
    rustCall() {
    
    _uniffi_matrix_sdk_ffi_impl_SlidingSync_pop_list_d50d(self.pointer, 
        FfiConverterString.lower(`name`), $0
    )
}
        )
    }
    public func `sync`()  -> TaskHandle {
        return try! FfiConverterTypeTaskHandle.lift(
            try!
    rustCall() {
    
    _uniffi_matrix_sdk_ffi_impl_SlidingSync_sync_fe44(self.pointer, $0
    )
}
        )
    }
    
}


public struct FfiConverterTypeSlidingSync: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = SlidingSync

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SlidingSync {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: SlidingSync, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> SlidingSync {
        return SlidingSync(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: SlidingSync) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}


public protocol SlidingSyncBuilderProtocol {
    func `homeserver`(`url`: String) throws -> SlidingSyncBuilder
    func `build`() throws -> SlidingSync
    func `addFullsyncList`()  -> SlidingSyncBuilder
    func `addList`(`v`: SlidingSyncList)  -> SlidingSyncBuilder
    func `coldCache`(`name`: String)  -> SlidingSyncBuilder
    func `noLists`()  -> SlidingSyncBuilder
    func `withAllExtensions`()  -> SlidingSyncBuilder
    func `withCommonExtensions`()  -> SlidingSyncBuilder
    func `withoutAccountDataExtension`()  -> SlidingSyncBuilder
    func `withoutE2eeExtension`()  -> SlidingSyncBuilder
    func `withoutReceiptExtension`()  -> SlidingSyncBuilder
    func `withoutToDeviceExtension`()  -> SlidingSyncBuilder
    func `withoutTypingExtension`()  -> SlidingSyncBuilder
    
}

public class SlidingSyncBuilder: SlidingSyncBuilderProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { ffi_matrix_sdk_ffi_7e42_SlidingSyncBuilder_object_free(pointer, $0) }
    }

    

    
    public func `homeserver`(`url`: String) throws -> SlidingSyncBuilder {
        return try FfiConverterTypeSlidingSyncBuilder.lift(
            try
    rustCallWithError(FfiConverterTypeClientError.self) {
    matrix_sdk_ffi_7e42_SlidingSyncBuilder_homeserver(self.pointer, 
        FfiConverterString.lower(`url`), $0
    )
}
        )
    }
    public func `build`() throws -> SlidingSync {
        return try FfiConverterTypeSlidingSync.lift(
            try
    rustCallWithError(FfiConverterTypeClientError.self) {
    matrix_sdk_ffi_7e42_SlidingSyncBuilder_build(self.pointer, $0
    )
}
        )
    }
    public func `addFullsyncList`()  -> SlidingSyncBuilder {
        return try! FfiConverterTypeSlidingSyncBuilder.lift(
            try!
    rustCall() {
    
    _uniffi_matrix_sdk_ffi_impl_SlidingSyncBuilder_add_fullsync_list_476e(self.pointer, $0
    )
}
        )
    }
    public func `addList`(`v`: SlidingSyncList)  -> SlidingSyncBuilder {
        return try! FfiConverterTypeSlidingSyncBuilder.lift(
            try!
    rustCall() {
    
    _uniffi_matrix_sdk_ffi_impl_SlidingSyncBuilder_add_list_f05a(self.pointer, 
        FfiConverterTypeSlidingSyncList.lower(`v`), $0
    )
}
        )
    }
    public func `coldCache`(`name`: String)  -> SlidingSyncBuilder {
        return try! FfiConverterTypeSlidingSyncBuilder.lift(
            try!
    rustCall() {
    
    _uniffi_matrix_sdk_ffi_impl_SlidingSyncBuilder_cold_cache_7814(self.pointer, 
        FfiConverterString.lower(`name`), $0
    )
}
        )
    }
    public func `noLists`()  -> SlidingSyncBuilder {
        return try! FfiConverterTypeSlidingSyncBuilder.lift(
            try!
    rustCall() {
    
    _uniffi_matrix_sdk_ffi_impl_SlidingSyncBuilder_no_lists_f239(self.pointer, $0
    )
}
        )
    }
    public func `withAllExtensions`()  -> SlidingSyncBuilder {
        return try! FfiConverterTypeSlidingSyncBuilder.lift(
            try!
    rustCall() {
    
    _uniffi_matrix_sdk_ffi_impl_SlidingSyncBuilder_with_all_extensions_a54(self.pointer, $0
    )
}
        )
    }
    public func `withCommonExtensions`()  -> SlidingSyncBuilder {
        return try! FfiConverterTypeSlidingSyncBuilder.lift(
            try!
    rustCall() {
    
    _uniffi_matrix_sdk_ffi_impl_SlidingSyncBuilder_with_common_extensions_f2da(self.pointer, $0
    )
}
        )
    }
    public func `withoutAccountDataExtension`()  -> SlidingSyncBuilder {
        return try! FfiConverterTypeSlidingSyncBuilder.lift(
            try!
    rustCall() {
    
    _uniffi_matrix_sdk_ffi_impl_SlidingSyncBuilder_without_account_data_extension_5a9d(self.pointer, $0
    )
}
        )
    }
    public func `withoutE2eeExtension`()  -> SlidingSyncBuilder {
        return try! FfiConverterTypeSlidingSyncBuilder.lift(
            try!
    rustCall() {
    
    _uniffi_matrix_sdk_ffi_impl_SlidingSyncBuilder_without_e2ee_extension_6ff7(self.pointer, $0
    )
}
        )
    }
    public func `withoutReceiptExtension`()  -> SlidingSyncBuilder {
        return try! FfiConverterTypeSlidingSyncBuilder.lift(
            try!
    rustCall() {
    
    _uniffi_matrix_sdk_ffi_impl_SlidingSyncBuilder_without_receipt_extension_9fb2(self.pointer, $0
    )
}
        )
    }
    public func `withoutToDeviceExtension`()  -> SlidingSyncBuilder {
        return try! FfiConverterTypeSlidingSyncBuilder.lift(
            try!
    rustCall() {
    
    _uniffi_matrix_sdk_ffi_impl_SlidingSyncBuilder_without_to_device_extension_29f5(self.pointer, $0
    )
}
        )
    }
    public func `withoutTypingExtension`()  -> SlidingSyncBuilder {
        return try! FfiConverterTypeSlidingSyncBuilder.lift(
            try!
    rustCall() {
    
    _uniffi_matrix_sdk_ffi_impl_SlidingSyncBuilder_without_typing_extension_f1c8(self.pointer, $0
    )
}
        )
    }
    
}


public struct FfiConverterTypeSlidingSyncBuilder: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = SlidingSyncBuilder

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SlidingSyncBuilder {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: SlidingSyncBuilder, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> SlidingSyncBuilder {
        return SlidingSyncBuilder(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: SlidingSyncBuilder) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}


public protocol SlidingSyncListProtocol {
    func `observeRoomList`(`observer`: SlidingSyncListRoomListObserver)  -> TaskHandle
    func `observeRoomsCount`(`observer`: SlidingSyncListRoomsCountObserver)  -> TaskHandle
    func `observeState`(`observer`: SlidingSyncListStateObserver)  -> TaskHandle
    func `observeRoomItems`(`observer`: SlidingSyncListRoomItemsObserver)  -> TaskHandle
    func `addRange`(`start`: UInt32, `end`: UInt32) 
    func `currentRoomCount`()  -> UInt32?
    func `currentRoomsList`()  -> [RoomListEntry]
    func `getTimelineLimit`()  -> UInt32?
    func `resetRanges`() 
    func `setRange`(`start`: UInt32, `end`: UInt32) 
    func `setTimelineLimit`(`value`: UInt32) 
    func `unsetTimelineLimit`() 
    
}

public class SlidingSyncList: SlidingSyncListProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { ffi_matrix_sdk_ffi_7e42_SlidingSyncList_object_free(pointer, $0) }
    }

    

    
    public func `observeRoomList`(`observer`: SlidingSyncListRoomListObserver)  -> TaskHandle {
        return try! FfiConverterTypeTaskHandle.lift(
            try!
    rustCall() {
    
    matrix_sdk_ffi_7e42_SlidingSyncList_observe_room_list(self.pointer, 
        FfiConverterCallbackInterfaceSlidingSyncListRoomListObserver.lower(`observer`), $0
    )
}
        )
    }
    public func `observeRoomsCount`(`observer`: SlidingSyncListRoomsCountObserver)  -> TaskHandle {
        return try! FfiConverterTypeTaskHandle.lift(
            try!
    rustCall() {
    
    matrix_sdk_ffi_7e42_SlidingSyncList_observe_rooms_count(self.pointer, 
        FfiConverterCallbackInterfaceSlidingSyncListRoomsCountObserver.lower(`observer`), $0
    )
}
        )
    }
    public func `observeState`(`observer`: SlidingSyncListStateObserver)  -> TaskHandle {
        return try! FfiConverterTypeTaskHandle.lift(
            try!
    rustCall() {
    
    matrix_sdk_ffi_7e42_SlidingSyncList_observe_state(self.pointer, 
        FfiConverterCallbackInterfaceSlidingSyncListStateObserver.lower(`observer`), $0
    )
}
        )
    }
    public func `observeRoomItems`(`observer`: SlidingSyncListRoomItemsObserver)  -> TaskHandle {
        return try! FfiConverterTypeTaskHandle.lift(
            try!
    rustCall() {
    
    matrix_sdk_ffi_7e42_SlidingSyncList_observe_room_items(self.pointer, 
        FfiConverterCallbackInterfaceSlidingSyncListRoomItemsObserver.lower(`observer`), $0
    )
}
        )
    }
    public func `addRange`(`start`: UInt32, `end`: UInt32)  {
        try!
    rustCall() {
    
    _uniffi_matrix_sdk_ffi_impl_SlidingSyncList_add_range_11e5(self.pointer, 
        FfiConverterUInt32.lower(`start`), 
        FfiConverterUInt32.lower(`end`), $0
    )
}
    }
    public func `currentRoomCount`()  -> UInt32? {
        return try! FfiConverterOptionUInt32.lift(
            try!
    rustCall() {
    
    _uniffi_matrix_sdk_ffi_impl_SlidingSyncList_current_room_count_e691(self.pointer, $0
    )
}
        )
    }
    public func `currentRoomsList`()  -> [RoomListEntry] {
        return try! FfiConverterSequenceTypeRoomListEntry.lift(
            try!
    rustCall() {
    
    _uniffi_matrix_sdk_ffi_impl_SlidingSyncList_current_rooms_list_d765(self.pointer, $0
    )
}
        )
    }
    public func `getTimelineLimit`()  -> UInt32? {
        return try! FfiConverterOptionUInt32.lift(
            try!
    rustCall() {
    
    _uniffi_matrix_sdk_ffi_impl_SlidingSyncList_get_timeline_limit_4549(self.pointer, $0
    )
}
        )
    }
    public func `resetRanges`()  {
        try!
    rustCall() {
    
    _uniffi_matrix_sdk_ffi_impl_SlidingSyncList_reset_ranges_ce50(self.pointer, $0
    )
}
    }
    public func `setRange`(`start`: UInt32, `end`: UInt32)  {
        try!
    rustCall() {
    
    _uniffi_matrix_sdk_ffi_impl_SlidingSyncList_set_range_1539(self.pointer, 
        FfiConverterUInt32.lower(`start`), 
        FfiConverterUInt32.lower(`end`), $0
    )
}
    }
    public func `setTimelineLimit`(`value`: UInt32)  {
        try!
    rustCall() {
    
    _uniffi_matrix_sdk_ffi_impl_SlidingSyncList_set_timeline_limit_1c5c(self.pointer, 
        FfiConverterUInt32.lower(`value`), $0
    )
}
    }
    public func `unsetTimelineLimit`()  {
        try!
    rustCall() {
    
    _uniffi_matrix_sdk_ffi_impl_SlidingSyncList_unset_timeline_limit_d743(self.pointer, $0
    )
}
    }
    
}


public struct FfiConverterTypeSlidingSyncList: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = SlidingSyncList

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SlidingSyncList {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: SlidingSyncList, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> SlidingSyncList {
        return SlidingSyncList(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: SlidingSyncList) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}


public protocol SlidingSyncListBuilderProtocol {
    func `syncMode`(`mode`: SlidingSyncMode)  -> SlidingSyncListBuilder
    func `sendUpdatesForItems`(`enable`: Bool)  -> SlidingSyncListBuilder
    func `build`() throws -> SlidingSyncList
    func `addRange`(`from`: UInt32, `to`: UInt32)  -> SlidingSyncListBuilder
    func `batchSize`(`batchSize`: UInt32)  -> SlidingSyncListBuilder
    func `filters`(`filters`: SlidingSyncRequestListFilters)  -> SlidingSyncListBuilder
    func `name`(`name`: String)  -> SlidingSyncListBuilder
    func `noFilters`()  -> SlidingSyncListBuilder
    func `noRoomLimit`()  -> SlidingSyncListBuilder
    func `noTimelineLimit`()  -> SlidingSyncListBuilder
    func `requiredState`(`requiredState`: [RequiredState])  -> SlidingSyncListBuilder
    func `resetRanges`()  -> SlidingSyncListBuilder
    func `roomLimit`(`limit`: UInt32)  -> SlidingSyncListBuilder
    func `sort`(`sort`: [String])  -> SlidingSyncListBuilder
    func `timelineLimit`(`limit`: UInt32)  -> SlidingSyncListBuilder
    
}

public class SlidingSyncListBuilder: SlidingSyncListBuilderProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }
    public convenience init()  {
        self.init(unsafeFromRawPointer: try!
    
    rustCall() {
    
    matrix_sdk_ffi_7e42_SlidingSyncListBuilder_new($0)
})
    }

    deinit {
        try! rustCall { ffi_matrix_sdk_ffi_7e42_SlidingSyncListBuilder_object_free(pointer, $0) }
    }

    

    
    public func `syncMode`(`mode`: SlidingSyncMode)  -> SlidingSyncListBuilder {
        return try! FfiConverterTypeSlidingSyncListBuilder.lift(
            try!
    rustCall() {
    
    matrix_sdk_ffi_7e42_SlidingSyncListBuilder_sync_mode(self.pointer, 
        FfiConverterTypeSlidingSyncMode.lower(`mode`), $0
    )
}
        )
    }
    public func `sendUpdatesForItems`(`enable`: Bool)  -> SlidingSyncListBuilder {
        return try! FfiConverterTypeSlidingSyncListBuilder.lift(
            try!
    rustCall() {
    
    matrix_sdk_ffi_7e42_SlidingSyncListBuilder_send_updates_for_items(self.pointer, 
        FfiConverterBool.lower(`enable`), $0
    )
}
        )
    }
    public func `build`() throws -> SlidingSyncList {
        return try FfiConverterTypeSlidingSyncList.lift(
            try
    rustCallWithError(FfiConverterTypeClientError.self) {
    matrix_sdk_ffi_7e42_SlidingSyncListBuilder_build(self.pointer, $0
    )
}
        )
    }
    public func `addRange`(`from`: UInt32, `to`: UInt32)  -> SlidingSyncListBuilder {
        return try! FfiConverterTypeSlidingSyncListBuilder.lift(
            try!
    rustCall() {
    
    _uniffi_matrix_sdk_ffi_impl_SlidingSyncListBuilder_add_range_312a(self.pointer, 
        FfiConverterUInt32.lower(`from`), 
        FfiConverterUInt32.lower(`to`), $0
    )
}
        )
    }
    public func `batchSize`(`batchSize`: UInt32)  -> SlidingSyncListBuilder {
        return try! FfiConverterTypeSlidingSyncListBuilder.lift(
            try!
    rustCall() {
    
    _uniffi_matrix_sdk_ffi_impl_SlidingSyncListBuilder_batch_size_9252(self.pointer, 
        FfiConverterUInt32.lower(`batchSize`), $0
    )
}
        )
    }
    public func `filters`(`filters`: SlidingSyncRequestListFilters)  -> SlidingSyncListBuilder {
        return try! FfiConverterTypeSlidingSyncListBuilder.lift(
            try!
    rustCall() {
    
    _uniffi_matrix_sdk_ffi_impl_SlidingSyncListBuilder_filters_a5ee(self.pointer, 
        FfiConverterTypeSlidingSyncRequestListFilters.lower(`filters`), $0
    )
}
        )
    }
    public func `name`(`name`: String)  -> SlidingSyncListBuilder {
        return try! FfiConverterTypeSlidingSyncListBuilder.lift(
            try!
    rustCall() {
    
    _uniffi_matrix_sdk_ffi_impl_SlidingSyncListBuilder_name_2267(self.pointer, 
        FfiConverterString.lower(`name`), $0
    )
}
        )
    }
    public func `noFilters`()  -> SlidingSyncListBuilder {
        return try! FfiConverterTypeSlidingSyncListBuilder.lift(
            try!
    rustCall() {
    
    _uniffi_matrix_sdk_ffi_impl_SlidingSyncListBuilder_no_filters_aad3(self.pointer, $0
    )
}
        )
    }
    public func `noRoomLimit`()  -> SlidingSyncListBuilder {
        return try! FfiConverterTypeSlidingSyncListBuilder.lift(
            try!
    rustCall() {
    
    _uniffi_matrix_sdk_ffi_impl_SlidingSyncListBuilder_no_room_limit_359(self.pointer, $0
    )
}
        )
    }
    public func `noTimelineLimit`()  -> SlidingSyncListBuilder {
        return try! FfiConverterTypeSlidingSyncListBuilder.lift(
            try!
    rustCall() {
    
    _uniffi_matrix_sdk_ffi_impl_SlidingSyncListBuilder_no_timeline_limit_cf9f(self.pointer, $0
    )
}
        )
    }
    public func `requiredState`(`requiredState`: [RequiredState])  -> SlidingSyncListBuilder {
        return try! FfiConverterTypeSlidingSyncListBuilder.lift(
            try!
    rustCall() {
    
    _uniffi_matrix_sdk_ffi_impl_SlidingSyncListBuilder_required_state_3608(self.pointer, 
        FfiConverterSequenceTypeRequiredState.lower(`requiredState`), $0
    )
}
        )
    }
    public func `resetRanges`()  -> SlidingSyncListBuilder {
        return try! FfiConverterTypeSlidingSyncListBuilder.lift(
            try!
    rustCall() {
    
    _uniffi_matrix_sdk_ffi_impl_SlidingSyncListBuilder_reset_ranges_ee3c(self.pointer, $0
    )
}
        )
    }
    public func `roomLimit`(`limit`: UInt32)  -> SlidingSyncListBuilder {
        return try! FfiConverterTypeSlidingSyncListBuilder.lift(
            try!
    rustCall() {
    
    _uniffi_matrix_sdk_ffi_impl_SlidingSyncListBuilder_room_limit_3023(self.pointer, 
        FfiConverterUInt32.lower(`limit`), $0
    )
}
        )
    }
    public func `sort`(`sort`: [String])  -> SlidingSyncListBuilder {
        return try! FfiConverterTypeSlidingSyncListBuilder.lift(
            try!
    rustCall() {
    
    _uniffi_matrix_sdk_ffi_impl_SlidingSyncListBuilder_sort_8a43(self.pointer, 
        FfiConverterSequenceString.lower(`sort`), $0
    )
}
        )
    }
    public func `timelineLimit`(`limit`: UInt32)  -> SlidingSyncListBuilder {
        return try! FfiConverterTypeSlidingSyncListBuilder.lift(
            try!
    rustCall() {
    
    _uniffi_matrix_sdk_ffi_impl_SlidingSyncListBuilder_timeline_limit_ee74(self.pointer, 
        FfiConverterUInt32.lower(`limit`), $0
    )
}
        )
    }
    
}


public struct FfiConverterTypeSlidingSyncListBuilder: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = SlidingSyncListBuilder

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SlidingSyncListBuilder {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: SlidingSyncListBuilder, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> SlidingSyncListBuilder {
        return SlidingSyncListBuilder(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: SlidingSyncListBuilder) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}


public protocol SlidingSyncRoomProtocol {
    func `subscribeAndAddTimelineListener`(`listener`: TimelineListener, `settings`: RoomSubscription?) throws -> SlidingSyncSubscribeResult
    func `addTimelineListener`(`listener`: TimelineListener) throws -> SlidingSyncSubscribeResult
    func `fullRoom`()  -> Room?
    func `hasUnreadNotifications`()  -> Bool
    func `isDm`()  -> Bool?
    func `isInitial`()  -> Bool?
    func `isLoadingMore`()  -> Bool
    func `latestRoomMessage`()  -> EventTimelineItem?
    func `name`()  -> String?
    func `roomId`()  -> String
    func `unreadNotifications`()  -> UnreadNotificationsCount
    
}

public class SlidingSyncRoom: SlidingSyncRoomProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { ffi_matrix_sdk_ffi_7e42_SlidingSyncRoom_object_free(pointer, $0) }
    }

    

    
    public func `subscribeAndAddTimelineListener`(`listener`: TimelineListener, `settings`: RoomSubscription?) throws -> SlidingSyncSubscribeResult {
        return try FfiConverterTypeSlidingSyncSubscribeResult.lift(
            try
    rustCallWithError(FfiConverterTypeClientError.self) {
    matrix_sdk_ffi_7e42_SlidingSyncRoom_subscribe_and_add_timeline_listener(self.pointer, 
        FfiConverterCallbackInterfaceTimelineListener.lower(`listener`), 
        FfiConverterOptionTypeRoomSubscription.lower(`settings`), $0
    )
}
        )
    }
    public func `addTimelineListener`(`listener`: TimelineListener) throws -> SlidingSyncSubscribeResult {
        return try FfiConverterTypeSlidingSyncSubscribeResult.lift(
            try
    rustCallWithError(FfiConverterTypeClientError.self) {
    matrix_sdk_ffi_7e42_SlidingSyncRoom_add_timeline_listener(self.pointer, 
        FfiConverterCallbackInterfaceTimelineListener.lower(`listener`), $0
    )
}
        )
    }
    public func `fullRoom`()  -> Room? {
        return try! FfiConverterOptionTypeRoom.lift(
            try!
    rustCall() {
    
    _uniffi_matrix_sdk_ffi_impl_SlidingSyncRoom_full_room_1d93(self.pointer, $0
    )
}
        )
    }
    public func `hasUnreadNotifications`()  -> Bool {
        return try! FfiConverterBool.lift(
            try!
    rustCall() {
    
    _uniffi_matrix_sdk_ffi_impl_SlidingSyncRoom_has_unread_notifications_d5da(self.pointer, $0
    )
}
        )
    }
    public func `isDm`()  -> Bool? {
        return try! FfiConverterOptionBool.lift(
            try!
    rustCall() {
    
    _uniffi_matrix_sdk_ffi_impl_SlidingSyncRoom_is_dm_8b22(self.pointer, $0
    )
}
        )
    }
    public func `isInitial`()  -> Bool? {
        return try! FfiConverterOptionBool.lift(
            try!
    rustCall() {
    
    _uniffi_matrix_sdk_ffi_impl_SlidingSyncRoom_is_initial_3e73(self.pointer, $0
    )
}
        )
    }
    public func `isLoadingMore`()  -> Bool {
        return try! FfiConverterBool.lift(
            try!
    rustCall() {
    
    _uniffi_matrix_sdk_ffi_impl_SlidingSyncRoom_is_loading_more_f939(self.pointer, $0
    )
}
        )
    }
    public func `latestRoomMessage`()  -> EventTimelineItem? {
        return try! FfiConverterOptionTypeEventTimelineItem.lift(
            try!
    rustCall() {
    
    _uniffi_matrix_sdk_ffi_impl_SlidingSyncRoom_latest_room_message_747b(self.pointer, $0
    )
}
        )
    }
    public func `name`()  -> String? {
        return try! FfiConverterOptionString.lift(
            try!
    rustCall() {
    
    _uniffi_matrix_sdk_ffi_impl_SlidingSyncRoom_name_59a7(self.pointer, $0
    )
}
        )
    }
    public func `roomId`()  -> String {
        return try! FfiConverterString.lift(
            try!
    rustCall() {
    
    _uniffi_matrix_sdk_ffi_impl_SlidingSyncRoom_room_id_b25f(self.pointer, $0
    )
}
        )
    }
    public func `unreadNotifications`()  -> UnreadNotificationsCount {
        return try! FfiConverterTypeUnreadNotificationsCount.lift(
            try!
    rustCall() {
    
    _uniffi_matrix_sdk_ffi_impl_SlidingSyncRoom_unread_notifications_21b0(self.pointer, $0
    )
}
        )
    }
    
}


public struct FfiConverterTypeSlidingSyncRoom: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = SlidingSyncRoom

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SlidingSyncRoom {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: SlidingSyncRoom, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> SlidingSyncRoom {
        return SlidingSyncRoom(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: SlidingSyncRoom) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}


public protocol TaskHandleProtocol {
    func `cancel`() 
    func `isFinished`()  -> Bool
    
}

public class TaskHandle: TaskHandleProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { ffi_matrix_sdk_ffi_7e42_TaskHandle_object_free(pointer, $0) }
    }

    

    
    public func `cancel`()  {
        try!
    rustCall() {
    
    _uniffi_matrix_sdk_ffi_impl_TaskHandle_cancel_32dd(self.pointer, $0
    )
}
    }
    public func `isFinished`()  -> Bool {
        return try! FfiConverterBool.lift(
            try!
    rustCall() {
    
    _uniffi_matrix_sdk_ffi_impl_TaskHandle_is_finished_d441(self.pointer, $0
    )
}
        )
    }
    
}


public struct FfiConverterTypeTaskHandle: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = TaskHandle

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TaskHandle {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: TaskHandle, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> TaskHandle {
        return TaskHandle(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: TaskHandle) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}


public protocol TimelineDiffProtocol {
    func `append`()  -> [TimelineItem]?
    func `change`()  -> TimelineChange
    func `insert`()  -> InsertData?
    func `pushBack`()  -> TimelineItem?
    func `pushFront`()  -> TimelineItem?
    func `remove`()  -> UInt32?
    func `reset`()  -> [TimelineItem]?
    func `set`()  -> SetData?
    
}

public class TimelineDiff: TimelineDiffProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { ffi_matrix_sdk_ffi_7e42_TimelineDiff_object_free(pointer, $0) }
    }

    

    
    public func `append`()  -> [TimelineItem]? {
        return try! FfiConverterOptionSequenceTypeTimelineItem.lift(
            try!
    rustCall() {
    
    _uniffi_matrix_sdk_ffi_impl_TimelineDiff_append_d860(self.pointer, $0
    )
}
        )
    }
    public func `change`()  -> TimelineChange {
        return try! FfiConverterTypeTimelineChange.lift(
            try!
    rustCall() {
    
    _uniffi_matrix_sdk_ffi_impl_TimelineDiff_change_95d6(self.pointer, $0
    )
}
        )
    }
    public func `insert`()  -> InsertData? {
        return try! FfiConverterOptionTypeInsertData.lift(
            try!
    rustCall() {
    
    _uniffi_matrix_sdk_ffi_impl_TimelineDiff_insert_9db8(self.pointer, $0
    )
}
        )
    }
    public func `pushBack`()  -> TimelineItem? {
        return try! FfiConverterOptionTypeTimelineItem.lift(
            try!
    rustCall() {
    
    _uniffi_matrix_sdk_ffi_impl_TimelineDiff_push_back_78c(self.pointer, $0
    )
}
        )
    }
    public func `pushFront`()  -> TimelineItem? {
        return try! FfiConverterOptionTypeTimelineItem.lift(
            try!
    rustCall() {
    
    _uniffi_matrix_sdk_ffi_impl_TimelineDiff_push_front_e1(self.pointer, $0
    )
}
        )
    }
    public func `remove`()  -> UInt32? {
        return try! FfiConverterOptionUInt32.lift(
            try!
    rustCall() {
    
    _uniffi_matrix_sdk_ffi_impl_TimelineDiff_remove_d332(self.pointer, $0
    )
}
        )
    }
    public func `reset`()  -> [TimelineItem]? {
        return try! FfiConverterOptionSequenceTypeTimelineItem.lift(
            try!
    rustCall() {
    
    _uniffi_matrix_sdk_ffi_impl_TimelineDiff_reset_13cf(self.pointer, $0
    )
}
        )
    }
    public func `set`()  -> SetData? {
        return try! FfiConverterOptionTypeSetData.lift(
            try!
    rustCall() {
    
    _uniffi_matrix_sdk_ffi_impl_TimelineDiff_set_a568(self.pointer, $0
    )
}
        )
    }
    
}


public struct FfiConverterTypeTimelineDiff: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = TimelineDiff

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TimelineDiff {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: TimelineDiff, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> TimelineDiff {
        return TimelineDiff(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: TimelineDiff) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}


public protocol TimelineItemProtocol {
    func `asEvent`()  -> EventTimelineItem?
    func `asVirtual`()  -> VirtualTimelineItem?
    func `fmtDebug`()  -> String
    
}

public class TimelineItem: TimelineItemProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { ffi_matrix_sdk_ffi_7e42_TimelineItem_object_free(pointer, $0) }
    }

    

    
    public func `asEvent`()  -> EventTimelineItem? {
        return try! FfiConverterOptionTypeEventTimelineItem.lift(
            try!
    rustCall() {
    
    _uniffi_matrix_sdk_ffi_impl_TimelineItem_as_event_bdd4(self.pointer, $0
    )
}
        )
    }
    public func `asVirtual`()  -> VirtualTimelineItem? {
        return try! FfiConverterOptionTypeVirtualTimelineItem.lift(
            try!
    rustCall() {
    
    _uniffi_matrix_sdk_ffi_impl_TimelineItem_as_virtual_c1a3(self.pointer, $0
    )
}
        )
    }
    public func `fmtDebug`()  -> String {
        return try! FfiConverterString.lift(
            try!
    rustCall() {
    
    _uniffi_matrix_sdk_ffi_impl_TimelineItem_fmt_debug_9284(self.pointer, $0
    )
}
        )
    }
    
}


public struct FfiConverterTypeTimelineItem: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = TimelineItem

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TimelineItem {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: TimelineItem, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> TimelineItem {
        return TimelineItem(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: TimelineItem) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}


public protocol TimelineItemContentProtocol {
    func `asMessage`()  -> Message?
    func `kind`()  -> TimelineItemContentKind
    
}

public class TimelineItemContent: TimelineItemContentProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { _uniffi_matrix_sdk_ffi_object_free_TimelineItemContent_2b31(pointer, $0) }
    }

    

    
    public func `asMessage`()  -> Message? {
        return try! FfiConverterOptionTypeMessage.lift(
            try!
    rustCall() {
    
    _uniffi_matrix_sdk_ffi_impl_TimelineItemContent_as_message_667f(self.pointer, $0
    )
}
        )
    }
    public func `kind`()  -> TimelineItemContentKind {
        return try! FfiConverterTypeTimelineItemContentKind.lift(
            try!
    rustCall() {
    
    _uniffi_matrix_sdk_ffi_impl_TimelineItemContent_kind_9185(self.pointer, $0
    )
}
        )
    }
    
}


public struct FfiConverterTypeTimelineItemContent: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = TimelineItemContent

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TimelineItemContent {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: TimelineItemContent, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> TimelineItemContent {
        return TimelineItemContent(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: TimelineItemContent) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}


public protocol UnreadNotificationsCountProtocol {
    func `hasNotifications`()  -> Bool
    func `highlightCount`()  -> UInt32
    func `notificationCount`()  -> UInt32
    
}

public class UnreadNotificationsCount: UnreadNotificationsCountProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { _uniffi_matrix_sdk_ffi_object_free_UnreadNotificationsCount_b323(pointer, $0) }
    }

    

    
    public func `hasNotifications`()  -> Bool {
        return try! FfiConverterBool.lift(
            try!
    rustCall() {
    
    _uniffi_matrix_sdk_ffi_impl_UnreadNotificationsCount_has_notifications_727e(self.pointer, $0
    )
}
        )
    }
    public func `highlightCount`()  -> UInt32 {
        return try! FfiConverterUInt32.lift(
            try!
    rustCall() {
    
    _uniffi_matrix_sdk_ffi_impl_UnreadNotificationsCount_highlight_count_67f9(self.pointer, $0
    )
}
        )
    }
    public func `notificationCount`()  -> UInt32 {
        return try! FfiConverterUInt32.lift(
            try!
    rustCall() {
    
    _uniffi_matrix_sdk_ffi_impl_UnreadNotificationsCount_notification_count_808c(self.pointer, $0
    )
}
        )
    }
    
}


public struct FfiConverterTypeUnreadNotificationsCount: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = UnreadNotificationsCount

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UnreadNotificationsCount {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: UnreadNotificationsCount, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> UnreadNotificationsCount {
        return UnreadNotificationsCount(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: UnreadNotificationsCount) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}


public struct AudioInfo {
    public var `duration`: UInt64?
    public var `size`: UInt64?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`duration`: UInt64?, `size`: UInt64?) {
        self.`duration` = `duration`
        self.`size` = `size`
    }
}


extension AudioInfo: Equatable, Hashable {
    public static func ==(lhs: AudioInfo, rhs: AudioInfo) -> Bool {
        if lhs.`duration` != rhs.`duration` {
            return false
        }
        if lhs.`size` != rhs.`size` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`duration`)
        hasher.combine(`size`)
    }
}


public struct FfiConverterTypeAudioInfo: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AudioInfo {
        return try AudioInfo(
            `duration`: FfiConverterOptionUInt64.read(from: &buf), 
            `size`: FfiConverterOptionUInt64.read(from: &buf)
        )
    }

    public static func write(_ value: AudioInfo, into buf: inout [UInt8]) {
        FfiConverterOptionUInt64.write(value.`duration`, into: &buf)
        FfiConverterOptionUInt64.write(value.`size`, into: &buf)
    }
}


public func FfiConverterTypeAudioInfo_lift(_ buf: RustBuffer) throws -> AudioInfo {
    return try FfiConverterTypeAudioInfo.lift(buf)
}

public func FfiConverterTypeAudioInfo_lower(_ value: AudioInfo) -> RustBuffer {
    return FfiConverterTypeAudioInfo.lower(value)
}


public struct AudioMessageContent {
    public var `body`: String
    public var `source`: MediaSource
    public var `info`: AudioInfo?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`body`: String, `source`: MediaSource, `info`: AudioInfo?) {
        self.`body` = `body`
        self.`source` = `source`
        self.`info` = `info`
    }
}



public struct FfiConverterTypeAudioMessageContent: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AudioMessageContent {
        return try AudioMessageContent(
            `body`: FfiConverterString.read(from: &buf), 
            `source`: FfiConverterTypeMediaSource.read(from: &buf), 
            `info`: FfiConverterOptionTypeAudioInfo.read(from: &buf)
        )
    }

    public static func write(_ value: AudioMessageContent, into buf: inout [UInt8]) {
        FfiConverterString.write(value.`body`, into: &buf)
        FfiConverterTypeMediaSource.write(value.`source`, into: &buf)
        FfiConverterOptionTypeAudioInfo.write(value.`info`, into: &buf)
    }
}


public func FfiConverterTypeAudioMessageContent_lift(_ buf: RustBuffer) throws -> AudioMessageContent {
    return try FfiConverterTypeAudioMessageContent.lift(buf)
}

public func FfiConverterTypeAudioMessageContent_lower(_ value: AudioMessageContent) -> RustBuffer {
    return FfiConverterTypeAudioMessageContent.lower(value)
}


public struct EmoteMessageContent {
    public var `body`: String
    public var `formatted`: FormattedBody?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`body`: String, `formatted`: FormattedBody?) {
        self.`body` = `body`
        self.`formatted` = `formatted`
    }
}


extension EmoteMessageContent: Equatable, Hashable {
    public static func ==(lhs: EmoteMessageContent, rhs: EmoteMessageContent) -> Bool {
        if lhs.`body` != rhs.`body` {
            return false
        }
        if lhs.`formatted` != rhs.`formatted` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`body`)
        hasher.combine(`formatted`)
    }
}


public struct FfiConverterTypeEmoteMessageContent: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> EmoteMessageContent {
        return try EmoteMessageContent(
            `body`: FfiConverterString.read(from: &buf), 
            `formatted`: FfiConverterOptionTypeFormattedBody.read(from: &buf)
        )
    }

    public static func write(_ value: EmoteMessageContent, into buf: inout [UInt8]) {
        FfiConverterString.write(value.`body`, into: &buf)
        FfiConverterOptionTypeFormattedBody.write(value.`formatted`, into: &buf)
    }
}


public func FfiConverterTypeEmoteMessageContent_lift(_ buf: RustBuffer) throws -> EmoteMessageContent {
    return try FfiConverterTypeEmoteMessageContent.lift(buf)
}

public func FfiConverterTypeEmoteMessageContent_lower(_ value: EmoteMessageContent) -> RustBuffer {
    return FfiConverterTypeEmoteMessageContent.lower(value)
}


public struct FileInfo {
    public var `mimetype`: String?
    public var `size`: UInt64?
    public var `thumbnailInfo`: ThumbnailInfo?
    public var `thumbnailSource`: MediaSource?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`mimetype`: String?, `size`: UInt64?, `thumbnailInfo`: ThumbnailInfo?, `thumbnailSource`: MediaSource?) {
        self.`mimetype` = `mimetype`
        self.`size` = `size`
        self.`thumbnailInfo` = `thumbnailInfo`
        self.`thumbnailSource` = `thumbnailSource`
    }
}



public struct FfiConverterTypeFileInfo: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FileInfo {
        return try FileInfo(
            `mimetype`: FfiConverterOptionString.read(from: &buf), 
            `size`: FfiConverterOptionUInt64.read(from: &buf), 
            `thumbnailInfo`: FfiConverterOptionTypeThumbnailInfo.read(from: &buf), 
            `thumbnailSource`: FfiConverterOptionTypeMediaSource.read(from: &buf)
        )
    }

    public static func write(_ value: FileInfo, into buf: inout [UInt8]) {
        FfiConverterOptionString.write(value.`mimetype`, into: &buf)
        FfiConverterOptionUInt64.write(value.`size`, into: &buf)
        FfiConverterOptionTypeThumbnailInfo.write(value.`thumbnailInfo`, into: &buf)
        FfiConverterOptionTypeMediaSource.write(value.`thumbnailSource`, into: &buf)
    }
}


public func FfiConverterTypeFileInfo_lift(_ buf: RustBuffer) throws -> FileInfo {
    return try FfiConverterTypeFileInfo.lift(buf)
}

public func FfiConverterTypeFileInfo_lower(_ value: FileInfo) -> RustBuffer {
    return FfiConverterTypeFileInfo.lower(value)
}


public struct FileMessageContent {
    public var `body`: String
    public var `source`: MediaSource
    public var `info`: FileInfo?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`body`: String, `source`: MediaSource, `info`: FileInfo?) {
        self.`body` = `body`
        self.`source` = `source`
        self.`info` = `info`
    }
}



public struct FfiConverterTypeFileMessageContent: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FileMessageContent {
        return try FileMessageContent(
            `body`: FfiConverterString.read(from: &buf), 
            `source`: FfiConverterTypeMediaSource.read(from: &buf), 
            `info`: FfiConverterOptionTypeFileInfo.read(from: &buf)
        )
    }

    public static func write(_ value: FileMessageContent, into buf: inout [UInt8]) {
        FfiConverterString.write(value.`body`, into: &buf)
        FfiConverterTypeMediaSource.write(value.`source`, into: &buf)
        FfiConverterOptionTypeFileInfo.write(value.`info`, into: &buf)
    }
}


public func FfiConverterTypeFileMessageContent_lift(_ buf: RustBuffer) throws -> FileMessageContent {
    return try FfiConverterTypeFileMessageContent.lift(buf)
}

public func FfiConverterTypeFileMessageContent_lower(_ value: FileMessageContent) -> RustBuffer {
    return FfiConverterTypeFileMessageContent.lower(value)
}


public struct FormattedBody {
    public var `format`: MessageFormat
    public var `body`: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`format`: MessageFormat, `body`: String) {
        self.`format` = `format`
        self.`body` = `body`
    }
}


extension FormattedBody: Equatable, Hashable {
    public static func ==(lhs: FormattedBody, rhs: FormattedBody) -> Bool {
        if lhs.`format` != rhs.`format` {
            return false
        }
        if lhs.`body` != rhs.`body` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`format`)
        hasher.combine(`body`)
    }
}


public struct FfiConverterTypeFormattedBody: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FormattedBody {
        return try FormattedBody(
            `format`: FfiConverterTypeMessageFormat.read(from: &buf), 
            `body`: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: FormattedBody, into buf: inout [UInt8]) {
        FfiConverterTypeMessageFormat.write(value.`format`, into: &buf)
        FfiConverterString.write(value.`body`, into: &buf)
    }
}


public func FfiConverterTypeFormattedBody_lift(_ buf: RustBuffer) throws -> FormattedBody {
    return try FfiConverterTypeFormattedBody.lift(buf)
}

public func FfiConverterTypeFormattedBody_lower(_ value: FormattedBody) -> RustBuffer {
    return FfiConverterTypeFormattedBody.lower(value)
}


public struct ImageInfo {
    public var `height`: UInt64?
    public var `width`: UInt64?
    public var `mimetype`: String?
    public var `size`: UInt64?
    public var `thumbnailInfo`: ThumbnailInfo?
    public var `thumbnailSource`: MediaSource?
    public var `blurhash`: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`height`: UInt64?, `width`: UInt64?, `mimetype`: String?, `size`: UInt64?, `thumbnailInfo`: ThumbnailInfo?, `thumbnailSource`: MediaSource?, `blurhash`: String?) {
        self.`height` = `height`
        self.`width` = `width`
        self.`mimetype` = `mimetype`
        self.`size` = `size`
        self.`thumbnailInfo` = `thumbnailInfo`
        self.`thumbnailSource` = `thumbnailSource`
        self.`blurhash` = `blurhash`
    }
}



public struct FfiConverterTypeImageInfo: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ImageInfo {
        return try ImageInfo(
            `height`: FfiConverterOptionUInt64.read(from: &buf), 
            `width`: FfiConverterOptionUInt64.read(from: &buf), 
            `mimetype`: FfiConverterOptionString.read(from: &buf), 
            `size`: FfiConverterOptionUInt64.read(from: &buf), 
            `thumbnailInfo`: FfiConverterOptionTypeThumbnailInfo.read(from: &buf), 
            `thumbnailSource`: FfiConverterOptionTypeMediaSource.read(from: &buf), 
            `blurhash`: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: ImageInfo, into buf: inout [UInt8]) {
        FfiConverterOptionUInt64.write(value.`height`, into: &buf)
        FfiConverterOptionUInt64.write(value.`width`, into: &buf)
        FfiConverterOptionString.write(value.`mimetype`, into: &buf)
        FfiConverterOptionUInt64.write(value.`size`, into: &buf)
        FfiConverterOptionTypeThumbnailInfo.write(value.`thumbnailInfo`, into: &buf)
        FfiConverterOptionTypeMediaSource.write(value.`thumbnailSource`, into: &buf)
        FfiConverterOptionString.write(value.`blurhash`, into: &buf)
    }
}


public func FfiConverterTypeImageInfo_lift(_ buf: RustBuffer) throws -> ImageInfo {
    return try FfiConverterTypeImageInfo.lift(buf)
}

public func FfiConverterTypeImageInfo_lower(_ value: ImageInfo) -> RustBuffer {
    return FfiConverterTypeImageInfo.lower(value)
}


public struct ImageMessageContent {
    public var `body`: String
    public var `source`: MediaSource
    public var `info`: ImageInfo?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`body`: String, `source`: MediaSource, `info`: ImageInfo?) {
        self.`body` = `body`
        self.`source` = `source`
        self.`info` = `info`
    }
}



public struct FfiConverterTypeImageMessageContent: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ImageMessageContent {
        return try ImageMessageContent(
            `body`: FfiConverterString.read(from: &buf), 
            `source`: FfiConverterTypeMediaSource.read(from: &buf), 
            `info`: FfiConverterOptionTypeImageInfo.read(from: &buf)
        )
    }

    public static func write(_ value: ImageMessageContent, into buf: inout [UInt8]) {
        FfiConverterString.write(value.`body`, into: &buf)
        FfiConverterTypeMediaSource.write(value.`source`, into: &buf)
        FfiConverterOptionTypeImageInfo.write(value.`info`, into: &buf)
    }
}


public func FfiConverterTypeImageMessageContent_lift(_ buf: RustBuffer) throws -> ImageMessageContent {
    return try FfiConverterTypeImageMessageContent.lift(buf)
}

public func FfiConverterTypeImageMessageContent_lower(_ value: ImageMessageContent) -> RustBuffer {
    return FfiConverterTypeImageMessageContent.lower(value)
}


public struct InsertData {
    public var `index`: UInt32
    public var `item`: TimelineItem

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`index`: UInt32, `item`: TimelineItem) {
        self.`index` = `index`
        self.`item` = `item`
    }
}



public struct FfiConverterTypeInsertData: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> InsertData {
        return try InsertData(
            `index`: FfiConverterUInt32.read(from: &buf), 
            `item`: FfiConverterTypeTimelineItem.read(from: &buf)
        )
    }

    public static func write(_ value: InsertData, into buf: inout [UInt8]) {
        FfiConverterUInt32.write(value.`index`, into: &buf)
        FfiConverterTypeTimelineItem.write(value.`item`, into: &buf)
    }
}


public func FfiConverterTypeInsertData_lift(_ buf: RustBuffer) throws -> InsertData {
    return try FfiConverterTypeInsertData.lift(buf)
}

public func FfiConverterTypeInsertData_lower(_ value: InsertData) -> RustBuffer {
    return FfiConverterTypeInsertData.lower(value)
}


public struct MoveData {
    public var `oldIndex`: UInt32
    public var `newIndex`: UInt32

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`oldIndex`: UInt32, `newIndex`: UInt32) {
        self.`oldIndex` = `oldIndex`
        self.`newIndex` = `newIndex`
    }
}


extension MoveData: Equatable, Hashable {
    public static func ==(lhs: MoveData, rhs: MoveData) -> Bool {
        if lhs.`oldIndex` != rhs.`oldIndex` {
            return false
        }
        if lhs.`newIndex` != rhs.`newIndex` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`oldIndex`)
        hasher.combine(`newIndex`)
    }
}


public struct FfiConverterTypeMoveData: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MoveData {
        return try MoveData(
            `oldIndex`: FfiConverterUInt32.read(from: &buf), 
            `newIndex`: FfiConverterUInt32.read(from: &buf)
        )
    }

    public static func write(_ value: MoveData, into buf: inout [UInt8]) {
        FfiConverterUInt32.write(value.`oldIndex`, into: &buf)
        FfiConverterUInt32.write(value.`newIndex`, into: &buf)
    }
}


public func FfiConverterTypeMoveData_lift(_ buf: RustBuffer) throws -> MoveData {
    return try FfiConverterTypeMoveData.lift(buf)
}

public func FfiConverterTypeMoveData_lower(_ value: MoveData) -> RustBuffer {
    return FfiConverterTypeMoveData.lower(value)
}


public struct NoticeMessageContent {
    public var `body`: String
    public var `formatted`: FormattedBody?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`body`: String, `formatted`: FormattedBody?) {
        self.`body` = `body`
        self.`formatted` = `formatted`
    }
}


extension NoticeMessageContent: Equatable, Hashable {
    public static func ==(lhs: NoticeMessageContent, rhs: NoticeMessageContent) -> Bool {
        if lhs.`body` != rhs.`body` {
            return false
        }
        if lhs.`formatted` != rhs.`formatted` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`body`)
        hasher.combine(`formatted`)
    }
}


public struct FfiConverterTypeNoticeMessageContent: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NoticeMessageContent {
        return try NoticeMessageContent(
            `body`: FfiConverterString.read(from: &buf), 
            `formatted`: FfiConverterOptionTypeFormattedBody.read(from: &buf)
        )
    }

    public static func write(_ value: NoticeMessageContent, into buf: inout [UInt8]) {
        FfiConverterString.write(value.`body`, into: &buf)
        FfiConverterOptionTypeFormattedBody.write(value.`formatted`, into: &buf)
    }
}


public func FfiConverterTypeNoticeMessageContent_lift(_ buf: RustBuffer) throws -> NoticeMessageContent {
    return try FfiConverterTypeNoticeMessageContent.lift(buf)
}

public func FfiConverterTypeNoticeMessageContent_lower(_ value: NoticeMessageContent) -> RustBuffer {
    return FfiConverterTypeNoticeMessageContent.lower(value)
}


public struct Reaction {
    public var `key`: String
    public var `count`: UInt64

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`key`: String, `count`: UInt64) {
        self.`key` = `key`
        self.`count` = `count`
    }
}


extension Reaction: Equatable, Hashable {
    public static func ==(lhs: Reaction, rhs: Reaction) -> Bool {
        if lhs.`key` != rhs.`key` {
            return false
        }
        if lhs.`count` != rhs.`count` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`key`)
        hasher.combine(`count`)
    }
}


public struct FfiConverterTypeReaction: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Reaction {
        return try Reaction(
            `key`: FfiConverterString.read(from: &buf), 
            `count`: FfiConverterUInt64.read(from: &buf)
        )
    }

    public static func write(_ value: Reaction, into buf: inout [UInt8]) {
        FfiConverterString.write(value.`key`, into: &buf)
        FfiConverterUInt64.write(value.`count`, into: &buf)
    }
}


public func FfiConverterTypeReaction_lift(_ buf: RustBuffer) throws -> Reaction {
    return try FfiConverterTypeReaction.lift(buf)
}

public func FfiConverterTypeReaction_lower(_ value: Reaction) -> RustBuffer {
    return FfiConverterTypeReaction.lower(value)
}


public struct RequiredState {
    public var `key`: String
    public var `value`: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`key`: String, `value`: String) {
        self.`key` = `key`
        self.`value` = `value`
    }
}


extension RequiredState: Equatable, Hashable {
    public static func ==(lhs: RequiredState, rhs: RequiredState) -> Bool {
        if lhs.`key` != rhs.`key` {
            return false
        }
        if lhs.`value` != rhs.`value` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`key`)
        hasher.combine(`value`)
    }
}


public struct FfiConverterTypeRequiredState: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RequiredState {
        return try RequiredState(
            `key`: FfiConverterString.read(from: &buf), 
            `value`: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: RequiredState, into buf: inout [UInt8]) {
        FfiConverterString.write(value.`key`, into: &buf)
        FfiConverterString.write(value.`value`, into: &buf)
    }
}


public func FfiConverterTypeRequiredState_lift(_ buf: RustBuffer) throws -> RequiredState {
    return try FfiConverterTypeRequiredState.lift(buf)
}

public func FfiConverterTypeRequiredState_lower(_ value: RequiredState) -> RustBuffer {
    return FfiConverterTypeRequiredState.lower(value)
}


public struct RoomMember {
    public var `userId`: String
    public var `displayName`: String?
    public var `avatarUrl`: String?
    public var `membership`: MembershipState
    public var `isNameAmbiguous`: Bool
    public var `powerLevel`: Int64
    public var `normalizedPowerLevel`: Int64

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`userId`: String, `displayName`: String?, `avatarUrl`: String?, `membership`: MembershipState, `isNameAmbiguous`: Bool, `powerLevel`: Int64, `normalizedPowerLevel`: Int64) {
        self.`userId` = `userId`
        self.`displayName` = `displayName`
        self.`avatarUrl` = `avatarUrl`
        self.`membership` = `membership`
        self.`isNameAmbiguous` = `isNameAmbiguous`
        self.`powerLevel` = `powerLevel`
        self.`normalizedPowerLevel` = `normalizedPowerLevel`
    }
}


extension RoomMember: Equatable, Hashable {
    public static func ==(lhs: RoomMember, rhs: RoomMember) -> Bool {
        if lhs.`userId` != rhs.`userId` {
            return false
        }
        if lhs.`displayName` != rhs.`displayName` {
            return false
        }
        if lhs.`avatarUrl` != rhs.`avatarUrl` {
            return false
        }
        if lhs.`membership` != rhs.`membership` {
            return false
        }
        if lhs.`isNameAmbiguous` != rhs.`isNameAmbiguous` {
            return false
        }
        if lhs.`powerLevel` != rhs.`powerLevel` {
            return false
        }
        if lhs.`normalizedPowerLevel` != rhs.`normalizedPowerLevel` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`userId`)
        hasher.combine(`displayName`)
        hasher.combine(`avatarUrl`)
        hasher.combine(`membership`)
        hasher.combine(`isNameAmbiguous`)
        hasher.combine(`powerLevel`)
        hasher.combine(`normalizedPowerLevel`)
    }
}


public struct FfiConverterTypeRoomMember: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RoomMember {
        return try RoomMember(
            `userId`: FfiConverterString.read(from: &buf), 
            `displayName`: FfiConverterOptionString.read(from: &buf), 
            `avatarUrl`: FfiConverterOptionString.read(from: &buf), 
            `membership`: FfiConverterTypeMembershipState.read(from: &buf), 
            `isNameAmbiguous`: FfiConverterBool.read(from: &buf), 
            `powerLevel`: FfiConverterInt64.read(from: &buf), 
            `normalizedPowerLevel`: FfiConverterInt64.read(from: &buf)
        )
    }

    public static func write(_ value: RoomMember, into buf: inout [UInt8]) {
        FfiConverterString.write(value.`userId`, into: &buf)
        FfiConverterOptionString.write(value.`displayName`, into: &buf)
        FfiConverterOptionString.write(value.`avatarUrl`, into: &buf)
        FfiConverterTypeMembershipState.write(value.`membership`, into: &buf)
        FfiConverterBool.write(value.`isNameAmbiguous`, into: &buf)
        FfiConverterInt64.write(value.`powerLevel`, into: &buf)
        FfiConverterInt64.write(value.`normalizedPowerLevel`, into: &buf)
    }
}


public func FfiConverterTypeRoomMember_lift(_ buf: RustBuffer) throws -> RoomMember {
    return try FfiConverterTypeRoomMember.lift(buf)
}

public func FfiConverterTypeRoomMember_lower(_ value: RoomMember) -> RustBuffer {
    return FfiConverterTypeRoomMember.lower(value)
}


public struct RoomSubscription {
    public var `requiredState`: [RequiredState]?
    public var `timelineLimit`: UInt32?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`requiredState`: [RequiredState]?, `timelineLimit`: UInt32?) {
        self.`requiredState` = `requiredState`
        self.`timelineLimit` = `timelineLimit`
    }
}


extension RoomSubscription: Equatable, Hashable {
    public static func ==(lhs: RoomSubscription, rhs: RoomSubscription) -> Bool {
        if lhs.`requiredState` != rhs.`requiredState` {
            return false
        }
        if lhs.`timelineLimit` != rhs.`timelineLimit` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`requiredState`)
        hasher.combine(`timelineLimit`)
    }
}


public struct FfiConverterTypeRoomSubscription: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RoomSubscription {
        return try RoomSubscription(
            `requiredState`: FfiConverterOptionSequenceTypeRequiredState.read(from: &buf), 
            `timelineLimit`: FfiConverterOptionUInt32.read(from: &buf)
        )
    }

    public static func write(_ value: RoomSubscription, into buf: inout [UInt8]) {
        FfiConverterOptionSequenceTypeRequiredState.write(value.`requiredState`, into: &buf)
        FfiConverterOptionUInt32.write(value.`timelineLimit`, into: &buf)
    }
}


public func FfiConverterTypeRoomSubscription_lift(_ buf: RustBuffer) throws -> RoomSubscription {
    return try FfiConverterTypeRoomSubscription.lift(buf)
}

public func FfiConverterTypeRoomSubscription_lower(_ value: RoomSubscription) -> RustBuffer {
    return FfiConverterTypeRoomSubscription.lower(value)
}


public struct Session {
    public var `accessToken`: String
    public var `refreshToken`: String?
    public var `userId`: String
    public var `deviceId`: String
    public var `homeserverUrl`: String
    public var `isSoftLogout`: Bool
    public var `slidingSyncProxy`: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`accessToken`: String, `refreshToken`: String?, `userId`: String, `deviceId`: String, `homeserverUrl`: String, `isSoftLogout`: Bool, `slidingSyncProxy`: String?) {
        self.`accessToken` = `accessToken`
        self.`refreshToken` = `refreshToken`
        self.`userId` = `userId`
        self.`deviceId` = `deviceId`
        self.`homeserverUrl` = `homeserverUrl`
        self.`isSoftLogout` = `isSoftLogout`
        self.`slidingSyncProxy` = `slidingSyncProxy`
    }
}


extension Session: Equatable, Hashable {
    public static func ==(lhs: Session, rhs: Session) -> Bool {
        if lhs.`accessToken` != rhs.`accessToken` {
            return false
        }
        if lhs.`refreshToken` != rhs.`refreshToken` {
            return false
        }
        if lhs.`userId` != rhs.`userId` {
            return false
        }
        if lhs.`deviceId` != rhs.`deviceId` {
            return false
        }
        if lhs.`homeserverUrl` != rhs.`homeserverUrl` {
            return false
        }
        if lhs.`isSoftLogout` != rhs.`isSoftLogout` {
            return false
        }
        if lhs.`slidingSyncProxy` != rhs.`slidingSyncProxy` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`accessToken`)
        hasher.combine(`refreshToken`)
        hasher.combine(`userId`)
        hasher.combine(`deviceId`)
        hasher.combine(`homeserverUrl`)
        hasher.combine(`isSoftLogout`)
        hasher.combine(`slidingSyncProxy`)
    }
}


public struct FfiConverterTypeSession: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Session {
        return try Session(
            `accessToken`: FfiConverterString.read(from: &buf), 
            `refreshToken`: FfiConverterOptionString.read(from: &buf), 
            `userId`: FfiConverterString.read(from: &buf), 
            `deviceId`: FfiConverterString.read(from: &buf), 
            `homeserverUrl`: FfiConverterString.read(from: &buf), 
            `isSoftLogout`: FfiConverterBool.read(from: &buf), 
            `slidingSyncProxy`: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: Session, into buf: inout [UInt8]) {
        FfiConverterString.write(value.`accessToken`, into: &buf)
        FfiConverterOptionString.write(value.`refreshToken`, into: &buf)
        FfiConverterString.write(value.`userId`, into: &buf)
        FfiConverterString.write(value.`deviceId`, into: &buf)
        FfiConverterString.write(value.`homeserverUrl`, into: &buf)
        FfiConverterBool.write(value.`isSoftLogout`, into: &buf)
        FfiConverterOptionString.write(value.`slidingSyncProxy`, into: &buf)
    }
}


public func FfiConverterTypeSession_lift(_ buf: RustBuffer) throws -> Session {
    return try FfiConverterTypeSession.lift(buf)
}

public func FfiConverterTypeSession_lower(_ value: Session) -> RustBuffer {
    return FfiConverterTypeSession.lower(value)
}


public struct SetData {
    public var `index`: UInt32
    public var `item`: TimelineItem

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`index`: UInt32, `item`: TimelineItem) {
        self.`index` = `index`
        self.`item` = `item`
    }
}



public struct FfiConverterTypeSetData: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SetData {
        return try SetData(
            `index`: FfiConverterUInt32.read(from: &buf), 
            `item`: FfiConverterTypeTimelineItem.read(from: &buf)
        )
    }

    public static func write(_ value: SetData, into buf: inout [UInt8]) {
        FfiConverterUInt32.write(value.`index`, into: &buf)
        FfiConverterTypeTimelineItem.write(value.`item`, into: &buf)
    }
}


public func FfiConverterTypeSetData_lift(_ buf: RustBuffer) throws -> SetData {
    return try FfiConverterTypeSetData.lift(buf)
}

public func FfiConverterTypeSetData_lower(_ value: SetData) -> RustBuffer {
    return FfiConverterTypeSetData.lower(value)
}


public struct SlidingSyncRequestListFilters {
    public var `isDm`: Bool?
    public var `spaces`: [String]
    public var `isEncrypted`: Bool?
    public var `isInvite`: Bool?
    public var `isTombstoned`: Bool?
    public var `roomTypes`: [String]
    public var `notRoomTypes`: [String]
    public var `roomNameLike`: String?
    public var `tags`: [String]
    public var `notTags`: [String]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`isDm`: Bool?, `spaces`: [String], `isEncrypted`: Bool?, `isInvite`: Bool?, `isTombstoned`: Bool?, `roomTypes`: [String], `notRoomTypes`: [String], `roomNameLike`: String?, `tags`: [String], `notTags`: [String]) {
        self.`isDm` = `isDm`
        self.`spaces` = `spaces`
        self.`isEncrypted` = `isEncrypted`
        self.`isInvite` = `isInvite`
        self.`isTombstoned` = `isTombstoned`
        self.`roomTypes` = `roomTypes`
        self.`notRoomTypes` = `notRoomTypes`
        self.`roomNameLike` = `roomNameLike`
        self.`tags` = `tags`
        self.`notTags` = `notTags`
    }
}


extension SlidingSyncRequestListFilters: Equatable, Hashable {
    public static func ==(lhs: SlidingSyncRequestListFilters, rhs: SlidingSyncRequestListFilters) -> Bool {
        if lhs.`isDm` != rhs.`isDm` {
            return false
        }
        if lhs.`spaces` != rhs.`spaces` {
            return false
        }
        if lhs.`isEncrypted` != rhs.`isEncrypted` {
            return false
        }
        if lhs.`isInvite` != rhs.`isInvite` {
            return false
        }
        if lhs.`isTombstoned` != rhs.`isTombstoned` {
            return false
        }
        if lhs.`roomTypes` != rhs.`roomTypes` {
            return false
        }
        if lhs.`notRoomTypes` != rhs.`notRoomTypes` {
            return false
        }
        if lhs.`roomNameLike` != rhs.`roomNameLike` {
            return false
        }
        if lhs.`tags` != rhs.`tags` {
            return false
        }
        if lhs.`notTags` != rhs.`notTags` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`isDm`)
        hasher.combine(`spaces`)
        hasher.combine(`isEncrypted`)
        hasher.combine(`isInvite`)
        hasher.combine(`isTombstoned`)
        hasher.combine(`roomTypes`)
        hasher.combine(`notRoomTypes`)
        hasher.combine(`roomNameLike`)
        hasher.combine(`tags`)
        hasher.combine(`notTags`)
    }
}


public struct FfiConverterTypeSlidingSyncRequestListFilters: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SlidingSyncRequestListFilters {
        return try SlidingSyncRequestListFilters(
            `isDm`: FfiConverterOptionBool.read(from: &buf), 
            `spaces`: FfiConverterSequenceString.read(from: &buf), 
            `isEncrypted`: FfiConverterOptionBool.read(from: &buf), 
            `isInvite`: FfiConverterOptionBool.read(from: &buf), 
            `isTombstoned`: FfiConverterOptionBool.read(from: &buf), 
            `roomTypes`: FfiConverterSequenceString.read(from: &buf), 
            `notRoomTypes`: FfiConverterSequenceString.read(from: &buf), 
            `roomNameLike`: FfiConverterOptionString.read(from: &buf), 
            `tags`: FfiConverterSequenceString.read(from: &buf), 
            `notTags`: FfiConverterSequenceString.read(from: &buf)
        )
    }

    public static func write(_ value: SlidingSyncRequestListFilters, into buf: inout [UInt8]) {
        FfiConverterOptionBool.write(value.`isDm`, into: &buf)
        FfiConverterSequenceString.write(value.`spaces`, into: &buf)
        FfiConverterOptionBool.write(value.`isEncrypted`, into: &buf)
        FfiConverterOptionBool.write(value.`isInvite`, into: &buf)
        FfiConverterOptionBool.write(value.`isTombstoned`, into: &buf)
        FfiConverterSequenceString.write(value.`roomTypes`, into: &buf)
        FfiConverterSequenceString.write(value.`notRoomTypes`, into: &buf)
        FfiConverterOptionString.write(value.`roomNameLike`, into: &buf)
        FfiConverterSequenceString.write(value.`tags`, into: &buf)
        FfiConverterSequenceString.write(value.`notTags`, into: &buf)
    }
}


public func FfiConverterTypeSlidingSyncRequestListFilters_lift(_ buf: RustBuffer) throws -> SlidingSyncRequestListFilters {
    return try FfiConverterTypeSlidingSyncRequestListFilters.lift(buf)
}

public func FfiConverterTypeSlidingSyncRequestListFilters_lower(_ value: SlidingSyncRequestListFilters) -> RustBuffer {
    return FfiConverterTypeSlidingSyncRequestListFilters.lower(value)
}


public struct SlidingSyncSubscribeResult {
    public var `items`: [TimelineItem]
    public var `taskHandle`: TaskHandle

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`items`: [TimelineItem], `taskHandle`: TaskHandle) {
        self.`items` = `items`
        self.`taskHandle` = `taskHandle`
    }
}



public struct FfiConverterTypeSlidingSyncSubscribeResult: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SlidingSyncSubscribeResult {
        return try SlidingSyncSubscribeResult(
            `items`: FfiConverterSequenceTypeTimelineItem.read(from: &buf), 
            `taskHandle`: FfiConverterTypeTaskHandle.read(from: &buf)
        )
    }

    public static func write(_ value: SlidingSyncSubscribeResult, into buf: inout [UInt8]) {
        FfiConverterSequenceTypeTimelineItem.write(value.`items`, into: &buf)
        FfiConverterTypeTaskHandle.write(value.`taskHandle`, into: &buf)
    }
}


public func FfiConverterTypeSlidingSyncSubscribeResult_lift(_ buf: RustBuffer) throws -> SlidingSyncSubscribeResult {
    return try FfiConverterTypeSlidingSyncSubscribeResult.lift(buf)
}

public func FfiConverterTypeSlidingSyncSubscribeResult_lower(_ value: SlidingSyncSubscribeResult) -> RustBuffer {
    return FfiConverterTypeSlidingSyncSubscribeResult.lower(value)
}


public struct TextMessageContent {
    public var `body`: String
    public var `formatted`: FormattedBody?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`body`: String, `formatted`: FormattedBody?) {
        self.`body` = `body`
        self.`formatted` = `formatted`
    }
}


extension TextMessageContent: Equatable, Hashable {
    public static func ==(lhs: TextMessageContent, rhs: TextMessageContent) -> Bool {
        if lhs.`body` != rhs.`body` {
            return false
        }
        if lhs.`formatted` != rhs.`formatted` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`body`)
        hasher.combine(`formatted`)
    }
}


public struct FfiConverterTypeTextMessageContent: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TextMessageContent {
        return try TextMessageContent(
            `body`: FfiConverterString.read(from: &buf), 
            `formatted`: FfiConverterOptionTypeFormattedBody.read(from: &buf)
        )
    }

    public static func write(_ value: TextMessageContent, into buf: inout [UInt8]) {
        FfiConverterString.write(value.`body`, into: &buf)
        FfiConverterOptionTypeFormattedBody.write(value.`formatted`, into: &buf)
    }
}


public func FfiConverterTypeTextMessageContent_lift(_ buf: RustBuffer) throws -> TextMessageContent {
    return try FfiConverterTypeTextMessageContent.lift(buf)
}

public func FfiConverterTypeTextMessageContent_lower(_ value: TextMessageContent) -> RustBuffer {
    return FfiConverterTypeTextMessageContent.lower(value)
}


public struct ThumbnailInfo {
    public var `height`: UInt64?
    public var `width`: UInt64?
    public var `mimetype`: String?
    public var `size`: UInt64?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`height`: UInt64?, `width`: UInt64?, `mimetype`: String?, `size`: UInt64?) {
        self.`height` = `height`
        self.`width` = `width`
        self.`mimetype` = `mimetype`
        self.`size` = `size`
    }
}


extension ThumbnailInfo: Equatable, Hashable {
    public static func ==(lhs: ThumbnailInfo, rhs: ThumbnailInfo) -> Bool {
        if lhs.`height` != rhs.`height` {
            return false
        }
        if lhs.`width` != rhs.`width` {
            return false
        }
        if lhs.`mimetype` != rhs.`mimetype` {
            return false
        }
        if lhs.`size` != rhs.`size` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`height`)
        hasher.combine(`width`)
        hasher.combine(`mimetype`)
        hasher.combine(`size`)
    }
}


public struct FfiConverterTypeThumbnailInfo: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ThumbnailInfo {
        return try ThumbnailInfo(
            `height`: FfiConverterOptionUInt64.read(from: &buf), 
            `width`: FfiConverterOptionUInt64.read(from: &buf), 
            `mimetype`: FfiConverterOptionString.read(from: &buf), 
            `size`: FfiConverterOptionUInt64.read(from: &buf)
        )
    }

    public static func write(_ value: ThumbnailInfo, into buf: inout [UInt8]) {
        FfiConverterOptionUInt64.write(value.`height`, into: &buf)
        FfiConverterOptionUInt64.write(value.`width`, into: &buf)
        FfiConverterOptionString.write(value.`mimetype`, into: &buf)
        FfiConverterOptionUInt64.write(value.`size`, into: &buf)
    }
}


public func FfiConverterTypeThumbnailInfo_lift(_ buf: RustBuffer) throws -> ThumbnailInfo {
    return try FfiConverterTypeThumbnailInfo.lift(buf)
}

public func FfiConverterTypeThumbnailInfo_lower(_ value: ThumbnailInfo) -> RustBuffer {
    return FfiConverterTypeThumbnailInfo.lower(value)
}


public struct UpdateSummary {
    public var `lists`: [String]
    public var `rooms`: [String]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`lists`: [String], `rooms`: [String]) {
        self.`lists` = `lists`
        self.`rooms` = `rooms`
    }
}


extension UpdateSummary: Equatable, Hashable {
    public static func ==(lhs: UpdateSummary, rhs: UpdateSummary) -> Bool {
        if lhs.`lists` != rhs.`lists` {
            return false
        }
        if lhs.`rooms` != rhs.`rooms` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`lists`)
        hasher.combine(`rooms`)
    }
}


public struct FfiConverterTypeUpdateSummary: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UpdateSummary {
        return try UpdateSummary(
            `lists`: FfiConverterSequenceString.read(from: &buf), 
            `rooms`: FfiConverterSequenceString.read(from: &buf)
        )
    }

    public static func write(_ value: UpdateSummary, into buf: inout [UInt8]) {
        FfiConverterSequenceString.write(value.`lists`, into: &buf)
        FfiConverterSequenceString.write(value.`rooms`, into: &buf)
    }
}


public func FfiConverterTypeUpdateSummary_lift(_ buf: RustBuffer) throws -> UpdateSummary {
    return try FfiConverterTypeUpdateSummary.lift(buf)
}

public func FfiConverterTypeUpdateSummary_lower(_ value: UpdateSummary) -> RustBuffer {
    return FfiConverterTypeUpdateSummary.lower(value)
}


public struct VideoInfo {
    public var `duration`: UInt64?
    public var `height`: UInt64?
    public var `width`: UInt64?
    public var `mimetype`: String?
    public var `size`: UInt64?
    public var `thumbnailInfo`: ThumbnailInfo?
    public var `thumbnailSource`: MediaSource?
    public var `blurhash`: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`duration`: UInt64?, `height`: UInt64?, `width`: UInt64?, `mimetype`: String?, `size`: UInt64?, `thumbnailInfo`: ThumbnailInfo?, `thumbnailSource`: MediaSource?, `blurhash`: String?) {
        self.`duration` = `duration`
        self.`height` = `height`
        self.`width` = `width`
        self.`mimetype` = `mimetype`
        self.`size` = `size`
        self.`thumbnailInfo` = `thumbnailInfo`
        self.`thumbnailSource` = `thumbnailSource`
        self.`blurhash` = `blurhash`
    }
}



public struct FfiConverterTypeVideoInfo: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> VideoInfo {
        return try VideoInfo(
            `duration`: FfiConverterOptionUInt64.read(from: &buf), 
            `height`: FfiConverterOptionUInt64.read(from: &buf), 
            `width`: FfiConverterOptionUInt64.read(from: &buf), 
            `mimetype`: FfiConverterOptionString.read(from: &buf), 
            `size`: FfiConverterOptionUInt64.read(from: &buf), 
            `thumbnailInfo`: FfiConverterOptionTypeThumbnailInfo.read(from: &buf), 
            `thumbnailSource`: FfiConverterOptionTypeMediaSource.read(from: &buf), 
            `blurhash`: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: VideoInfo, into buf: inout [UInt8]) {
        FfiConverterOptionUInt64.write(value.`duration`, into: &buf)
        FfiConverterOptionUInt64.write(value.`height`, into: &buf)
        FfiConverterOptionUInt64.write(value.`width`, into: &buf)
        FfiConverterOptionString.write(value.`mimetype`, into: &buf)
        FfiConverterOptionUInt64.write(value.`size`, into: &buf)
        FfiConverterOptionTypeThumbnailInfo.write(value.`thumbnailInfo`, into: &buf)
        FfiConverterOptionTypeMediaSource.write(value.`thumbnailSource`, into: &buf)
        FfiConverterOptionString.write(value.`blurhash`, into: &buf)
    }
}


public func FfiConverterTypeVideoInfo_lift(_ buf: RustBuffer) throws -> VideoInfo {
    return try FfiConverterTypeVideoInfo.lift(buf)
}

public func FfiConverterTypeVideoInfo_lower(_ value: VideoInfo) -> RustBuffer {
    return FfiConverterTypeVideoInfo.lower(value)
}


public struct VideoMessageContent {
    public var `body`: String
    public var `source`: MediaSource
    public var `info`: VideoInfo?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`body`: String, `source`: MediaSource, `info`: VideoInfo?) {
        self.`body` = `body`
        self.`source` = `source`
        self.`info` = `info`
    }
}



public struct FfiConverterTypeVideoMessageContent: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> VideoMessageContent {
        return try VideoMessageContent(
            `body`: FfiConverterString.read(from: &buf), 
            `source`: FfiConverterTypeMediaSource.read(from: &buf), 
            `info`: FfiConverterOptionTypeVideoInfo.read(from: &buf)
        )
    }

    public static func write(_ value: VideoMessageContent, into buf: inout [UInt8]) {
        FfiConverterString.write(value.`body`, into: &buf)
        FfiConverterTypeMediaSource.write(value.`source`, into: &buf)
        FfiConverterOptionTypeVideoInfo.write(value.`info`, into: &buf)
    }
}


public func FfiConverterTypeVideoMessageContent_lift(_ buf: RustBuffer) throws -> VideoMessageContent {
    return try FfiConverterTypeVideoMessageContent.lift(buf)
}

public func FfiConverterTypeVideoMessageContent_lower(_ value: VideoMessageContent) -> RustBuffer {
    return FfiConverterTypeVideoMessageContent.lower(value)
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum EncryptedMessage {
    
    case `olmV1Curve25519AesSha2`(`senderKey`: String)
    case `megolmV1AesSha2`(`sessionId`: String)
    case `unknown`
}

public struct FfiConverterTypeEncryptedMessage: FfiConverterRustBuffer {
    typealias SwiftType = EncryptedMessage

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> EncryptedMessage {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .`olmV1Curve25519AesSha2`(
            `senderKey`: try FfiConverterString.read(from: &buf)
        )
        
        case 2: return .`megolmV1AesSha2`(
            `sessionId`: try FfiConverterString.read(from: &buf)
        )
        
        case 3: return .`unknown`
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: EncryptedMessage, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .`olmV1Curve25519AesSha2`(`senderKey`):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(`senderKey`, into: &buf)
            
        
        case let .`megolmV1AesSha2`(`sessionId`):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(`sessionId`, into: &buf)
            
        
        case .`unknown`:
            writeInt(&buf, Int32(3))
        
        }
    }
}


public func FfiConverterTypeEncryptedMessage_lift(_ buf: RustBuffer) throws -> EncryptedMessage {
    return try FfiConverterTypeEncryptedMessage.lift(buf)
}

public func FfiConverterTypeEncryptedMessage_lower(_ value: EncryptedMessage) -> RustBuffer {
    return FfiConverterTypeEncryptedMessage.lower(value)
}


extension EncryptedMessage: Equatable, Hashable {}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum EventSendState {
    
    case `notSendYet`
    case `sendingFailed`(`error`: String)
    case `sent`(`eventId`: String)
}

public struct FfiConverterTypeEventSendState: FfiConverterRustBuffer {
    typealias SwiftType = EventSendState

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> EventSendState {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .`notSendYet`
        
        case 2: return .`sendingFailed`(
            `error`: try FfiConverterString.read(from: &buf)
        )
        
        case 3: return .`sent`(
            `eventId`: try FfiConverterString.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: EventSendState, into buf: inout [UInt8]) {
        switch value {
        
        
        case .`notSendYet`:
            writeInt(&buf, Int32(1))
        
        
        case let .`sendingFailed`(`error`):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(`error`, into: &buf)
            
        
        case let .`sent`(`eventId`):
            writeInt(&buf, Int32(3))
            FfiConverterString.write(`eventId`, into: &buf)
            
        }
    }
}


public func FfiConverterTypeEventSendState_lift(_ buf: RustBuffer) throws -> EventSendState {
    return try FfiConverterTypeEventSendState.lift(buf)
}

public func FfiConverterTypeEventSendState_lower(_ value: EventSendState) -> RustBuffer {
    return FfiConverterTypeEventSendState.lower(value)
}


extension EventSendState: Equatable, Hashable {}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum Membership {
    
    case `invited`
    case `joined`
    case `left`
}

public struct FfiConverterTypeMembership: FfiConverterRustBuffer {
    typealias SwiftType = Membership

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Membership {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .`invited`
        
        case 2: return .`joined`
        
        case 3: return .`left`
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: Membership, into buf: inout [UInt8]) {
        switch value {
        
        
        case .`invited`:
            writeInt(&buf, Int32(1))
        
        
        case .`joined`:
            writeInt(&buf, Int32(2))
        
        
        case .`left`:
            writeInt(&buf, Int32(3))
        
        }
    }
}


public func FfiConverterTypeMembership_lift(_ buf: RustBuffer) throws -> Membership {
    return try FfiConverterTypeMembership.lift(buf)
}

public func FfiConverterTypeMembership_lower(_ value: Membership) -> RustBuffer {
    return FfiConverterTypeMembership.lower(value)
}


extension Membership: Equatable, Hashable {}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum MembershipChange {
    
    case `none`
    case `error`
    case `joined`
    case `left`
    case `banned`
    case `unbanned`
    case `kicked`
    case `invited`
    case `kickedAndBanned`
    case `invitationAccepted`
    case `invitationRejected`
    case `invitationRevoked`
    case `knocked`
    case `knockAccepted`
    case `knockRetracted`
    case `knockDenied`
    case `notImplemented`
}

public struct FfiConverterTypeMembershipChange: FfiConverterRustBuffer {
    typealias SwiftType = MembershipChange

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MembershipChange {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .`none`
        
        case 2: return .`error`
        
        case 3: return .`joined`
        
        case 4: return .`left`
        
        case 5: return .`banned`
        
        case 6: return .`unbanned`
        
        case 7: return .`kicked`
        
        case 8: return .`invited`
        
        case 9: return .`kickedAndBanned`
        
        case 10: return .`invitationAccepted`
        
        case 11: return .`invitationRejected`
        
        case 12: return .`invitationRevoked`
        
        case 13: return .`knocked`
        
        case 14: return .`knockAccepted`
        
        case 15: return .`knockRetracted`
        
        case 16: return .`knockDenied`
        
        case 17: return .`notImplemented`
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: MembershipChange, into buf: inout [UInt8]) {
        switch value {
        
        
        case .`none`:
            writeInt(&buf, Int32(1))
        
        
        case .`error`:
            writeInt(&buf, Int32(2))
        
        
        case .`joined`:
            writeInt(&buf, Int32(3))
        
        
        case .`left`:
            writeInt(&buf, Int32(4))
        
        
        case .`banned`:
            writeInt(&buf, Int32(5))
        
        
        case .`unbanned`:
            writeInt(&buf, Int32(6))
        
        
        case .`kicked`:
            writeInt(&buf, Int32(7))
        
        
        case .`invited`:
            writeInt(&buf, Int32(8))
        
        
        case .`kickedAndBanned`:
            writeInt(&buf, Int32(9))
        
        
        case .`invitationAccepted`:
            writeInt(&buf, Int32(10))
        
        
        case .`invitationRejected`:
            writeInt(&buf, Int32(11))
        
        
        case .`invitationRevoked`:
            writeInt(&buf, Int32(12))
        
        
        case .`knocked`:
            writeInt(&buf, Int32(13))
        
        
        case .`knockAccepted`:
            writeInt(&buf, Int32(14))
        
        
        case .`knockRetracted`:
            writeInt(&buf, Int32(15))
        
        
        case .`knockDenied`:
            writeInt(&buf, Int32(16))
        
        
        case .`notImplemented`:
            writeInt(&buf, Int32(17))
        
        }
    }
}


public func FfiConverterTypeMembershipChange_lift(_ buf: RustBuffer) throws -> MembershipChange {
    return try FfiConverterTypeMembershipChange.lift(buf)
}

public func FfiConverterTypeMembershipChange_lower(_ value: MembershipChange) -> RustBuffer {
    return FfiConverterTypeMembershipChange.lower(value)
}


extension MembershipChange: Equatable, Hashable {}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum MembershipState {
    
    case `ban`
    case `invite`
    case `join`
    case `knock`
    case `leave`
}

public struct FfiConverterTypeMembershipState: FfiConverterRustBuffer {
    typealias SwiftType = MembershipState

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MembershipState {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .`ban`
        
        case 2: return .`invite`
        
        case 3: return .`join`
        
        case 4: return .`knock`
        
        case 5: return .`leave`
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: MembershipState, into buf: inout [UInt8]) {
        switch value {
        
        
        case .`ban`:
            writeInt(&buf, Int32(1))
        
        
        case .`invite`:
            writeInt(&buf, Int32(2))
        
        
        case .`join`:
            writeInt(&buf, Int32(3))
        
        
        case .`knock`:
            writeInt(&buf, Int32(4))
        
        
        case .`leave`:
            writeInt(&buf, Int32(5))
        
        }
    }
}


public func FfiConverterTypeMembershipState_lift(_ buf: RustBuffer) throws -> MembershipState {
    return try FfiConverterTypeMembershipState.lift(buf)
}

public func FfiConverterTypeMembershipState_lower(_ value: MembershipState) -> RustBuffer {
    return FfiConverterTypeMembershipState.lower(value)
}


extension MembershipState: Equatable, Hashable {}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum MessageFormat {
    
    case `html`
    case `unknown`
}

public struct FfiConverterTypeMessageFormat: FfiConverterRustBuffer {
    typealias SwiftType = MessageFormat

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MessageFormat {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .`html`
        
        case 2: return .`unknown`
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: MessageFormat, into buf: inout [UInt8]) {
        switch value {
        
        
        case .`html`:
            writeInt(&buf, Int32(1))
        
        
        case .`unknown`:
            writeInt(&buf, Int32(2))
        
        }
    }
}


public func FfiConverterTypeMessageFormat_lift(_ buf: RustBuffer) throws -> MessageFormat {
    return try FfiConverterTypeMessageFormat.lift(buf)
}

public func FfiConverterTypeMessageFormat_lower(_ value: MessageFormat) -> RustBuffer {
    return FfiConverterTypeMessageFormat.lower(value)
}


extension MessageFormat: Equatable, Hashable {}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum MessageType {
    
    case `emote`(`content`: EmoteMessageContent)
    case `image`(`content`: ImageMessageContent)
    case `audio`(`content`: AudioMessageContent)
    case `video`(`content`: VideoMessageContent)
    case `file`(`content`: FileMessageContent)
    case `notice`(`content`: NoticeMessageContent)
    case `text`(`content`: TextMessageContent)
}

public struct FfiConverterTypeMessageType: FfiConverterRustBuffer {
    typealias SwiftType = MessageType

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MessageType {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .`emote`(
            `content`: try FfiConverterTypeEmoteMessageContent.read(from: &buf)
        )
        
        case 2: return .`image`(
            `content`: try FfiConverterTypeImageMessageContent.read(from: &buf)
        )
        
        case 3: return .`audio`(
            `content`: try FfiConverterTypeAudioMessageContent.read(from: &buf)
        )
        
        case 4: return .`video`(
            `content`: try FfiConverterTypeVideoMessageContent.read(from: &buf)
        )
        
        case 5: return .`file`(
            `content`: try FfiConverterTypeFileMessageContent.read(from: &buf)
        )
        
        case 6: return .`notice`(
            `content`: try FfiConverterTypeNoticeMessageContent.read(from: &buf)
        )
        
        case 7: return .`text`(
            `content`: try FfiConverterTypeTextMessageContent.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: MessageType, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .`emote`(`content`):
            writeInt(&buf, Int32(1))
            FfiConverterTypeEmoteMessageContent.write(`content`, into: &buf)
            
        
        case let .`image`(`content`):
            writeInt(&buf, Int32(2))
            FfiConverterTypeImageMessageContent.write(`content`, into: &buf)
            
        
        case let .`audio`(`content`):
            writeInt(&buf, Int32(3))
            FfiConverterTypeAudioMessageContent.write(`content`, into: &buf)
            
        
        case let .`video`(`content`):
            writeInt(&buf, Int32(4))
            FfiConverterTypeVideoMessageContent.write(`content`, into: &buf)
            
        
        case let .`file`(`content`):
            writeInt(&buf, Int32(5))
            FfiConverterTypeFileMessageContent.write(`content`, into: &buf)
            
        
        case let .`notice`(`content`):
            writeInt(&buf, Int32(6))
            FfiConverterTypeNoticeMessageContent.write(`content`, into: &buf)
            
        
        case let .`text`(`content`):
            writeInt(&buf, Int32(7))
            FfiConverterTypeTextMessageContent.write(`content`, into: &buf)
            
        }
    }
}


public func FfiConverterTypeMessageType_lift(_ buf: RustBuffer) throws -> MessageType {
    return try FfiConverterTypeMessageType.lift(buf)
}

public func FfiConverterTypeMessageType_lower(_ value: MessageType) -> RustBuffer {
    return FfiConverterTypeMessageType.lower(value)
}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum OtherState {
    
    case `policyRuleRoom`
    case `policyRuleServer`
    case `policyRuleUser`
    case `roomAliases`
    case `roomAvatar`(`url`: String?)
    case `roomCanonicalAlias`
    case `roomCreate`
    case `roomEncryption`
    case `roomGuestAccess`
    case `roomHistoryVisibility`
    case `roomJoinRules`
    case `roomName`(`name`: String?)
    case `roomPinnedEvents`
    case `roomPowerLevels`
    case `roomServerAcl`
    case `roomThirdPartyInvite`(`displayName`: String?)
    case `roomTombstone`
    case `roomTopic`(`topic`: String?)
    case `spaceChild`
    case `spaceParent`
    case `custom`(`eventType`: String)
}

public struct FfiConverterTypeOtherState: FfiConverterRustBuffer {
    typealias SwiftType = OtherState

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> OtherState {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .`policyRuleRoom`
        
        case 2: return .`policyRuleServer`
        
        case 3: return .`policyRuleUser`
        
        case 4: return .`roomAliases`
        
        case 5: return .`roomAvatar`(
            `url`: try FfiConverterOptionString.read(from: &buf)
        )
        
        case 6: return .`roomCanonicalAlias`
        
        case 7: return .`roomCreate`
        
        case 8: return .`roomEncryption`
        
        case 9: return .`roomGuestAccess`
        
        case 10: return .`roomHistoryVisibility`
        
        case 11: return .`roomJoinRules`
        
        case 12: return .`roomName`(
            `name`: try FfiConverterOptionString.read(from: &buf)
        )
        
        case 13: return .`roomPinnedEvents`
        
        case 14: return .`roomPowerLevels`
        
        case 15: return .`roomServerAcl`
        
        case 16: return .`roomThirdPartyInvite`(
            `displayName`: try FfiConverterOptionString.read(from: &buf)
        )
        
        case 17: return .`roomTombstone`
        
        case 18: return .`roomTopic`(
            `topic`: try FfiConverterOptionString.read(from: &buf)
        )
        
        case 19: return .`spaceChild`
        
        case 20: return .`spaceParent`
        
        case 21: return .`custom`(
            `eventType`: try FfiConverterString.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: OtherState, into buf: inout [UInt8]) {
        switch value {
        
        
        case .`policyRuleRoom`:
            writeInt(&buf, Int32(1))
        
        
        case .`policyRuleServer`:
            writeInt(&buf, Int32(2))
        
        
        case .`policyRuleUser`:
            writeInt(&buf, Int32(3))
        
        
        case .`roomAliases`:
            writeInt(&buf, Int32(4))
        
        
        case let .`roomAvatar`(`url`):
            writeInt(&buf, Int32(5))
            FfiConverterOptionString.write(`url`, into: &buf)
            
        
        case .`roomCanonicalAlias`:
            writeInt(&buf, Int32(6))
        
        
        case .`roomCreate`:
            writeInt(&buf, Int32(7))
        
        
        case .`roomEncryption`:
            writeInt(&buf, Int32(8))
        
        
        case .`roomGuestAccess`:
            writeInt(&buf, Int32(9))
        
        
        case .`roomHistoryVisibility`:
            writeInt(&buf, Int32(10))
        
        
        case .`roomJoinRules`:
            writeInt(&buf, Int32(11))
        
        
        case let .`roomName`(`name`):
            writeInt(&buf, Int32(12))
            FfiConverterOptionString.write(`name`, into: &buf)
            
        
        case .`roomPinnedEvents`:
            writeInt(&buf, Int32(13))
        
        
        case .`roomPowerLevels`:
            writeInt(&buf, Int32(14))
        
        
        case .`roomServerAcl`:
            writeInt(&buf, Int32(15))
        
        
        case let .`roomThirdPartyInvite`(`displayName`):
            writeInt(&buf, Int32(16))
            FfiConverterOptionString.write(`displayName`, into: &buf)
            
        
        case .`roomTombstone`:
            writeInt(&buf, Int32(17))
        
        
        case let .`roomTopic`(`topic`):
            writeInt(&buf, Int32(18))
            FfiConverterOptionString.write(`topic`, into: &buf)
            
        
        case .`spaceChild`:
            writeInt(&buf, Int32(19))
        
        
        case .`spaceParent`:
            writeInt(&buf, Int32(20))
        
        
        case let .`custom`(`eventType`):
            writeInt(&buf, Int32(21))
            FfiConverterString.write(`eventType`, into: &buf)
            
        }
    }
}


public func FfiConverterTypeOtherState_lift(_ buf: RustBuffer) throws -> OtherState {
    return try FfiConverterTypeOtherState.lift(buf)
}

public func FfiConverterTypeOtherState_lower(_ value: OtherState) -> RustBuffer {
    return FfiConverterTypeOtherState.lower(value)
}


extension OtherState: Equatable, Hashable {}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum PaginationOptions {
    
    case `singleRequest`(`eventLimit`: UInt16)
    case `untilNumItems`(`eventLimit`: UInt16, `items`: UInt16)
}

public struct FfiConverterTypePaginationOptions: FfiConverterRustBuffer {
    typealias SwiftType = PaginationOptions

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PaginationOptions {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .`singleRequest`(
            `eventLimit`: try FfiConverterUInt16.read(from: &buf)
        )
        
        case 2: return .`untilNumItems`(
            `eventLimit`: try FfiConverterUInt16.read(from: &buf), 
            `items`: try FfiConverterUInt16.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: PaginationOptions, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .`singleRequest`(`eventLimit`):
            writeInt(&buf, Int32(1))
            FfiConverterUInt16.write(`eventLimit`, into: &buf)
            
        
        case let .`untilNumItems`(`eventLimit`,`items`):
            writeInt(&buf, Int32(2))
            FfiConverterUInt16.write(`eventLimit`, into: &buf)
            FfiConverterUInt16.write(`items`, into: &buf)
            
        }
    }
}


public func FfiConverterTypePaginationOptions_lift(_ buf: RustBuffer) throws -> PaginationOptions {
    return try FfiConverterTypePaginationOptions.lift(buf)
}

public func FfiConverterTypePaginationOptions_lower(_ value: PaginationOptions) -> RustBuffer {
    return FfiConverterTypePaginationOptions.lower(value)
}


extension PaginationOptions: Equatable, Hashable {}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum ProfileTimelineDetails {
    
    case `unavailable`
    case `pending`
    case `ready`(`displayName`: String?, `displayNameAmbiguous`: Bool, `avatarUrl`: String?)
    case `error`(`message`: String)
}

public struct FfiConverterTypeProfileTimelineDetails: FfiConverterRustBuffer {
    typealias SwiftType = ProfileTimelineDetails

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ProfileTimelineDetails {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .`unavailable`
        
        case 2: return .`pending`
        
        case 3: return .`ready`(
            `displayName`: try FfiConverterOptionString.read(from: &buf), 
            `displayNameAmbiguous`: try FfiConverterBool.read(from: &buf), 
            `avatarUrl`: try FfiConverterOptionString.read(from: &buf)
        )
        
        case 4: return .`error`(
            `message`: try FfiConverterString.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ProfileTimelineDetails, into buf: inout [UInt8]) {
        switch value {
        
        
        case .`unavailable`:
            writeInt(&buf, Int32(1))
        
        
        case .`pending`:
            writeInt(&buf, Int32(2))
        
        
        case let .`ready`(`displayName`,`displayNameAmbiguous`,`avatarUrl`):
            writeInt(&buf, Int32(3))
            FfiConverterOptionString.write(`displayName`, into: &buf)
            FfiConverterBool.write(`displayNameAmbiguous`, into: &buf)
            FfiConverterOptionString.write(`avatarUrl`, into: &buf)
            
        
        case let .`error`(`message`):
            writeInt(&buf, Int32(4))
            FfiConverterString.write(`message`, into: &buf)
            
        }
    }
}


public func FfiConverterTypeProfileTimelineDetails_lift(_ buf: RustBuffer) throws -> ProfileTimelineDetails {
    return try FfiConverterTypeProfileTimelineDetails.lift(buf)
}

public func FfiConverterTypeProfileTimelineDetails_lower(_ value: ProfileTimelineDetails) -> RustBuffer {
    return FfiConverterTypeProfileTimelineDetails.lower(value)
}


extension ProfileTimelineDetails: Equatable, Hashable {}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum RoomListEntry {
    
    case `empty`
    case `invalidated`(`roomId`: String)
    case `filled`(`roomId`: String)
}

public struct FfiConverterTypeRoomListEntry: FfiConverterRustBuffer {
    typealias SwiftType = RoomListEntry

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RoomListEntry {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .`empty`
        
        case 2: return .`invalidated`(
            `roomId`: try FfiConverterString.read(from: &buf)
        )
        
        case 3: return .`filled`(
            `roomId`: try FfiConverterString.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: RoomListEntry, into buf: inout [UInt8]) {
        switch value {
        
        
        case .`empty`:
            writeInt(&buf, Int32(1))
        
        
        case let .`invalidated`(`roomId`):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(`roomId`, into: &buf)
            
        
        case let .`filled`(`roomId`):
            writeInt(&buf, Int32(3))
            FfiConverterString.write(`roomId`, into: &buf)
            
        }
    }
}


public func FfiConverterTypeRoomListEntry_lift(_ buf: RustBuffer) throws -> RoomListEntry {
    return try FfiConverterTypeRoomListEntry.lift(buf)
}

public func FfiConverterTypeRoomListEntry_lower(_ value: RoomListEntry) -> RustBuffer {
    return FfiConverterTypeRoomListEntry.lower(value)
}


extension RoomListEntry: Equatable, Hashable {}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum SlidingSyncListRoomsListDiff {
    
    case `append`(`values`: [RoomListEntry])
    case `insert`(`index`: UInt32, `value`: RoomListEntry)
    case `set`(`index`: UInt32, `value`: RoomListEntry)
    case `remove`(`index`: UInt32)
    case `pushBack`(`value`: RoomListEntry)
    case `pushFront`(`value`: RoomListEntry)
    case `popBack`
    case `popFront`
    case `clear`
    case `reset`(`values`: [RoomListEntry])
}

public struct FfiConverterTypeSlidingSyncListRoomsListDiff: FfiConverterRustBuffer {
    typealias SwiftType = SlidingSyncListRoomsListDiff

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SlidingSyncListRoomsListDiff {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .`append`(
            `values`: try FfiConverterSequenceTypeRoomListEntry.read(from: &buf)
        )
        
        case 2: return .`insert`(
            `index`: try FfiConverterUInt32.read(from: &buf), 
            `value`: try FfiConverterTypeRoomListEntry.read(from: &buf)
        )
        
        case 3: return .`set`(
            `index`: try FfiConverterUInt32.read(from: &buf), 
            `value`: try FfiConverterTypeRoomListEntry.read(from: &buf)
        )
        
        case 4: return .`remove`(
            `index`: try FfiConverterUInt32.read(from: &buf)
        )
        
        case 5: return .`pushBack`(
            `value`: try FfiConverterTypeRoomListEntry.read(from: &buf)
        )
        
        case 6: return .`pushFront`(
            `value`: try FfiConverterTypeRoomListEntry.read(from: &buf)
        )
        
        case 7: return .`popBack`
        
        case 8: return .`popFront`
        
        case 9: return .`clear`
        
        case 10: return .`reset`(
            `values`: try FfiConverterSequenceTypeRoomListEntry.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: SlidingSyncListRoomsListDiff, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .`append`(`values`):
            writeInt(&buf, Int32(1))
            FfiConverterSequenceTypeRoomListEntry.write(`values`, into: &buf)
            
        
        case let .`insert`(`index`,`value`):
            writeInt(&buf, Int32(2))
            FfiConverterUInt32.write(`index`, into: &buf)
            FfiConverterTypeRoomListEntry.write(`value`, into: &buf)
            
        
        case let .`set`(`index`,`value`):
            writeInt(&buf, Int32(3))
            FfiConverterUInt32.write(`index`, into: &buf)
            FfiConverterTypeRoomListEntry.write(`value`, into: &buf)
            
        
        case let .`remove`(`index`):
            writeInt(&buf, Int32(4))
            FfiConverterUInt32.write(`index`, into: &buf)
            
        
        case let .`pushBack`(`value`):
            writeInt(&buf, Int32(5))
            FfiConverterTypeRoomListEntry.write(`value`, into: &buf)
            
        
        case let .`pushFront`(`value`):
            writeInt(&buf, Int32(6))
            FfiConverterTypeRoomListEntry.write(`value`, into: &buf)
            
        
        case .`popBack`:
            writeInt(&buf, Int32(7))
        
        
        case .`popFront`:
            writeInt(&buf, Int32(8))
        
        
        case .`clear`:
            writeInt(&buf, Int32(9))
        
        
        case let .`reset`(`values`):
            writeInt(&buf, Int32(10))
            FfiConverterSequenceTypeRoomListEntry.write(`values`, into: &buf)
            
        }
    }
}


public func FfiConverterTypeSlidingSyncListRoomsListDiff_lift(_ buf: RustBuffer) throws -> SlidingSyncListRoomsListDiff {
    return try FfiConverterTypeSlidingSyncListRoomsListDiff.lift(buf)
}

public func FfiConverterTypeSlidingSyncListRoomsListDiff_lower(_ value: SlidingSyncListRoomsListDiff) -> RustBuffer {
    return FfiConverterTypeSlidingSyncListRoomsListDiff.lower(value)
}


extension SlidingSyncListRoomsListDiff: Equatable, Hashable {}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum SlidingSyncMode {
    
    case `pagingFullSync`
    case `growingFullSync`
    case `selective`
}

public struct FfiConverterTypeSlidingSyncMode: FfiConverterRustBuffer {
    typealias SwiftType = SlidingSyncMode

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SlidingSyncMode {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .`pagingFullSync`
        
        case 2: return .`growingFullSync`
        
        case 3: return .`selective`
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: SlidingSyncMode, into buf: inout [UInt8]) {
        switch value {
        
        
        case .`pagingFullSync`:
            writeInt(&buf, Int32(1))
        
        
        case .`growingFullSync`:
            writeInt(&buf, Int32(2))
        
        
        case .`selective`:
            writeInt(&buf, Int32(3))
        
        }
    }
}


public func FfiConverterTypeSlidingSyncMode_lift(_ buf: RustBuffer) throws -> SlidingSyncMode {
    return try FfiConverterTypeSlidingSyncMode.lift(buf)
}

public func FfiConverterTypeSlidingSyncMode_lower(_ value: SlidingSyncMode) -> RustBuffer {
    return FfiConverterTypeSlidingSyncMode.lower(value)
}


extension SlidingSyncMode: Equatable, Hashable {}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum SlidingSyncState {
    
    case `cold`
    case `preload`
    case `catchingUp`
    case `live`
}

public struct FfiConverterTypeSlidingSyncState: FfiConverterRustBuffer {
    typealias SwiftType = SlidingSyncState

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SlidingSyncState {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .`cold`
        
        case 2: return .`preload`
        
        case 3: return .`catchingUp`
        
        case 4: return .`live`
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: SlidingSyncState, into buf: inout [UInt8]) {
        switch value {
        
        
        case .`cold`:
            writeInt(&buf, Int32(1))
        
        
        case .`preload`:
            writeInt(&buf, Int32(2))
        
        
        case .`catchingUp`:
            writeInt(&buf, Int32(3))
        
        
        case .`live`:
            writeInt(&buf, Int32(4))
        
        }
    }
}


public func FfiConverterTypeSlidingSyncState_lift(_ buf: RustBuffer) throws -> SlidingSyncState {
    return try FfiConverterTypeSlidingSyncState.lift(buf)
}

public func FfiConverterTypeSlidingSyncState_lower(_ value: SlidingSyncState) -> RustBuffer {
    return FfiConverterTypeSlidingSyncState.lower(value)
}


extension SlidingSyncState: Equatable, Hashable {}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum TimelineChange {
    
    case `append`
    case `clear`
    case `insert`
    case `set`
    case `remove`
    case `pushBack`
    case `pushFront`
    case `popBack`
    case `popFront`
    case `reset`
}

public struct FfiConverterTypeTimelineChange: FfiConverterRustBuffer {
    typealias SwiftType = TimelineChange

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TimelineChange {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .`append`
        
        case 2: return .`clear`
        
        case 3: return .`insert`
        
        case 4: return .`set`
        
        case 5: return .`remove`
        
        case 6: return .`pushBack`
        
        case 7: return .`pushFront`
        
        case 8: return .`popBack`
        
        case 9: return .`popFront`
        
        case 10: return .`reset`
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: TimelineChange, into buf: inout [UInt8]) {
        switch value {
        
        
        case .`append`:
            writeInt(&buf, Int32(1))
        
        
        case .`clear`:
            writeInt(&buf, Int32(2))
        
        
        case .`insert`:
            writeInt(&buf, Int32(3))
        
        
        case .`set`:
            writeInt(&buf, Int32(4))
        
        
        case .`remove`:
            writeInt(&buf, Int32(5))
        
        
        case .`pushBack`:
            writeInt(&buf, Int32(6))
        
        
        case .`pushFront`:
            writeInt(&buf, Int32(7))
        
        
        case .`popBack`:
            writeInt(&buf, Int32(8))
        
        
        case .`popFront`:
            writeInt(&buf, Int32(9))
        
        
        case .`reset`:
            writeInt(&buf, Int32(10))
        
        }
    }
}


public func FfiConverterTypeTimelineChange_lift(_ buf: RustBuffer) throws -> TimelineChange {
    return try FfiConverterTypeTimelineChange.lift(buf)
}

public func FfiConverterTypeTimelineChange_lower(_ value: TimelineChange) -> RustBuffer {
    return FfiConverterTypeTimelineChange.lower(value)
}


extension TimelineChange: Equatable, Hashable {}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum TimelineItemContentKind {
    
    case `message`
    case `redactedMessage`
    case `sticker`(`body`: String, `info`: ImageInfo, `url`: String)
    case `unableToDecrypt`(`msg`: EncryptedMessage)
    case `roomMembership`(`userId`: String, `change`: MembershipChange?)
    case `profileChange`(`displayName`: String?, `prevDisplayName`: String?, `avatarUrl`: String?, `prevAvatarUrl`: String?)
    case `state`(`stateKey`: String, `content`: OtherState)
    case `failedToParseMessageLike`(`eventType`: String, `error`: String)
    case `failedToParseState`(`eventType`: String, `stateKey`: String, `error`: String)
}

public struct FfiConverterTypeTimelineItemContentKind: FfiConverterRustBuffer {
    typealias SwiftType = TimelineItemContentKind

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TimelineItemContentKind {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .`message`
        
        case 2: return .`redactedMessage`
        
        case 3: return .`sticker`(
            `body`: try FfiConverterString.read(from: &buf), 
            `info`: try FfiConverterTypeImageInfo.read(from: &buf), 
            `url`: try FfiConverterString.read(from: &buf)
        )
        
        case 4: return .`unableToDecrypt`(
            `msg`: try FfiConverterTypeEncryptedMessage.read(from: &buf)
        )
        
        case 5: return .`roomMembership`(
            `userId`: try FfiConverterString.read(from: &buf), 
            `change`: try FfiConverterOptionTypeMembershipChange.read(from: &buf)
        )
        
        case 6: return .`profileChange`(
            `displayName`: try FfiConverterOptionString.read(from: &buf), 
            `prevDisplayName`: try FfiConverterOptionString.read(from: &buf), 
            `avatarUrl`: try FfiConverterOptionString.read(from: &buf), 
            `prevAvatarUrl`: try FfiConverterOptionString.read(from: &buf)
        )
        
        case 7: return .`state`(
            `stateKey`: try FfiConverterString.read(from: &buf), 
            `content`: try FfiConverterTypeOtherState.read(from: &buf)
        )
        
        case 8: return .`failedToParseMessageLike`(
            `eventType`: try FfiConverterString.read(from: &buf), 
            `error`: try FfiConverterString.read(from: &buf)
        )
        
        case 9: return .`failedToParseState`(
            `eventType`: try FfiConverterString.read(from: &buf), 
            `stateKey`: try FfiConverterString.read(from: &buf), 
            `error`: try FfiConverterString.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: TimelineItemContentKind, into buf: inout [UInt8]) {
        switch value {
        
        
        case .`message`:
            writeInt(&buf, Int32(1))
        
        
        case .`redactedMessage`:
            writeInt(&buf, Int32(2))
        
        
        case let .`sticker`(`body`,`info`,`url`):
            writeInt(&buf, Int32(3))
            FfiConverterString.write(`body`, into: &buf)
            FfiConverterTypeImageInfo.write(`info`, into: &buf)
            FfiConverterString.write(`url`, into: &buf)
            
        
        case let .`unableToDecrypt`(`msg`):
            writeInt(&buf, Int32(4))
            FfiConverterTypeEncryptedMessage.write(`msg`, into: &buf)
            
        
        case let .`roomMembership`(`userId`,`change`):
            writeInt(&buf, Int32(5))
            FfiConverterString.write(`userId`, into: &buf)
            FfiConverterOptionTypeMembershipChange.write(`change`, into: &buf)
            
        
        case let .`profileChange`(`displayName`,`prevDisplayName`,`avatarUrl`,`prevAvatarUrl`):
            writeInt(&buf, Int32(6))
            FfiConverterOptionString.write(`displayName`, into: &buf)
            FfiConverterOptionString.write(`prevDisplayName`, into: &buf)
            FfiConverterOptionString.write(`avatarUrl`, into: &buf)
            FfiConverterOptionString.write(`prevAvatarUrl`, into: &buf)
            
        
        case let .`state`(`stateKey`,`content`):
            writeInt(&buf, Int32(7))
            FfiConverterString.write(`stateKey`, into: &buf)
            FfiConverterTypeOtherState.write(`content`, into: &buf)
            
        
        case let .`failedToParseMessageLike`(`eventType`,`error`):
            writeInt(&buf, Int32(8))
            FfiConverterString.write(`eventType`, into: &buf)
            FfiConverterString.write(`error`, into: &buf)
            
        
        case let .`failedToParseState`(`eventType`,`stateKey`,`error`):
            writeInt(&buf, Int32(9))
            FfiConverterString.write(`eventType`, into: &buf)
            FfiConverterString.write(`stateKey`, into: &buf)
            FfiConverterString.write(`error`, into: &buf)
            
        }
    }
}


public func FfiConverterTypeTimelineItemContentKind_lift(_ buf: RustBuffer) throws -> TimelineItemContentKind {
    return try FfiConverterTypeTimelineItemContentKind.lift(buf)
}

public func FfiConverterTypeTimelineItemContentKind_lower(_ value: TimelineItemContentKind) -> RustBuffer {
    return FfiConverterTypeTimelineItemContentKind.lower(value)
}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum VirtualTimelineItem {
    
    case `dayDivider`(`ts`: UInt64)
    case `readMarker`
    case `loadingIndicator`
    case `timelineStart`
}

public struct FfiConverterTypeVirtualTimelineItem: FfiConverterRustBuffer {
    typealias SwiftType = VirtualTimelineItem

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> VirtualTimelineItem {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .`dayDivider`(
            `ts`: try FfiConverterUInt64.read(from: &buf)
        )
        
        case 2: return .`readMarker`
        
        case 3: return .`loadingIndicator`
        
        case 4: return .`timelineStart`
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: VirtualTimelineItem, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .`dayDivider`(`ts`):
            writeInt(&buf, Int32(1))
            FfiConverterUInt64.write(`ts`, into: &buf)
            
        
        case .`readMarker`:
            writeInt(&buf, Int32(2))
        
        
        case .`loadingIndicator`:
            writeInt(&buf, Int32(3))
        
        
        case .`timelineStart`:
            writeInt(&buf, Int32(4))
        
        }
    }
}


public func FfiConverterTypeVirtualTimelineItem_lift(_ buf: RustBuffer) throws -> VirtualTimelineItem {
    return try FfiConverterTypeVirtualTimelineItem.lift(buf)
}

public func FfiConverterTypeVirtualTimelineItem_lower(_ value: VirtualTimelineItem) -> RustBuffer {
    return FfiConverterTypeVirtualTimelineItem.lower(value)
}


extension VirtualTimelineItem: Equatable, Hashable {}



public enum AuthenticationError {

    
    
    // Simple error enums only carry a message
    case ClientMissing(message: String)
    
    // Simple error enums only carry a message
    case InvalidServerName(message: String)
    
    // Simple error enums only carry a message
    case SlidingSyncNotAvailable(message: String)
    
    // Simple error enums only carry a message
    case SessionMissing(message: String)
    
    // Simple error enums only carry a message
    case Generic(message: String)
    
}

public struct FfiConverterTypeAuthenticationError: FfiConverterRustBuffer {
    typealias SwiftType = AuthenticationError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AuthenticationError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .ClientMissing(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 2: return .InvalidServerName(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 3: return .SlidingSyncNotAvailable(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 4: return .SessionMissing(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 5: return .Generic(
            message: try FfiConverterString.read(from: &buf)
        )
        

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: AuthenticationError, into buf: inout [UInt8]) {
        switch value {

        

        
        case let .ClientMissing(message):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(message, into: &buf)
        case let .InvalidServerName(message):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(message, into: &buf)
        case let .SlidingSyncNotAvailable(message):
            writeInt(&buf, Int32(3))
            FfiConverterString.write(message, into: &buf)
        case let .SessionMissing(message):
            writeInt(&buf, Int32(4))
            FfiConverterString.write(message, into: &buf)
        case let .Generic(message):
            writeInt(&buf, Int32(5))
            FfiConverterString.write(message, into: &buf)

        
        }
    }
}


extension AuthenticationError: Equatable, Hashable {}

extension AuthenticationError: Error { }


public enum ClientError {

    
    
    case Generic(`msg`: String)
}

public struct FfiConverterTypeClientError: FfiConverterRustBuffer {
    typealias SwiftType = ClientError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ClientError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .Generic(
            `msg`: try FfiConverterString.read(from: &buf)
            )

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ClientError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case let .Generic(`msg`):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(`msg`, into: &buf)
            
        }
    }
}


extension ClientError: Equatable, Hashable {}

extension ClientError: Error { }

fileprivate extension NSLock {
    func withLock<T>(f: () throws -> T) rethrows -> T {
        self.lock()
        defer { self.unlock() }
        return try f()
    }
}

fileprivate typealias UniFFICallbackHandle = UInt64
fileprivate class UniFFICallbackHandleMap<T> {
    private var leftMap: [UniFFICallbackHandle: T] = [:]
    private var counter: [UniFFICallbackHandle: UInt64] = [:]
    private var rightMap: [ObjectIdentifier: UniFFICallbackHandle] = [:]

    private let lock = NSLock()
    private var currentHandle: UniFFICallbackHandle = 0
    private let stride: UniFFICallbackHandle = 1

    func insert(obj: T) -> UniFFICallbackHandle {
        lock.withLock {
            let id = ObjectIdentifier(obj as AnyObject)
            let handle = rightMap[id] ?? {
                currentHandle += stride
                let handle = currentHandle
                leftMap[handle] = obj
                rightMap[id] = handle
                return handle
            }()
            counter[handle] = (counter[handle] ?? 0) + 1
            return handle
        }
    }

    func get(handle: UniFFICallbackHandle) -> T? {
        lock.withLock {
            leftMap[handle]
        }
    }

    func delete(handle: UniFFICallbackHandle) {
        remove(handle: handle)
    }

    @discardableResult
    func remove(handle: UniFFICallbackHandle) -> T? {
        lock.withLock {
            defer { counter[handle] = (counter[handle] ?? 1) - 1 }
            guard counter[handle] == 1 else { return leftMap[handle] }
            let obj = leftMap.removeValue(forKey: handle)
            if let obj = obj {
                rightMap.removeValue(forKey: ObjectIdentifier(obj as AnyObject))
            }
            return obj
        }
    }
}

// Magic number for the Rust proxy to call using the same mechanism as every other method,
// to free the callback once it's dropped by Rust.
private let IDX_CALLBACK_FREE: Int32 = 0

// Declaration and FfiConverters for ClientDelegate Callback Interface

public protocol ClientDelegate : AnyObject {
    func `didReceiveSyncUpdate`() 
    func `didReceiveAuthError`(`isSoftLogout`: Bool) 
    func `didUpdateRestoreToken`() 
    
}

// The ForeignCallback that is passed to Rust.
fileprivate let foreignCallbackCallbackInterfaceClientDelegate : ForeignCallback =
    { (handle: UniFFICallbackHandle, method: Int32, args: RustBuffer, out_buf: UnsafeMutablePointer<RustBuffer>) -> Int32 in
        func `invokeDidReceiveSyncUpdate`(_ swiftCallbackInterface: ClientDelegate, _ args: RustBuffer) throws -> RustBuffer {
        defer { args.deallocate() }
            swiftCallbackInterface.`didReceiveSyncUpdate`()
            return RustBuffer()
                // TODO catch errors and report them back to Rust.
                // https://github.com/mozilla/uniffi-rs/issues/351

        }
        func `invokeDidReceiveAuthError`(_ swiftCallbackInterface: ClientDelegate, _ args: RustBuffer) throws -> RustBuffer {
        defer { args.deallocate() }

            var reader = createReader(data: Data(rustBuffer: args))
            swiftCallbackInterface.`didReceiveAuthError`(
                    `isSoftLogout`:  try FfiConverterBool.read(from: &reader)
                    )
            return RustBuffer()
                // TODO catch errors and report them back to Rust.
                // https://github.com/mozilla/uniffi-rs/issues/351

        }
        func `invokeDidUpdateRestoreToken`(_ swiftCallbackInterface: ClientDelegate, _ args: RustBuffer) throws -> RustBuffer {
        defer { args.deallocate() }
            swiftCallbackInterface.`didUpdateRestoreToken`()
            return RustBuffer()
                // TODO catch errors and report them back to Rust.
                // https://github.com/mozilla/uniffi-rs/issues/351

        }
        

        let cb: ClientDelegate
        do {
            cb = try FfiConverterCallbackInterfaceClientDelegate.lift(handle)
        } catch {
            out_buf.pointee = FfiConverterString.lower("ClientDelegate: Invalid handle")
            return -1
        }

        switch method {
            case IDX_CALLBACK_FREE:
                FfiConverterCallbackInterfaceClientDelegate.drop(handle: handle)
                // No return value.
                // See docs of ForeignCallback in `uniffi/src/ffi/foreigncallbacks.rs`
                return 0
            case 1:
                do {
                    out_buf.pointee = try `invokeDidReceiveSyncUpdate`(cb, args)
                    // Value written to out buffer.
                    // See docs of ForeignCallback in `uniffi/src/ffi/foreigncallbacks.rs`
                    return 1
                } catch let error {
                    out_buf.pointee = FfiConverterString.lower(String(describing: error))
                    return -1
                }
            case 2:
                do {
                    out_buf.pointee = try `invokeDidReceiveAuthError`(cb, args)
                    // Value written to out buffer.
                    // See docs of ForeignCallback in `uniffi/src/ffi/foreigncallbacks.rs`
                    return 1
                } catch let error {
                    out_buf.pointee = FfiConverterString.lower(String(describing: error))
                    return -1
                }
            case 3:
                do {
                    out_buf.pointee = try `invokeDidUpdateRestoreToken`(cb, args)
                    // Value written to out buffer.
                    // See docs of ForeignCallback in `uniffi/src/ffi/foreigncallbacks.rs`
                    return 1
                } catch let error {
                    out_buf.pointee = FfiConverterString.lower(String(describing: error))
                    return -1
                }
            
            // This should never happen, because an out of bounds method index won't
            // ever be used. Once we can catch errors, we should return an InternalError.
            // https://github.com/mozilla/uniffi-rs/issues/351
            default:
                // An unexpected error happened.
                // See docs of ForeignCallback in `uniffi/src/ffi/foreigncallbacks.rs`
                return -1
        }
    }

// FfiConverter protocol for callback interfaces
fileprivate struct FfiConverterCallbackInterfaceClientDelegate {
    // Initialize our callback method with the scaffolding code
    private static var callbackInitialized = false
    private static func initCallback() {
        try! rustCall { (err: UnsafeMutablePointer<RustCallStatus>) in
                ffi_matrix_sdk_ffi_7e42_ClientDelegate_init_callback(foreignCallbackCallbackInterfaceClientDelegate, err)
        }
    }
    private static func ensureCallbackinitialized() {
        if !callbackInitialized {
            initCallback()
            callbackInitialized = true
        }
    }

    static func drop(handle: UniFFICallbackHandle) {
        handleMap.remove(handle: handle)
    }

    private static var handleMap = UniFFICallbackHandleMap<ClientDelegate>()
}

extension FfiConverterCallbackInterfaceClientDelegate : FfiConverter {
    typealias SwiftType = ClientDelegate
    // We can use Handle as the FfiType because it's a typealias to UInt64
    typealias FfiType = UniFFICallbackHandle

    public static func lift(_ handle: UniFFICallbackHandle) throws -> SwiftType {
        ensureCallbackinitialized();
        guard let callback = handleMap.get(handle: handle) else {
            throw UniffiInternalError.unexpectedStaleHandle
        }
        return callback
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        ensureCallbackinitialized();
        let handle: UniFFICallbackHandle = try readInt(&buf)
        return try lift(handle)
    }

    public static func lower(_ v: SwiftType) -> UniFFICallbackHandle {
        ensureCallbackinitialized();
        return handleMap.insert(obj: v)
    }

    public static func write(_ v: SwiftType, into buf: inout [UInt8]) {
        ensureCallbackinitialized();
        writeInt(&buf, lower(v))
    }
}



// Declaration and FfiConverters for SessionVerificationControllerDelegate Callback Interface

public protocol SessionVerificationControllerDelegate : AnyObject {
    func `didAcceptVerificationRequest`() 
    func `didStartSasVerification`() 
    func `didReceiveVerificationData`(`data`: [SessionVerificationEmoji]) 
    func `didFail`() 
    func `didCancel`() 
    func `didFinish`() 
    
}

// The ForeignCallback that is passed to Rust.
fileprivate let foreignCallbackCallbackInterfaceSessionVerificationControllerDelegate : ForeignCallback =
    { (handle: UniFFICallbackHandle, method: Int32, args: RustBuffer, out_buf: UnsafeMutablePointer<RustBuffer>) -> Int32 in
        func `invokeDidAcceptVerificationRequest`(_ swiftCallbackInterface: SessionVerificationControllerDelegate, _ args: RustBuffer) throws -> RustBuffer {
        defer { args.deallocate() }
            swiftCallbackInterface.`didAcceptVerificationRequest`()
            return RustBuffer()
                // TODO catch errors and report them back to Rust.
                // https://github.com/mozilla/uniffi-rs/issues/351

        }
        func `invokeDidStartSasVerification`(_ swiftCallbackInterface: SessionVerificationControllerDelegate, _ args: RustBuffer) throws -> RustBuffer {
        defer { args.deallocate() }
            swiftCallbackInterface.`didStartSasVerification`()
            return RustBuffer()
                // TODO catch errors and report them back to Rust.
                // https://github.com/mozilla/uniffi-rs/issues/351

        }
        func `invokeDidReceiveVerificationData`(_ swiftCallbackInterface: SessionVerificationControllerDelegate, _ args: RustBuffer) throws -> RustBuffer {
        defer { args.deallocate() }

            var reader = createReader(data: Data(rustBuffer: args))
            swiftCallbackInterface.`didReceiveVerificationData`(
                    `data`:  try FfiConverterSequenceTypeSessionVerificationEmoji.read(from: &reader)
                    )
            return RustBuffer()
                // TODO catch errors and report them back to Rust.
                // https://github.com/mozilla/uniffi-rs/issues/351

        }
        func `invokeDidFail`(_ swiftCallbackInterface: SessionVerificationControllerDelegate, _ args: RustBuffer) throws -> RustBuffer {
        defer { args.deallocate() }
            swiftCallbackInterface.`didFail`()
            return RustBuffer()
                // TODO catch errors and report them back to Rust.
                // https://github.com/mozilla/uniffi-rs/issues/351

        }
        func `invokeDidCancel`(_ swiftCallbackInterface: SessionVerificationControllerDelegate, _ args: RustBuffer) throws -> RustBuffer {
        defer { args.deallocate() }
            swiftCallbackInterface.`didCancel`()
            return RustBuffer()
                // TODO catch errors and report them back to Rust.
                // https://github.com/mozilla/uniffi-rs/issues/351

        }
        func `invokeDidFinish`(_ swiftCallbackInterface: SessionVerificationControllerDelegate, _ args: RustBuffer) throws -> RustBuffer {
        defer { args.deallocate() }
            swiftCallbackInterface.`didFinish`()
            return RustBuffer()
                // TODO catch errors and report them back to Rust.
                // https://github.com/mozilla/uniffi-rs/issues/351

        }
        

        let cb: SessionVerificationControllerDelegate
        do {
            cb = try FfiConverterCallbackInterfaceSessionVerificationControllerDelegate.lift(handle)
        } catch {
            out_buf.pointee = FfiConverterString.lower("SessionVerificationControllerDelegate: Invalid handle")
            return -1
        }

        switch method {
            case IDX_CALLBACK_FREE:
                FfiConverterCallbackInterfaceSessionVerificationControllerDelegate.drop(handle: handle)
                // No return value.
                // See docs of ForeignCallback in `uniffi/src/ffi/foreigncallbacks.rs`
                return 0
            case 1:
                do {
                    out_buf.pointee = try `invokeDidAcceptVerificationRequest`(cb, args)
                    // Value written to out buffer.
                    // See docs of ForeignCallback in `uniffi/src/ffi/foreigncallbacks.rs`
                    return 1
                } catch let error {
                    out_buf.pointee = FfiConverterString.lower(String(describing: error))
                    return -1
                }
            case 2:
                do {
                    out_buf.pointee = try `invokeDidStartSasVerification`(cb, args)
                    // Value written to out buffer.
                    // See docs of ForeignCallback in `uniffi/src/ffi/foreigncallbacks.rs`
                    return 1
                } catch let error {
                    out_buf.pointee = FfiConverterString.lower(String(describing: error))
                    return -1
                }
            case 3:
                do {
                    out_buf.pointee = try `invokeDidReceiveVerificationData`(cb, args)
                    // Value written to out buffer.
                    // See docs of ForeignCallback in `uniffi/src/ffi/foreigncallbacks.rs`
                    return 1
                } catch let error {
                    out_buf.pointee = FfiConverterString.lower(String(describing: error))
                    return -1
                }
            case 4:
                do {
                    out_buf.pointee = try `invokeDidFail`(cb, args)
                    // Value written to out buffer.
                    // See docs of ForeignCallback in `uniffi/src/ffi/foreigncallbacks.rs`
                    return 1
                } catch let error {
                    out_buf.pointee = FfiConverterString.lower(String(describing: error))
                    return -1
                }
            case 5:
                do {
                    out_buf.pointee = try `invokeDidCancel`(cb, args)
                    // Value written to out buffer.
                    // See docs of ForeignCallback in `uniffi/src/ffi/foreigncallbacks.rs`
                    return 1
                } catch let error {
                    out_buf.pointee = FfiConverterString.lower(String(describing: error))
                    return -1
                }
            case 6:
                do {
                    out_buf.pointee = try `invokeDidFinish`(cb, args)
                    // Value written to out buffer.
                    // See docs of ForeignCallback in `uniffi/src/ffi/foreigncallbacks.rs`
                    return 1
                } catch let error {
                    out_buf.pointee = FfiConverterString.lower(String(describing: error))
                    return -1
                }
            
            // This should never happen, because an out of bounds method index won't
            // ever be used. Once we can catch errors, we should return an InternalError.
            // https://github.com/mozilla/uniffi-rs/issues/351
            default:
                // An unexpected error happened.
                // See docs of ForeignCallback in `uniffi/src/ffi/foreigncallbacks.rs`
                return -1
        }
    }

// FfiConverter protocol for callback interfaces
fileprivate struct FfiConverterCallbackInterfaceSessionVerificationControllerDelegate {
    // Initialize our callback method with the scaffolding code
    private static var callbackInitialized = false
    private static func initCallback() {
        try! rustCall { (err: UnsafeMutablePointer<RustCallStatus>) in
                ffi_matrix_sdk_ffi_7e42_SessionVerificationControllerDelegate_init_callback(foreignCallbackCallbackInterfaceSessionVerificationControllerDelegate, err)
        }
    }
    private static func ensureCallbackinitialized() {
        if !callbackInitialized {
            initCallback()
            callbackInitialized = true
        }
    }

    static func drop(handle: UniFFICallbackHandle) {
        handleMap.remove(handle: handle)
    }

    private static var handleMap = UniFFICallbackHandleMap<SessionVerificationControllerDelegate>()
}

extension FfiConverterCallbackInterfaceSessionVerificationControllerDelegate : FfiConverter {
    typealias SwiftType = SessionVerificationControllerDelegate
    // We can use Handle as the FfiType because it's a typealias to UInt64
    typealias FfiType = UniFFICallbackHandle

    public static func lift(_ handle: UniFFICallbackHandle) throws -> SwiftType {
        ensureCallbackinitialized();
        guard let callback = handleMap.get(handle: handle) else {
            throw UniffiInternalError.unexpectedStaleHandle
        }
        return callback
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        ensureCallbackinitialized();
        let handle: UniFFICallbackHandle = try readInt(&buf)
        return try lift(handle)
    }

    public static func lower(_ v: SwiftType) -> UniFFICallbackHandle {
        ensureCallbackinitialized();
        return handleMap.insert(obj: v)
    }

    public static func write(_ v: SwiftType, into buf: inout [UInt8]) {
        ensureCallbackinitialized();
        writeInt(&buf, lower(v))
    }
}



// Declaration and FfiConverters for SlidingSyncListRoomItemsObserver Callback Interface

public protocol SlidingSyncListRoomItemsObserver : AnyObject {
    func `didReceiveUpdate`() 
    
}

// The ForeignCallback that is passed to Rust.
fileprivate let foreignCallbackCallbackInterfaceSlidingSyncListRoomItemsObserver : ForeignCallback =
    { (handle: UniFFICallbackHandle, method: Int32, args: RustBuffer, out_buf: UnsafeMutablePointer<RustBuffer>) -> Int32 in
        func `invokeDidReceiveUpdate`(_ swiftCallbackInterface: SlidingSyncListRoomItemsObserver, _ args: RustBuffer) throws -> RustBuffer {
        defer { args.deallocate() }
            swiftCallbackInterface.`didReceiveUpdate`()
            return RustBuffer()
                // TODO catch errors and report them back to Rust.
                // https://github.com/mozilla/uniffi-rs/issues/351

        }
        

        let cb: SlidingSyncListRoomItemsObserver
        do {
            cb = try FfiConverterCallbackInterfaceSlidingSyncListRoomItemsObserver.lift(handle)
        } catch {
            out_buf.pointee = FfiConverterString.lower("SlidingSyncListRoomItemsObserver: Invalid handle")
            return -1
        }

        switch method {
            case IDX_CALLBACK_FREE:
                FfiConverterCallbackInterfaceSlidingSyncListRoomItemsObserver.drop(handle: handle)
                // No return value.
                // See docs of ForeignCallback in `uniffi/src/ffi/foreigncallbacks.rs`
                return 0
            case 1:
                do {
                    out_buf.pointee = try `invokeDidReceiveUpdate`(cb, args)
                    // Value written to out buffer.
                    // See docs of ForeignCallback in `uniffi/src/ffi/foreigncallbacks.rs`
                    return 1
                } catch let error {
                    out_buf.pointee = FfiConverterString.lower(String(describing: error))
                    return -1
                }
            
            // This should never happen, because an out of bounds method index won't
            // ever be used. Once we can catch errors, we should return an InternalError.
            // https://github.com/mozilla/uniffi-rs/issues/351
            default:
                // An unexpected error happened.
                // See docs of ForeignCallback in `uniffi/src/ffi/foreigncallbacks.rs`
                return -1
        }
    }

// FfiConverter protocol for callback interfaces
fileprivate struct FfiConverterCallbackInterfaceSlidingSyncListRoomItemsObserver {
    // Initialize our callback method with the scaffolding code
    private static var callbackInitialized = false
    private static func initCallback() {
        try! rustCall { (err: UnsafeMutablePointer<RustCallStatus>) in
                ffi_matrix_sdk_ffi_7e42_SlidingSyncListRoomItemsObserver_init_callback(foreignCallbackCallbackInterfaceSlidingSyncListRoomItemsObserver, err)
        }
    }
    private static func ensureCallbackinitialized() {
        if !callbackInitialized {
            initCallback()
            callbackInitialized = true
        }
    }

    static func drop(handle: UniFFICallbackHandle) {
        handleMap.remove(handle: handle)
    }

    private static var handleMap = UniFFICallbackHandleMap<SlidingSyncListRoomItemsObserver>()
}

extension FfiConverterCallbackInterfaceSlidingSyncListRoomItemsObserver : FfiConverter {
    typealias SwiftType = SlidingSyncListRoomItemsObserver
    // We can use Handle as the FfiType because it's a typealias to UInt64
    typealias FfiType = UniFFICallbackHandle

    public static func lift(_ handle: UniFFICallbackHandle) throws -> SwiftType {
        ensureCallbackinitialized();
        guard let callback = handleMap.get(handle: handle) else {
            throw UniffiInternalError.unexpectedStaleHandle
        }
        return callback
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        ensureCallbackinitialized();
        let handle: UniFFICallbackHandle = try readInt(&buf)
        return try lift(handle)
    }

    public static func lower(_ v: SwiftType) -> UniFFICallbackHandle {
        ensureCallbackinitialized();
        return handleMap.insert(obj: v)
    }

    public static func write(_ v: SwiftType, into buf: inout [UInt8]) {
        ensureCallbackinitialized();
        writeInt(&buf, lower(v))
    }
}



// Declaration and FfiConverters for SlidingSyncListRoomListObserver Callback Interface

public protocol SlidingSyncListRoomListObserver : AnyObject {
    func `didReceiveUpdate`(`diff`: SlidingSyncListRoomsListDiff) 
    
}

// The ForeignCallback that is passed to Rust.
fileprivate let foreignCallbackCallbackInterfaceSlidingSyncListRoomListObserver : ForeignCallback =
    { (handle: UniFFICallbackHandle, method: Int32, args: RustBuffer, out_buf: UnsafeMutablePointer<RustBuffer>) -> Int32 in
        func `invokeDidReceiveUpdate`(_ swiftCallbackInterface: SlidingSyncListRoomListObserver, _ args: RustBuffer) throws -> RustBuffer {
        defer { args.deallocate() }

            var reader = createReader(data: Data(rustBuffer: args))
            swiftCallbackInterface.`didReceiveUpdate`(
                    `diff`:  try FfiConverterTypeSlidingSyncListRoomsListDiff.read(from: &reader)
                    )
            return RustBuffer()
                // TODO catch errors and report them back to Rust.
                // https://github.com/mozilla/uniffi-rs/issues/351

        }
        

        let cb: SlidingSyncListRoomListObserver
        do {
            cb = try FfiConverterCallbackInterfaceSlidingSyncListRoomListObserver.lift(handle)
        } catch {
            out_buf.pointee = FfiConverterString.lower("SlidingSyncListRoomListObserver: Invalid handle")
            return -1
        }

        switch method {
            case IDX_CALLBACK_FREE:
                FfiConverterCallbackInterfaceSlidingSyncListRoomListObserver.drop(handle: handle)
                // No return value.
                // See docs of ForeignCallback in `uniffi/src/ffi/foreigncallbacks.rs`
                return 0
            case 1:
                do {
                    out_buf.pointee = try `invokeDidReceiveUpdate`(cb, args)
                    // Value written to out buffer.
                    // See docs of ForeignCallback in `uniffi/src/ffi/foreigncallbacks.rs`
                    return 1
                } catch let error {
                    out_buf.pointee = FfiConverterString.lower(String(describing: error))
                    return -1
                }
            
            // This should never happen, because an out of bounds method index won't
            // ever be used. Once we can catch errors, we should return an InternalError.
            // https://github.com/mozilla/uniffi-rs/issues/351
            default:
                // An unexpected error happened.
                // See docs of ForeignCallback in `uniffi/src/ffi/foreigncallbacks.rs`
                return -1
        }
    }

// FfiConverter protocol for callback interfaces
fileprivate struct FfiConverterCallbackInterfaceSlidingSyncListRoomListObserver {
    // Initialize our callback method with the scaffolding code
    private static var callbackInitialized = false
    private static func initCallback() {
        try! rustCall { (err: UnsafeMutablePointer<RustCallStatus>) in
                ffi_matrix_sdk_ffi_7e42_SlidingSyncListRoomListObserver_init_callback(foreignCallbackCallbackInterfaceSlidingSyncListRoomListObserver, err)
        }
    }
    private static func ensureCallbackinitialized() {
        if !callbackInitialized {
            initCallback()
            callbackInitialized = true
        }
    }

    static func drop(handle: UniFFICallbackHandle) {
        handleMap.remove(handle: handle)
    }

    private static var handleMap = UniFFICallbackHandleMap<SlidingSyncListRoomListObserver>()
}

extension FfiConverterCallbackInterfaceSlidingSyncListRoomListObserver : FfiConverter {
    typealias SwiftType = SlidingSyncListRoomListObserver
    // We can use Handle as the FfiType because it's a typealias to UInt64
    typealias FfiType = UniFFICallbackHandle

    public static func lift(_ handle: UniFFICallbackHandle) throws -> SwiftType {
        ensureCallbackinitialized();
        guard let callback = handleMap.get(handle: handle) else {
            throw UniffiInternalError.unexpectedStaleHandle
        }
        return callback
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        ensureCallbackinitialized();
        let handle: UniFFICallbackHandle = try readInt(&buf)
        return try lift(handle)
    }

    public static func lower(_ v: SwiftType) -> UniFFICallbackHandle {
        ensureCallbackinitialized();
        return handleMap.insert(obj: v)
    }

    public static func write(_ v: SwiftType, into buf: inout [UInt8]) {
        ensureCallbackinitialized();
        writeInt(&buf, lower(v))
    }
}



// Declaration and FfiConverters for SlidingSyncListRoomsCountObserver Callback Interface

public protocol SlidingSyncListRoomsCountObserver : AnyObject {
    func `didReceiveUpdate`(`count`: UInt32) 
    
}

// The ForeignCallback that is passed to Rust.
fileprivate let foreignCallbackCallbackInterfaceSlidingSyncListRoomsCountObserver : ForeignCallback =
    { (handle: UniFFICallbackHandle, method: Int32, args: RustBuffer, out_buf: UnsafeMutablePointer<RustBuffer>) -> Int32 in
        func `invokeDidReceiveUpdate`(_ swiftCallbackInterface: SlidingSyncListRoomsCountObserver, _ args: RustBuffer) throws -> RustBuffer {
        defer { args.deallocate() }

            var reader = createReader(data: Data(rustBuffer: args))
            swiftCallbackInterface.`didReceiveUpdate`(
                    `count`:  try FfiConverterUInt32.read(from: &reader)
                    )
            return RustBuffer()
                // TODO catch errors and report them back to Rust.
                // https://github.com/mozilla/uniffi-rs/issues/351

        }
        

        let cb: SlidingSyncListRoomsCountObserver
        do {
            cb = try FfiConverterCallbackInterfaceSlidingSyncListRoomsCountObserver.lift(handle)
        } catch {
            out_buf.pointee = FfiConverterString.lower("SlidingSyncListRoomsCountObserver: Invalid handle")
            return -1
        }

        switch method {
            case IDX_CALLBACK_FREE:
                FfiConverterCallbackInterfaceSlidingSyncListRoomsCountObserver.drop(handle: handle)
                // No return value.
                // See docs of ForeignCallback in `uniffi/src/ffi/foreigncallbacks.rs`
                return 0
            case 1:
                do {
                    out_buf.pointee = try `invokeDidReceiveUpdate`(cb, args)
                    // Value written to out buffer.
                    // See docs of ForeignCallback in `uniffi/src/ffi/foreigncallbacks.rs`
                    return 1
                } catch let error {
                    out_buf.pointee = FfiConverterString.lower(String(describing: error))
                    return -1
                }
            
            // This should never happen, because an out of bounds method index won't
            // ever be used. Once we can catch errors, we should return an InternalError.
            // https://github.com/mozilla/uniffi-rs/issues/351
            default:
                // An unexpected error happened.
                // See docs of ForeignCallback in `uniffi/src/ffi/foreigncallbacks.rs`
                return -1
        }
    }

// FfiConverter protocol for callback interfaces
fileprivate struct FfiConverterCallbackInterfaceSlidingSyncListRoomsCountObserver {
    // Initialize our callback method with the scaffolding code
    private static var callbackInitialized = false
    private static func initCallback() {
        try! rustCall { (err: UnsafeMutablePointer<RustCallStatus>) in
                ffi_matrix_sdk_ffi_7e42_SlidingSyncListRoomsCountObserver_init_callback(foreignCallbackCallbackInterfaceSlidingSyncListRoomsCountObserver, err)
        }
    }
    private static func ensureCallbackinitialized() {
        if !callbackInitialized {
            initCallback()
            callbackInitialized = true
        }
    }

    static func drop(handle: UniFFICallbackHandle) {
        handleMap.remove(handle: handle)
    }

    private static var handleMap = UniFFICallbackHandleMap<SlidingSyncListRoomsCountObserver>()
}

extension FfiConverterCallbackInterfaceSlidingSyncListRoomsCountObserver : FfiConverter {
    typealias SwiftType = SlidingSyncListRoomsCountObserver
    // We can use Handle as the FfiType because it's a typealias to UInt64
    typealias FfiType = UniFFICallbackHandle

    public static func lift(_ handle: UniFFICallbackHandle) throws -> SwiftType {
        ensureCallbackinitialized();
        guard let callback = handleMap.get(handle: handle) else {
            throw UniffiInternalError.unexpectedStaleHandle
        }
        return callback
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        ensureCallbackinitialized();
        let handle: UniFFICallbackHandle = try readInt(&buf)
        return try lift(handle)
    }

    public static func lower(_ v: SwiftType) -> UniFFICallbackHandle {
        ensureCallbackinitialized();
        return handleMap.insert(obj: v)
    }

    public static func write(_ v: SwiftType, into buf: inout [UInt8]) {
        ensureCallbackinitialized();
        writeInt(&buf, lower(v))
    }
}



// Declaration and FfiConverters for SlidingSyncListStateObserver Callback Interface

public protocol SlidingSyncListStateObserver : AnyObject {
    func `didReceiveUpdate`(`newState`: SlidingSyncState) 
    
}

// The ForeignCallback that is passed to Rust.
fileprivate let foreignCallbackCallbackInterfaceSlidingSyncListStateObserver : ForeignCallback =
    { (handle: UniFFICallbackHandle, method: Int32, args: RustBuffer, out_buf: UnsafeMutablePointer<RustBuffer>) -> Int32 in
        func `invokeDidReceiveUpdate`(_ swiftCallbackInterface: SlidingSyncListStateObserver, _ args: RustBuffer) throws -> RustBuffer {
        defer { args.deallocate() }

            var reader = createReader(data: Data(rustBuffer: args))
            swiftCallbackInterface.`didReceiveUpdate`(
                    `newState`:  try FfiConverterTypeSlidingSyncState.read(from: &reader)
                    )
            return RustBuffer()
                // TODO catch errors and report them back to Rust.
                // https://github.com/mozilla/uniffi-rs/issues/351

        }
        

        let cb: SlidingSyncListStateObserver
        do {
            cb = try FfiConverterCallbackInterfaceSlidingSyncListStateObserver.lift(handle)
        } catch {
            out_buf.pointee = FfiConverterString.lower("SlidingSyncListStateObserver: Invalid handle")
            return -1
        }

        switch method {
            case IDX_CALLBACK_FREE:
                FfiConverterCallbackInterfaceSlidingSyncListStateObserver.drop(handle: handle)
                // No return value.
                // See docs of ForeignCallback in `uniffi/src/ffi/foreigncallbacks.rs`
                return 0
            case 1:
                do {
                    out_buf.pointee = try `invokeDidReceiveUpdate`(cb, args)
                    // Value written to out buffer.
                    // See docs of ForeignCallback in `uniffi/src/ffi/foreigncallbacks.rs`
                    return 1
                } catch let error {
                    out_buf.pointee = FfiConverterString.lower(String(describing: error))
                    return -1
                }
            
            // This should never happen, because an out of bounds method index won't
            // ever be used. Once we can catch errors, we should return an InternalError.
            // https://github.com/mozilla/uniffi-rs/issues/351
            default:
                // An unexpected error happened.
                // See docs of ForeignCallback in `uniffi/src/ffi/foreigncallbacks.rs`
                return -1
        }
    }

// FfiConverter protocol for callback interfaces
fileprivate struct FfiConverterCallbackInterfaceSlidingSyncListStateObserver {
    // Initialize our callback method with the scaffolding code
    private static var callbackInitialized = false
    private static func initCallback() {
        try! rustCall { (err: UnsafeMutablePointer<RustCallStatus>) in
                ffi_matrix_sdk_ffi_7e42_SlidingSyncListStateObserver_init_callback(foreignCallbackCallbackInterfaceSlidingSyncListStateObserver, err)
        }
    }
    private static func ensureCallbackinitialized() {
        if !callbackInitialized {
            initCallback()
            callbackInitialized = true
        }
    }

    static func drop(handle: UniFFICallbackHandle) {
        handleMap.remove(handle: handle)
    }

    private static var handleMap = UniFFICallbackHandleMap<SlidingSyncListStateObserver>()
}

extension FfiConverterCallbackInterfaceSlidingSyncListStateObserver : FfiConverter {
    typealias SwiftType = SlidingSyncListStateObserver
    // We can use Handle as the FfiType because it's a typealias to UInt64
    typealias FfiType = UniFFICallbackHandle

    public static func lift(_ handle: UniFFICallbackHandle) throws -> SwiftType {
        ensureCallbackinitialized();
        guard let callback = handleMap.get(handle: handle) else {
            throw UniffiInternalError.unexpectedStaleHandle
        }
        return callback
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        ensureCallbackinitialized();
        let handle: UniFFICallbackHandle = try readInt(&buf)
        return try lift(handle)
    }

    public static func lower(_ v: SwiftType) -> UniFFICallbackHandle {
        ensureCallbackinitialized();
        return handleMap.insert(obj: v)
    }

    public static func write(_ v: SwiftType, into buf: inout [UInt8]) {
        ensureCallbackinitialized();
        writeInt(&buf, lower(v))
    }
}



// Declaration and FfiConverters for SlidingSyncObserver Callback Interface

public protocol SlidingSyncObserver : AnyObject {
    func `didReceiveSyncUpdate`(`summary`: UpdateSummary) 
    
}

// The ForeignCallback that is passed to Rust.
fileprivate let foreignCallbackCallbackInterfaceSlidingSyncObserver : ForeignCallback =
    { (handle: UniFFICallbackHandle, method: Int32, args: RustBuffer, out_buf: UnsafeMutablePointer<RustBuffer>) -> Int32 in
        func `invokeDidReceiveSyncUpdate`(_ swiftCallbackInterface: SlidingSyncObserver, _ args: RustBuffer) throws -> RustBuffer {
        defer { args.deallocate() }

            var reader = createReader(data: Data(rustBuffer: args))
            swiftCallbackInterface.`didReceiveSyncUpdate`(
                    `summary`:  try FfiConverterTypeUpdateSummary.read(from: &reader)
                    )
            return RustBuffer()
                // TODO catch errors and report them back to Rust.
                // https://github.com/mozilla/uniffi-rs/issues/351

        }
        

        let cb: SlidingSyncObserver
        do {
            cb = try FfiConverterCallbackInterfaceSlidingSyncObserver.lift(handle)
        } catch {
            out_buf.pointee = FfiConverterString.lower("SlidingSyncObserver: Invalid handle")
            return -1
        }

        switch method {
            case IDX_CALLBACK_FREE:
                FfiConverterCallbackInterfaceSlidingSyncObserver.drop(handle: handle)
                // No return value.
                // See docs of ForeignCallback in `uniffi/src/ffi/foreigncallbacks.rs`
                return 0
            case 1:
                do {
                    out_buf.pointee = try `invokeDidReceiveSyncUpdate`(cb, args)
                    // Value written to out buffer.
                    // See docs of ForeignCallback in `uniffi/src/ffi/foreigncallbacks.rs`
                    return 1
                } catch let error {
                    out_buf.pointee = FfiConverterString.lower(String(describing: error))
                    return -1
                }
            
            // This should never happen, because an out of bounds method index won't
            // ever be used. Once we can catch errors, we should return an InternalError.
            // https://github.com/mozilla/uniffi-rs/issues/351
            default:
                // An unexpected error happened.
                // See docs of ForeignCallback in `uniffi/src/ffi/foreigncallbacks.rs`
                return -1
        }
    }

// FfiConverter protocol for callback interfaces
fileprivate struct FfiConverterCallbackInterfaceSlidingSyncObserver {
    // Initialize our callback method with the scaffolding code
    private static var callbackInitialized = false
    private static func initCallback() {
        try! rustCall { (err: UnsafeMutablePointer<RustCallStatus>) in
                ffi_matrix_sdk_ffi_7e42_SlidingSyncObserver_init_callback(foreignCallbackCallbackInterfaceSlidingSyncObserver, err)
        }
    }
    private static func ensureCallbackinitialized() {
        if !callbackInitialized {
            initCallback()
            callbackInitialized = true
        }
    }

    static func drop(handle: UniFFICallbackHandle) {
        handleMap.remove(handle: handle)
    }

    private static var handleMap = UniFFICallbackHandleMap<SlidingSyncObserver>()
}

extension FfiConverterCallbackInterfaceSlidingSyncObserver : FfiConverter {
    typealias SwiftType = SlidingSyncObserver
    // We can use Handle as the FfiType because it's a typealias to UInt64
    typealias FfiType = UniFFICallbackHandle

    public static func lift(_ handle: UniFFICallbackHandle) throws -> SwiftType {
        ensureCallbackinitialized();
        guard let callback = handleMap.get(handle: handle) else {
            throw UniffiInternalError.unexpectedStaleHandle
        }
        return callback
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        ensureCallbackinitialized();
        let handle: UniFFICallbackHandle = try readInt(&buf)
        return try lift(handle)
    }

    public static func lower(_ v: SwiftType) -> UniFFICallbackHandle {
        ensureCallbackinitialized();
        return handleMap.insert(obj: v)
    }

    public static func write(_ v: SwiftType, into buf: inout [UInt8]) {
        ensureCallbackinitialized();
        writeInt(&buf, lower(v))
    }
}



// Declaration and FfiConverters for TimelineListener Callback Interface

public protocol TimelineListener : AnyObject {
    func `onUpdate`(`update`: TimelineDiff) 
    
}

// The ForeignCallback that is passed to Rust.
fileprivate let foreignCallbackCallbackInterfaceTimelineListener : ForeignCallback =
    { (handle: UniFFICallbackHandle, method: Int32, args: RustBuffer, out_buf: UnsafeMutablePointer<RustBuffer>) -> Int32 in
        func `invokeOnUpdate`(_ swiftCallbackInterface: TimelineListener, _ args: RustBuffer) throws -> RustBuffer {
        defer { args.deallocate() }

            var reader = createReader(data: Data(rustBuffer: args))
            swiftCallbackInterface.`onUpdate`(
                    `update`:  try FfiConverterTypeTimelineDiff.read(from: &reader)
                    )
            return RustBuffer()
                // TODO catch errors and report them back to Rust.
                // https://github.com/mozilla/uniffi-rs/issues/351

        }
        

        let cb: TimelineListener
        do {
            cb = try FfiConverterCallbackInterfaceTimelineListener.lift(handle)
        } catch {
            out_buf.pointee = FfiConverterString.lower("TimelineListener: Invalid handle")
            return -1
        }

        switch method {
            case IDX_CALLBACK_FREE:
                FfiConverterCallbackInterfaceTimelineListener.drop(handle: handle)
                // No return value.
                // See docs of ForeignCallback in `uniffi/src/ffi/foreigncallbacks.rs`
                return 0
            case 1:
                do {
                    out_buf.pointee = try `invokeOnUpdate`(cb, args)
                    // Value written to out buffer.
                    // See docs of ForeignCallback in `uniffi/src/ffi/foreigncallbacks.rs`
                    return 1
                } catch let error {
                    out_buf.pointee = FfiConverterString.lower(String(describing: error))
                    return -1
                }
            
            // This should never happen, because an out of bounds method index won't
            // ever be used. Once we can catch errors, we should return an InternalError.
            // https://github.com/mozilla/uniffi-rs/issues/351
            default:
                // An unexpected error happened.
                // See docs of ForeignCallback in `uniffi/src/ffi/foreigncallbacks.rs`
                return -1
        }
    }

// FfiConverter protocol for callback interfaces
fileprivate struct FfiConverterCallbackInterfaceTimelineListener {
    // Initialize our callback method with the scaffolding code
    private static var callbackInitialized = false
    private static func initCallback() {
        try! rustCall { (err: UnsafeMutablePointer<RustCallStatus>) in
                ffi_matrix_sdk_ffi_7e42_TimelineListener_init_callback(foreignCallbackCallbackInterfaceTimelineListener, err)
        }
    }
    private static func ensureCallbackinitialized() {
        if !callbackInitialized {
            initCallback()
            callbackInitialized = true
        }
    }

    static func drop(handle: UniFFICallbackHandle) {
        handleMap.remove(handle: handle)
    }

    private static var handleMap = UniFFICallbackHandleMap<TimelineListener>()
}

extension FfiConverterCallbackInterfaceTimelineListener : FfiConverter {
    typealias SwiftType = TimelineListener
    // We can use Handle as the FfiType because it's a typealias to UInt64
    typealias FfiType = UniFFICallbackHandle

    public static func lift(_ handle: UniFFICallbackHandle) throws -> SwiftType {
        ensureCallbackinitialized();
        guard let callback = handleMap.get(handle: handle) else {
            throw UniffiInternalError.unexpectedStaleHandle
        }
        return callback
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        ensureCallbackinitialized();
        let handle: UniFFICallbackHandle = try readInt(&buf)
        return try lift(handle)
    }

    public static func lower(_ v: SwiftType) -> UniFFICallbackHandle {
        ensureCallbackinitialized();
        return handleMap.insert(obj: v)
    }

    public static func write(_ v: SwiftType, into buf: inout [UInt8]) {
        ensureCallbackinitialized();
        writeInt(&buf, lower(v))
    }
}

fileprivate struct FfiConverterOptionUInt16: FfiConverterRustBuffer {
    typealias SwiftType = UInt16?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterUInt16.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterUInt16.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionUInt32: FfiConverterRustBuffer {
    typealias SwiftType = UInt32?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterUInt32.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterUInt32.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionInt32: FfiConverterRustBuffer {
    typealias SwiftType = Int32?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterInt32.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterInt32.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionUInt64: FfiConverterRustBuffer {
    typealias SwiftType = UInt64?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterUInt64.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterUInt64.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionBool: FfiConverterRustBuffer {
    typealias SwiftType = Bool?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterBool.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterBool.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionString: FfiConverterRustBuffer {
    typealias SwiftType = String?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterString.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterString.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeEventTimelineItem: FfiConverterRustBuffer {
    typealias SwiftType = EventTimelineItem?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeEventTimelineItem.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeEventTimelineItem.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeHomeserverLoginDetails: FfiConverterRustBuffer {
    typealias SwiftType = HomeserverLoginDetails?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeHomeserverLoginDetails.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeHomeserverLoginDetails.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeMediaSource: FfiConverterRustBuffer {
    typealias SwiftType = MediaSource?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeMediaSource.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeMediaSource.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeMessage: FfiConverterRustBuffer {
    typealias SwiftType = Message?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeMessage.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeMessage.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeRoom: FfiConverterRustBuffer {
    typealias SwiftType = Room?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeRoom.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeRoom.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeSlidingSyncList: FfiConverterRustBuffer {
    typealias SwiftType = SlidingSyncList?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeSlidingSyncList.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeSlidingSyncList.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeSlidingSyncRoom: FfiConverterRustBuffer {
    typealias SwiftType = SlidingSyncRoom?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeSlidingSyncRoom.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeSlidingSyncRoom.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeTimelineItem: FfiConverterRustBuffer {
    typealias SwiftType = TimelineItem?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeTimelineItem.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeTimelineItem.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeAudioInfo: FfiConverterRustBuffer {
    typealias SwiftType = AudioInfo?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeAudioInfo.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeAudioInfo.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeFileInfo: FfiConverterRustBuffer {
    typealias SwiftType = FileInfo?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeFileInfo.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeFileInfo.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeFormattedBody: FfiConverterRustBuffer {
    typealias SwiftType = FormattedBody?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeFormattedBody.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeFormattedBody.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeImageInfo: FfiConverterRustBuffer {
    typealias SwiftType = ImageInfo?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeImageInfo.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeImageInfo.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeInsertData: FfiConverterRustBuffer {
    typealias SwiftType = InsertData?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeInsertData.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeInsertData.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeRoomSubscription: FfiConverterRustBuffer {
    typealias SwiftType = RoomSubscription?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeRoomSubscription.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeRoomSubscription.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeSetData: FfiConverterRustBuffer {
    typealias SwiftType = SetData?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeSetData.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeSetData.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeThumbnailInfo: FfiConverterRustBuffer {
    typealias SwiftType = ThumbnailInfo?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeThumbnailInfo.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeThumbnailInfo.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeVideoInfo: FfiConverterRustBuffer {
    typealias SwiftType = VideoInfo?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeVideoInfo.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeVideoInfo.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeEventSendState: FfiConverterRustBuffer {
    typealias SwiftType = EventSendState?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeEventSendState.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeEventSendState.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeMembershipChange: FfiConverterRustBuffer {
    typealias SwiftType = MembershipChange?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeMembershipChange.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeMembershipChange.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeMessageType: FfiConverterRustBuffer {
    typealias SwiftType = MessageType?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeMessageType.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeMessageType.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeVirtualTimelineItem: FfiConverterRustBuffer {
    typealias SwiftType = VirtualTimelineItem?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeVirtualTimelineItem.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeVirtualTimelineItem.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionCallbackInterfaceClientDelegate: FfiConverterRustBuffer {
    typealias SwiftType = ClientDelegate?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterCallbackInterfaceClientDelegate.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterCallbackInterfaceClientDelegate.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionCallbackInterfaceSessionVerificationControllerDelegate: FfiConverterRustBuffer {
    typealias SwiftType = SessionVerificationControllerDelegate?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterCallbackInterfaceSessionVerificationControllerDelegate.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterCallbackInterfaceSessionVerificationControllerDelegate.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionCallbackInterfaceSlidingSyncObserver: FfiConverterRustBuffer {
    typealias SwiftType = SlidingSyncObserver?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterCallbackInterfaceSlidingSyncObserver.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterCallbackInterfaceSlidingSyncObserver.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionSequenceTypeTimelineItem: FfiConverterRustBuffer {
    typealias SwiftType = [TimelineItem]?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterSequenceTypeTimelineItem.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterSequenceTypeTimelineItem.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionSequenceTypeReaction: FfiConverterRustBuffer {
    typealias SwiftType = [Reaction]?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterSequenceTypeReaction.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterSequenceTypeReaction.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionSequenceTypeRequiredState: FfiConverterRustBuffer {
    typealias SwiftType = [RequiredState]?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterSequenceTypeRequiredState.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterSequenceTypeRequiredState.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterSequenceUInt8: FfiConverterRustBuffer {
    typealias SwiftType = [UInt8]

    public static func write(_ value: [UInt8], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterUInt8.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [UInt8] {
        let len: Int32 = try readInt(&buf)
        var seq = [UInt8]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterUInt8.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceString: FfiConverterRustBuffer {
    typealias SwiftType = [String]

    public static func write(_ value: [String], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterString.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String] {
        let len: Int32 = try readInt(&buf)
        var seq = [String]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterString.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeRoom: FfiConverterRustBuffer {
    typealias SwiftType = [Room]

    public static func write(_ value: [Room], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeRoom.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Room] {
        let len: Int32 = try readInt(&buf)
        var seq = [Room]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeRoom.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeSessionVerificationEmoji: FfiConverterRustBuffer {
    typealias SwiftType = [SessionVerificationEmoji]

    public static func write(_ value: [SessionVerificationEmoji], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeSessionVerificationEmoji.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [SessionVerificationEmoji] {
        let len: Int32 = try readInt(&buf)
        var seq = [SessionVerificationEmoji]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeSessionVerificationEmoji.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeTimelineItem: FfiConverterRustBuffer {
    typealias SwiftType = [TimelineItem]

    public static func write(_ value: [TimelineItem], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeTimelineItem.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [TimelineItem] {
        let len: Int32 = try readInt(&buf)
        var seq = [TimelineItem]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeTimelineItem.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeReaction: FfiConverterRustBuffer {
    typealias SwiftType = [Reaction]

    public static func write(_ value: [Reaction], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeReaction.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Reaction] {
        let len: Int32 = try readInt(&buf)
        var seq = [Reaction]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeReaction.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeRequiredState: FfiConverterRustBuffer {
    typealias SwiftType = [RequiredState]

    public static func write(_ value: [RequiredState], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeRequiredState.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [RequiredState] {
        let len: Int32 = try readInt(&buf)
        var seq = [RequiredState]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeRequiredState.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeRoomMember: FfiConverterRustBuffer {
    typealias SwiftType = [RoomMember]

    public static func write(_ value: [RoomMember], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeRoomMember.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [RoomMember] {
        let len: Int32 = try readInt(&buf)
        var seq = [RoomMember]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeRoomMember.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeRoomListEntry: FfiConverterRustBuffer {
    typealias SwiftType = [RoomListEntry]

    public static func write(_ value: [RoomListEntry], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeRoomListEntry.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [RoomListEntry] {
        let len: Int32 = try readInt(&buf)
        var seq = [RoomListEntry]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeRoomListEntry.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceOptionTypeSlidingSyncRoom: FfiConverterRustBuffer {
    typealias SwiftType = [SlidingSyncRoom?]

    public static func write(_ value: [SlidingSyncRoom?], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterOptionTypeSlidingSyncRoom.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [SlidingSyncRoom?] {
        let len: Int32 = try readInt(&buf)
        var seq = [SlidingSyncRoom?]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterOptionTypeSlidingSyncRoom.read(from: &buf))
        }
        return seq
    }
}

public func `genTransactionId`()  -> String {
    return try! FfiConverterString.lift(
        try!
    
    rustCall() {
    
    _uniffi_matrix_sdk_ffi_gen_transaction_id_2d4f($0)
}
    )
}



public func `mediaSourceFromUrl`(`url`: String)  -> MediaSource {
    return try! FfiConverterTypeMediaSource.lift(
        try!
    
    rustCall() {
    
    _uniffi_matrix_sdk_ffi_media_source_from_url_55aa(
        FfiConverterString.lower(`url`), $0)
}
    )
}



public func `messageEventContentFromMarkdown`(`md`: String)  -> RoomMessageEventContent {
    return try! FfiConverterTypeRoomMessageEventContent.lift(
        try!
    
    rustCall() {
    
    _uniffi_matrix_sdk_ffi_message_event_content_from_markdown_c8db(
        FfiConverterString.lower(`md`), $0)
}
    )
}



public func `setupOtlpTracing`(`filter`: String, `clientName`: String, `user`: String, `password`: String, `otlpEndpoint`: String)  {
    try!
    
    rustCall() {
    
    _uniffi_matrix_sdk_ffi_setup_otlp_tracing_bc07(
        FfiConverterString.lower(`filter`), 
        FfiConverterString.lower(`clientName`), 
        FfiConverterString.lower(`user`), 
        FfiConverterString.lower(`password`), 
        FfiConverterString.lower(`otlpEndpoint`), $0)
}
}


public func `setupTracing`(`filter`: String)  {
    try!
    
    rustCall() {
    
    _uniffi_matrix_sdk_ffi_setup_tracing_62d6(
        FfiConverterString.lower(`filter`), $0)
}
}


/**
 * Top level initializers and tear down methods.
 *
 * This is generated by uniffi.
 */
public enum MatrixSdkFfiLifecycle {
    /**
     * Initialize the FFI and Rust library. This should be only called once per application.
     */
    func initialize() {
    }
}